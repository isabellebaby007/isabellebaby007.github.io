<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Isabelle的博客小站</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="%5Bobject%20Object%5D" rel="hub"/>
    <description>Isabelle的博客小站</description>
    <pubDate>Thu, 05 Apr 2018 19:35:45 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>微信小游戏的关系链数据</title>
      <link>http://yoursite.com/2018/04/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84%E5%85%B3%E7%B3%BB%E9%93%BE%E6%95%B0%E6%8D%AE/</link>
      <guid>http://yoursite.com/2018/04/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84%E5%85%B3%E7%B3%BB%E9%93%BE%E6%95%B0%E6%8D%AE/</guid>
      <pubDate>Thu, 05 Apr 2018 19:20:59 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;微信用户的关系链数据组成&quot;&gt;&lt;a href=&quot;#微信用户的关系链数据组成&quot; class=&quot;headerlink&quot; title=&quot;微信用户的关系链数据组成&quot;&gt;&lt;/a&gt;微信用户的关系链数据组成&lt;/h3&gt;&lt;p&gt;包括两部分：&lt;/p&gt;
&lt;p&gt;​      该用户好友的用户数据  &lt;/p&gt;
&lt;p&gt;​       该用户所在的某个群的群成员的用户数据。&lt;/p&gt;
&lt;p&gt;获取关系链数据的API：&lt;/p&gt;
&lt;p&gt;​      &lt;a href=&quot;https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.getFriendCloudStorage.html?t=2018329&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wx.getFriendCloudStorage()&lt;/a&gt;获取当前用户也玩该小游戏的好友的用户数据&lt;/p&gt;
&lt;p&gt;​      &lt;a href=&quot;https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.getGroupCloudStorage.html?t=2018329&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wx.getGroupCloudStorage()&lt;/a&gt; 获取当前用户在某个群中也玩该小游戏的成员的用户数据&lt;/p&gt;
&lt;p&gt;API返回的结果为一个对象数组，数组的每一个元素都是一个表示用户数据的对象。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;openId&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;用户的openId&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;avatarUrI&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;用户的微信头像url&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nickName&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;用户的微信昵称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;用户的游戏数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="微信用户的关系链数据组成"><a href="#微信用户的关系链数据组成" class="headerlink" title="微信用户的关系链数据组成"></a>微信用户的关系链数据组成</h3><p>包括两部分：</p><p>​      该用户好友的用户数据  </p><p>​       该用户所在的某个群的群成员的用户数据。</p><p>获取关系链数据的API：</p><p>​      <a href="https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.getFriendCloudStorage.html?t=2018329" target="_blank" rel="noopener">wx.getFriendCloudStorage()</a>获取当前用户也玩该小游戏的好友的用户数据</p><p>​      <a href="https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.getGroupCloudStorage.html?t=2018329" target="_blank" rel="noopener">wx.getGroupCloudStorage()</a> 获取当前用户在某个群中也玩该小游戏的成员的用户数据</p><p>API返回的结果为一个对象数组，数组的每一个元素都是一个表示用户数据的对象。</p><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>openId</td><td>string</td><td>用户的openId</td></tr><tr><td>avatarUrI</td><td>string</td><td>用户的微信头像url</td></tr><tr><td>nickName</td><td>string</td><td>用户的微信昵称</td></tr><tr><td>data</td><td>Object</td><td>用户的游戏数据</td></tr></tbody></table><a id="more"></a><h3 id="关系链数据的应用场景"><a href="#关系链数据的应用场景" class="headerlink" title="关系链数据的应用场景"></a>关系链数据的应用场景</h3><p>例如 用户的段位、战绩、积分等排行榜，这些游戏业务特有的数据，都可以用到这个功能。</p><p>通过调用 <a href="https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.setUserCloudStorage.html?t=2018329" target="_blank" rel="noopener">wx.setUserCloudStorage()</a> 可以将当前用户的游戏数据托管在微信后台。只有被托管过数据的用户，才会被视为 <code>玩过</code> 该小游戏的用户，才会出现在 <a href="https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.getFriendCloudStorage.html?t=2018329" target="_blank" rel="noopener">wx.getFriendCloudStorage()</a> 和 <a href="https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.getGroupCloudStorage.html?t=2018329" target="_blank" rel="noopener">wx.getGroupCloudStorage()</a> 返回的对象数组中。</p><p>除此之外，我们还提供了以下 API：</p><ul><li><a href="https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.removeUserCloudStorage.html?t=2018329" target="_blank" rel="noopener">wx.removeUserCloudStorage()</a> 删除用户托管数据中指定字段的数据</li><li><a href="https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.getUserCloudStorage.html?t=2018329" target="_blank" rel="noopener">wx.getUserCloudStorage()</a> 获取当前用户的托管数据</li></ul><p><a href="https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.getUserCloudStorage.html?t=2018329" target="_blank" rel="noopener">wx.getUserCloudStorage</a>、<a href="https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.getFriendCloudStorage.html?t=2018329" target="_blank" rel="noopener">wx.getFriendCloudStorage()</a> 和 <a href="https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.getGroupCloudStorage.html?t=2018329" target="_blank" rel="noopener">wx.getGroupCloudStorage()</a> 只能在 <code>开放数据域</code> 中调用。<br><a href="https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.setUserCloudStorage.html?t=2018329" target="_blank" rel="noopener">wx.setUserCloudStorage()</a> 和 <a href="https://developers.weixin.qq.com/minigame/dev/document/open-api/data/wx.removeUserCloudStorage.html?t=2018329" target="_blank" rel="noopener">wx.removeUserCloudStorage()</a> 可以同时在 <code>主域</code> 和开放数据域中调用。</p><h3 id="展示关系链数据"><a href="#展示关系链数据" class="headerlink" title="展示关系链数据"></a>展示关系链数据</h3><p>如果想要展示通过关系链 API 获取到的用户数据，如绘制排行榜等业务场景，需要将排行榜绘制到 <code>sharedCanvas</code> 上，再在主域将 sharedCanvas 渲染上屏。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/04/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84%E5%85%B3%E7%B3%BB%E9%93%BE%E6%95%B0%E6%8D%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>微信小游戏的Adapter适配层</title>
      <link>http://yoursite.com/2018/04/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84Adapter%E9%80%82%E9%85%8D%E5%B1%82/</link>
      <guid>http://yoursite.com/2018/04/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84Adapter%E9%80%82%E9%85%8D%E5%B1%82/</guid>
      <pubDate>Thu, 05 Apr 2018 17:54:24 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;为什么要用Adapter&quot;&gt;&lt;a href=&quot;#为什么要用Adapter&quot; class=&quot;headerlink&quot; title=&quot;为什么要用Adapter&quot;&gt;&lt;/a&gt;为什么要用Adapter&lt;/h3&gt;&lt;p&gt;因为小游戏的运行环境在IOS上是javaScriptCore
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="为什么要用Adapter"><a href="#为什么要用Adapter" class="headerlink" title="为什么要用Adapter"></a>为什么要用Adapter</h3><p>因为小游戏的运行环境在IOS上是javaScriptCore,在安卓上是V8，都没有BOM和DOM的运行环境，没有全局的document和window对象。因此如果直接用DOM API来创建Canvas和Image等元素的时候，会引发错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas=<span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)   <span class="comment">//出现错误</span></span><br></pre></td></tr></table></figure><p>但是我们可以使用wx.createCanvas和wx.createImage来封装一个document。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">document</span>=&#123;</span><br><span class="line">    createElement:<span class="function"><span class="keyword">function</span>(<span class="params">tagName</span>)</span>&#123;</span><br><span class="line">        tagName = tagName.toLowerCase()</span><br><span class="line">        <span class="keyword">if</span>(tagName===<span class="string">'canvas'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> wx.createCanvas()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tagName=== <span class="string">'image'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> wx.createImage()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装了上面的函数之后，我们就可以直接创建元素Canvas和Image了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas=<span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">var</span> image=<span class="built_in">document</span>.createImage(<span class="string">'image'</span>)</span><br></pre></td></tr></table></figure><p>同样，如果想实现 new Image() 的方式创建 Image 对象，只须添加如下代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Image</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wx.createImage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Adapter是用户代码，是用来使游戏引擎适配小游戏的运行环境"><a href="#Adapter是用户代码，是用来使游戏引擎适配小游戏的运行环境" class="headerlink" title="Adapter是用户代码，是用来使游戏引擎适配小游戏的运行环境"></a>Adapter是用户代码，是用来使游戏引擎适配小游戏的运行环境</h3><p>原因：因为小游戏的宿主环境根本没有提供document和window这两个在浏览器中内置的全局变量，而H5游戏基本上大量地使用到这些DOM和BOM API 。Adapter即在引擎和游戏逻辑代码之间加一层模拟 BOM 和 DOM API 的适配层，我们称之为 Adapter。这层适配层在全局通过 wx API 模拟了引擎会访问到的那部分 window 和 document 对象的属性和方法，使引擎感受不到环境的差异。</p><p><img src="https://developers.weixin.qq.com/minigame/dev/tutorial/images/framework-1.png" alt=""></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/04/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84Adapter%E9%80%82%E9%85%8D%E5%B1%82/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js之二分查找</title>
      <link>http://yoursite.com/2018/03/31/js%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <guid>http://yoursite.com/2018/03/31/js%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <pubDate>Sat, 31 Mar 2018 10:01:38 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;二分查找基本思路描述&quot;&gt;&lt;a href=&quot;#二分查找基本思路描述&quot; class=&quot;headerlink&quot; title=&quot;二分查找基本思路描述&quot;&gt;&lt;/a&gt;二分查找基本思路描述&lt;/h3&gt;&lt;p&gt;采用二分查找之前，数据应该是排好序的。&lt;/p&gt;
&lt;p&gt;主要思路是：设查找的数组区间为array[s,e]&lt;/p&gt;
&lt;p&gt;(1)确定区间的中间位置&lt;/p&gt;
&lt;p&gt;(2)将要查找的值x与数组中间位置的值作比较array[m]，查找成功则返回此位置；否则重复1、2步，继续确定新的查找位置，继续二分查找。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="二分查找基本思路描述"><a href="#二分查找基本思路描述" class="headerlink" title="二分查找基本思路描述"></a>二分查找基本思路描述</h3><p>采用二分查找之前，数据应该是排好序的。</p><p>主要思路是：设查找的数组区间为array[s,e]</p><p>(1)确定区间的中间位置</p><p>(2)将要查找的值x与数组中间位置的值作比较array[m]，查找成功则返回此位置；否则重复1、2步，继续确定新的查找位置，继续二分查找。</p><a id="more"></a><p>区域确定过程：这里假设array是按照从小到大的顺序排列的</p><p>array[m]&gt;T由数组的有序性可知array[m,…..,e]都大于T;</p><p>故新的区间为array[s,…….m-1],</p><p>重复上述步骤，每一次查找与中间值进行比较，判断是否成功，不成功则当前查找区间缩小一半，循环查找，即可。</p><p>时间复杂度为O（log2 n）；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> arr2=[<span class="number">88</span>,<span class="number">77</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">44</span>,<span class="number">33</span>,<span class="number">22</span>,<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">BinarySearch(arr1,<span class="number">2</span>);</span><br><span class="line">BinarySearch(arr2,<span class="number">77</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearch</span>(<span class="params">arr,target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> e=arr.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> m=<span class="built_in">Math</span>.floor((s+e)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> sortTag=arr[s]&lt;=arr[e];  <span class="comment">//确定排序的顺序是升序还是降序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(s&lt;e &amp;&amp; arr[m] !==target)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[m] &gt;target)&#123;</span><br><span class="line">        sortTag &amp;&amp; (e=m<span class="number">-1</span>); <span class="comment">//</span></span><br><span class="line">        !sortTag &amp;&amp; (s=m+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        !sortTag &amp;&amp; (e=m<span class="number">-1</span>);</span><br><span class="line">        sortTag &amp;&amp; (s=m+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m=<span class="built_in">Math</span>.floor((s+e)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(arr[m] == target)&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'找到了，位于%s'</span>,m);</span><br><span class="line">       <span class="keyword">return</span> m;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'没找到'</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了&amp;&amp; 的短路原理：</p><p>1、只要 &amp;&amp; 前面是false,无论 &amp;&amp; 后面是true还是false,结果都将返回 &amp;&amp; 前面的值</p><p>2、只要 &amp;&amp; 前面是true，无论 &amp;&amp; 后面是true还是false,结果都将返回 &amp;&amp; 后面的值。</p><p>例如：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">0</span> <span class="symbol">&amp;&amp;</span> 'a')<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>结果返回0， &amp;&amp; 前面 0 是false,后面 a是true,所以直接分返回前面的值</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/31/js%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>react router之router参数传递</title>
      <link>http://yoursite.com/2018/03/21/react-router%E4%B9%8Brouter%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</link>
      <guid>http://yoursite.com/2018/03/21/react-router%E4%B9%8Brouter%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</guid>
      <pubDate>Wed, 21 Mar 2018 11:00:07 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://yoursite.com/2018/03/21/react-router%E4%B9%8Brouter%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/#disqus_thread</comments>
    </item>
    
    <item>
      <title>react router之router概念</title>
      <link>http://yoursite.com/2018/03/21/react-router%E4%B9%8Brouter%E6%A6%82%E5%BF%B5/</link>
      <guid>http://yoursite.com/2018/03/21/react-router%E4%B9%8Brouter%E6%A6%82%E5%BF%B5/</guid>
      <pubDate>Wed, 21 Mar 2018 10:59:56 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;router简介&quot;&gt;&lt;a href=&quot;#router简介&quot; class=&quot;headerlink&quot; title=&quot;router简介&quot;&gt;&lt;/a&gt;router简介&lt;/h3&gt;&lt;p&gt;推荐使用react router插件： &lt;a href=&quot;https://github.co
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="router简介"><a href="#router简介" class="headerlink" title="router简介"></a>router简介</h3><p>推荐使用react router插件： <a href="https://github.com/ReactTraining/react-router" target="_blank" rel="noopener">https://github.com/ReactTraining/react-router</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/21/react-router%E4%B9%8Brouter%E6%A6%82%E5%BF%B5/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
