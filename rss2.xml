<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Isabelle的博客小站</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="%5Bobject%20Object%5D" rel="hub"/>
    <description>Isabelle的博客小站</description>
    <pubDate>Fri, 23 Feb 2018 14:59:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>前端利器——6款开源web性能优化辅助工具</title>
      <link>http://yoursite.com/2018/02/23/%E5%89%8D%E7%AB%AF%E5%88%A9%E5%99%A8%E2%80%94%E2%80%946%E6%AC%BE%E5%BC%80%E6%BA%90web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/</link>
      <guid>http://yoursite.com/2018/02/23/%E5%89%8D%E7%AB%AF%E5%88%A9%E5%99%A8%E2%80%94%E2%80%946%E6%AC%BE%E5%BC%80%E6%BA%90web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/</guid>
      <pubDate>Fri, 23 Feb 2018 14:25:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;Web 性能优化是一个老生常谈的话题，也是前端页面开发十分重要的部分。当页面加载速度越慢，用户流失的概率就越大，性能和交互直接影响用户体验。&lt;br&gt;下面推荐几款 Web 性能优化辅助工具推荐，希望能对大家有所帮助  &lt;/p&gt;
&lt;h4 id=&quot;Lighthouse&quot;&gt;&lt;a href=&quot;#Lighthouse&quot; class=&quot;headerlink&quot; title=&quot;Lighthouse&quot;&gt;&lt;/a&gt;Lighthouse&lt;/h4&gt;&lt;p&gt;Lighthouse 是 Google 开源的一个自动化工具，用于改进网络应用的质量。你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Web 性能优化是一个老生常谈的话题，也是前端页面开发十分重要的部分。当页面加载速度越慢，用户流失的概率就越大，性能和交互直接影响用户体验。<br>下面推荐几款 Web 性能优化辅助工具推荐，希望能对大家有所帮助  </p><h4 id="Lighthouse"><a href="#Lighthouse" class="headerlink" title="Lighthouse"></a>Lighthouse</h4><p>Lighthouse 是 Google 开源的一个自动化工具，用于改进网络应用的质量。你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。<a id="more"></a></p><p>当为 Lighthouse 提供一个要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。可以参考失败的测试，看看可以采取哪些措施来改进应用。  </p><p>Chrom 扩展则会把报告以非常人性化的图形界面展示给你。  </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibxYFwdzvMX2PbAak3hgHs2obIJxZ8fTqE62hRcCdHgxY1BlKl4OWIVg29ZoGKcxrprlRKa2ZYuTw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">  </p><p>传送门：www.oschina.net/p/lighthouse  </p><h4 id="Speed-Racer"><a href="#Speed-Racer" class="headerlink" title="Speed Racer"></a>Speed Racer</h4><p>SpeedRacer 是一款性能测试工具，它在 Chrome 中运行脚本，并生成详细的性能报告。  </p><p>SpeedRacer 是直接借助浏览器来实际测试性能的工具，在实际工作中，可以与其它模拟用户访问流量来评估性能的工具配合使用。  </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibxYFwdzvMX2PbAak3hgHs2eMnibRGSmDBZzwtrTNFU1Z27c4rDA418r3wHc9maibAQk4tc0DIbn2Tw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">  </p><p>传送门：<a href="https://github.com/speedracer/speedracer" target="_blank" rel="noopener">https://github.com/speedracer/speedracer</a>  </p><h4 id="Yellow-Lab-Tools"><a href="#Yellow-Lab-Tools" class="headerlink" title="Yellow Lab Tools"></a>Yellow Lab Tools</h4><p>Yellow Lab Tools 是一款 Web 性能及前端质量测试工具。与其他工具不同的是，它有一些在其他工具上无法看到的独特功能，例如页面加载时 JavaScript 与 DOM 互动和其他程序代码验证问题。  </p><p>Yellow Lab Tools 偏向于一个发现不良实践的工具，会综合页面权重、请求数、DOM、错误的 Javascript、错误的 CSS 等方面取得一个评分。并显示出在加载页面的过程中，DOM 是如何相互影响。  </p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/dkwuWwLoRKibxYFwdzvMX2PbAak3hgHs2wdjqX4Cr8gd0UL3aWnibQ9udHSaRPKqmfBU5GWCbajXgsficudj9r8fw/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">  </p><p>传送门：<a href="https://yellowlab.tools/" target="_blank" rel="noopener">https://yellowlab.tools/</a>  </p><h4 id="Web-Tracing-Framework"><a href="#Web-Tracing-Framework" class="headerlink" title="Web Tracing Framework"></a>Web Tracing Framework</h4><p>Web Tracing Framework 也是 Google 推出的一组用于跟踪和调查复杂 Web 应用的库、工具和可视化工具合集。它可以帮助发现性能问题，跟踪回归，并构建流畅的 60fps Web 应用。能让你花更少时间来测试代码即可。  </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibxYFwdzvMX2PbAak3hgHs2icIN99tX5dFXPcs2NmJQ4ROCULaPdjgMTYDHweH8gVNiaX1d1vKwtGJA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">  </p><p>传送门：www.oschina.net/p/tracing-framework  </p><h4 id="grunt-perfbudget"><a href="#grunt-perfbudget" class="headerlink" title="grunt-perfbudget"></a>grunt-perfbudget</h4><p>grunt-perfbudget 是一款用于评估性能的 Grunt task，它使用 WebPagetest 的公有或私有实例在特定的 URL 进行测试，并将测试结果和你预期的性能期望做比较。  </p><p>如果小于预期，那么这个 task 就顺利完成了，如果超过了预期的性能期望，那么就会报告失败，并帮助你分析超出预期的原因。  </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibxYFwdzvMX2PbAak3hgHs2DLSNAsryvtbApayL9uM19YD0vVxZqY5mQC8ibEoZIUicHQUmGuZ1QEBQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">  </p><p>传送门：<a href="https://github.com/tkadlec/grunt-perfbudget" target="_blank" rel="noopener">https://github.com/tkadlec/grunt-perfbudget</a>  </p><h4 id="Sitespeed-io"><a href="#Sitespeed-io" class="headerlink" title="Sitespeed.io"></a>Sitespeed.io</h4><p>Sitespeed.io 是一组基于最佳实践以及一些加载时序等量化标准的开源工具，用以帮助开发者分析网页的加载速度和渲染性能。  </p><p>Sitespeed.io 从开发者的站点收集多个页面的数据，并根据最佳实践等规则来分析这些网页，然后将结果以 HTML 的形式输出，或者以数值的形式发送到 Graphite 。  </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibxYFwdzvMX2PbAak3hgHs2mPUS1BvN0PF6ZVDVdicvM6HoQ6bjquP4NFcc9ytYLtzZNO3yCOBg7kg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">  </p><p>传送门：<a href="https://www-origin.sitespeed.io/" target="_blank" rel="noopener">https://www-origin.sitespeed.io/</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/23/%E5%89%8D%E7%AB%AF%E5%88%A9%E5%99%A8%E2%80%94%E2%80%946%E6%AC%BE%E5%BC%80%E6%BA%90web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>给博客添加feed</title>
      <link>http://yoursite.com/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed/</link>
      <guid>http://yoursite.com/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed/</guid>
      <pubDate>Fri, 23 Feb 2018 13:36:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;安装hexo-generator-feed  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install hexo-generator-feed --save  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置到站点配置文件_config.yml&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>安装hexo-generator-feed  </p><pre><code>$ npm install hexo-generator-feed --save  </code></pre><p>配置到站点配置文件_config.yml  <a id="more"></a></p><pre><code># Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20  </code></pre><p>最后，在你next主题下的_config.yml下，添加RSS订阅链接即可：  </p><pre><code>rss: /atom.xml</code></pre>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed/#disqus_thread</comments>
    </item>
    
    <item>
      <title>给博客添加站点地图</title>
      <link>http://yoursite.com/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/</link>
      <guid>http://yoursite.com/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/</guid>
      <pubDate>Fri, 23 Feb 2018 13:29:12 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;安装hexo-generator-seo-friendly-sitemap  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install hexo-generator-seo-friendly-sitemap --save  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在站点配置文件
        
      
      </description>
      
      <content:encoded><![CDATA[<p>安装hexo-generator-seo-friendly-sitemap  </p><pre><code>$ npm install hexo-generator-seo-friendly-sitemap --save  </code></pre><p>在站点配置文件_config.yml中添加  </p><pre><code>sitemap:    path: sitemap.xml</code></pre>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo添加站内搜索</title>
      <link>http://yoursite.com/2018/02/23/hexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/</link>
      <guid>http://yoursite.com/2018/02/23/hexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/</guid>
      <pubDate>Fri, 23 Feb 2018 12:49:43 GMT</pubDate>
      <description>
      
        &lt;p&gt;NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。<a id="more"></a> </p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="安装hexo-generator-search"><a href="#安装hexo-generator-search" class="headerlink" title="安装hexo-generator-search"></a>安装hexo-generator-search</h4><p>在站点的根目录下执行：  </p><pre><code>$ npm install hexo-generator-search --save  </code></pre><h4 id="安装hexo-generator-searchdb"><a href="#安装hexo-generator-searchdb" class="headerlink" title="安装hexo-generator-searchdb"></a>安装hexo-generator-searchdb</h4><p>在站点的根目录下执行：  </p><pre><code>$ npm install hexo-generator-searchdb --save  </code></pre><h4 id="启用搜索"><a href="#启用搜索" class="headerlink" title="启用搜索"></a>启用搜索</h4><p>编辑站点配置文件，加入以下代码： </p><pre><code>search:  path: search.xml  field: post  format: html  limit: 10000</code></pre>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/23/hexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>元素各种位置宽高</title>
      <link>http://yoursite.com/2018/02/23/%E5%85%83%E7%B4%A0%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%AE%BD%E9%AB%98/</link>
      <guid>http://yoursite.com/2018/02/23/%E5%85%83%E7%B4%A0%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%AE%BD%E9%AB%98/</guid>
      <pubDate>Thu, 22 Feb 2018 19:40:33 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;offsetLeft&quot;&gt;&lt;a href=&quot;#offsetLeft&quot; class=&quot;headerlink&quot; title=&quot;offsetLeft&quot;&gt;&lt;/a&gt;offsetLeft&lt;/h3&gt;&lt;p&gt;offsetLeft[Top]:只读，属性，当前元素到定位父级的距离（偏移值），就是到当前元素的offsetParent的距离。  &lt;/p&gt;
&lt;h4 id=&quot;当前元素没有定位，但是有定位父级&quot;&gt;&lt;a href=&quot;#当前元素没有定位，但是有定位父级&quot; class=&quot;headerlink&quot; title=&quot;当前元素没有定位，但是有定位父级&quot;&gt;&lt;/a&gt;当前元素没有定位，但是有定位父级&lt;/h4&gt;&lt;p&gt;css部分：&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="offsetLeft"><a href="#offsetLeft" class="headerlink" title="offsetLeft"></a>offsetLeft</h3><p>offsetLeft[Top]:只读，属性，当前元素到定位父级的距离（偏移值），就是到当前元素的offsetParent的距离。  </p><h4 id="当前元素没有定位，但是有定位父级"><a href="#当前元素没有定位，但是有定位父级" class="headerlink" title="当前元素没有定位，但是有定位父级"></a>当前元素没有定位，但是有定位父级</h4><p>css部分：  <a id="more"></a></p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;position: relative;}#div3 {background: orange; }&lt;/style&gt;  </code></pre><p>js部分：  </p><pre><code>window.onload = function() {    var oDiv3 = document.getElementById(&apos;div3&apos;);  alert( oDiv3.offsetLeft );    }  </code></pre><p>html部分:  </p><pre><code>&lt;body id=&quot;body1&quot;&gt;    &lt;div id=&quot;div1&quot;&gt;        &lt;div id=&quot;div2&quot;&gt;            &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;  </code></pre><p>上述代码在ie11和Ie7的效果如下两图所示，可以得出结论： 在ie7下，如果自己没有定位，那么offsetLeft[Top]是到body的距离。 所以会显示100px</p><p><img src="/2018/02/23/元素各种位置宽高/ie11标准.png" alt="">  </p><p><img src="/2018/02/23/元素各种位置宽高/ie7非标准.png" alt="">  </p><h4 id="当前元素有定位的情况，且定位父级"><a href="#当前元素有定位的情况，且定位父级" class="headerlink" title="当前元素有定位的情况，且定位父级"></a>当前元素有定位的情况，且定位父级</h4><p>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;position: relative;}#div3 {background: orange;position: relative; }&lt;/style&gt;  </code></pre><p>其余部分代码同上个例子。ie11的效果同上个例子，但是Ie7的效果发生了变化，当前元素有定位的情况下，是到定位父级的距离。</p><p><img src="/2018/02/23/元素各种位置宽高/有定位.png" alt="">  </p><h4 id="当前元素有定位，但是没有定位父级"><a href="#当前元素有定位，但是没有定位父级" class="headerlink" title="当前元素有定位，但是没有定位父级"></a>当前元素有定位，但是没有定位父级</h4><p>当前元素如果没有定位父级，offsetLeft默认的情况下是到body的，但是在Ie7下是指向到html的(在ie7以下body的默认margin-left值是10px)。<br>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;}#div3 {background: orange;position: relative; }&lt;/style&gt;  </code></pre><p>其余部分代码同例子一。  </p><p><img src="/2018/02/23/元素各种位置宽高/108.png" alt="">  </p><p><img src="/2018/02/23/元素各种位置宽高/110.png" alt="">  </p><h3 id="offsetTop"><a href="#offsetTop" class="headerlink" title="offsetTop"></a>offsetTop</h3><p>css部分：  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;}#div3 {background: orange;position: relative; }&lt;/style&gt;  </code></pre><p>js部分:  </p><pre><code>window.onload = function() {    var oDiv3 = document.getElementById(&apos;div3&apos;);  alert( oDiv3.offsetLeft );    }  </code></pre><p>效果如下,得出结论：ie7下的html默认margin-top是15px</p><p><img src="/2018/02/23/元素各种位置宽高/88.png" alt=""> </p><p><img src="/2018/02/23/元素各种位置宽高/95.png" alt=""> </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果有定位父级：<br>ie7以下：如果自己没有定位，那么offsetLeft[Top]是到body的距离；<br>如果自己有定位，那么就是到定位父级的距离。<br>其他浏览器：到定位父级的距离。  </p><h3 id="元素宽高"><a href="#元素宽高" class="headerlink" title="元素宽高"></a>元素宽高</h3><p>html部分：  </p><pre><code>&lt;body&gt;    &lt;div id=&quot;div1&quot; style=&quot;width: 100px; height: 100px; border: 1px solid red; padding: 10px; margin: 10px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;  </code></pre><p>js部分:  </p><pre><code>&lt;script&gt;window.onload = function() {    var oDiv = document.getElementById(&apos;div1&apos;);alert( oDiv.style.width );    //样式宽100alert( oDiv.clientWidth );    //样式宽 + padding=可视区宽    120alert( oDiv.offsetWidth );    //样式宽 + padding + border  可视区宽 + 边框    122    }  &lt;script&gt;  </code></pre><p>得到三个宽度分别为:  </p><p><img src="/2018/02/23/元素各种位置宽高/宽高1.png" alt="">  </p><p><img src="/2018/02/23/元素各种位置宽高/宽高2.png" alt="">  </p><p><img src="/2018/02/23/元素各种位置宽高/宽高3.png" alt=""></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/23/%E5%85%83%E7%B4%A0%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%AE%BD%E9%AB%98/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
