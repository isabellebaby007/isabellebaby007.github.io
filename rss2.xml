<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Isabelle的博客小站</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="%5Bobject%20Object%5D" rel="hub"/>
    <description>Isabelle的博客小站</description>
    <pubDate>Thu, 22 Feb 2018 19:34:35 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title></title>
      <link>http://yoursite.com/2018/02/22/%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%B0%BA%E5%AF%B8%E5%AE%BD%E9%AB%98/</link>
      <guid>http://yoursite.com/2018/02/22/%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%B0%BA%E5%AF%B8%E5%AE%BD%E9%AB%98/</guid>
      <pubDate>Thu, 22 Feb 2018 12:14:56 GMT</pubDate>
      <description>
      
        &lt;hr&gt;
&lt;p&gt;title: 元素的各种位置尺寸宽高&lt;br&gt;date: 2018-02-22 20:14:56&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端&lt;/li&gt;
&lt;li&gt;js&lt;/li&gt;
&lt;li&gt;DOM&lt;br&gt;categories:&lt;/li&gt;
&lt;li&gt;前端&lt;/li&gt;
&lt;li&gt;js&lt;/li&gt;
&lt;li&gt;DOM&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;offsetLeft&quot;&gt;&lt;a href=&quot;#offsetLeft&quot; class=&quot;headerlink&quot; title=&quot;offsetLeft&quot;&gt;&lt;/a&gt;offsetLeft&lt;/h3&gt;&lt;p&gt;offsetLeft[Top]:只读，属性，当前元素到定位父级的距离（偏移值），就是到当前元素的offsetParent的距离。  &lt;/p&gt;
&lt;h4 id=&quot;当前元素没有定位，但是有定位父级&quot;&gt;&lt;a href=&quot;#当前元素没有定位，但是有定位父级&quot; class=&quot;headerlink&quot; title=&quot;当前元素没有定位，但是有定位父级&quot;&gt;&lt;/a&gt;当前元素没有定位，但是有定位父级&lt;/h4&gt;&lt;p&gt;css部分：&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>title: 元素的各种位置尺寸宽高<br>date: 2018-02-22 20:14:56<br>tags:</p><ul><li>前端</li><li>js</li><li>DOM<br>categories:</li><li>前端</li><li>js</li><li>DOM</li></ul><hr><h3 id="offsetLeft"><a href="#offsetLeft" class="headerlink" title="offsetLeft"></a>offsetLeft</h3><p>offsetLeft[Top]:只读，属性，当前元素到定位父级的距离（偏移值），就是到当前元素的offsetParent的距离。  </p><h4 id="当前元素没有定位，但是有定位父级"><a href="#当前元素没有定位，但是有定位父级" class="headerlink" title="当前元素没有定位，但是有定位父级"></a>当前元素没有定位，但是有定位父级</h4><p>css部分：  <a id="more"></a></p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;position: relative;}#div3 {background: orange; }&lt;/style&gt;  </code></pre><p>js部分：  </p><pre><code>window.onload = function() {    var oDiv3 = document.getElementById(&apos;div3&apos;);  alert( oDiv3.offsetLeft );    }  </code></pre><p>html部分:  </p><pre><code>&lt;body id=&quot;body1&quot;&gt;    &lt;div id=&quot;div1&quot;&gt;        &lt;div id=&quot;div2&quot;&gt;            &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;  </code></pre><p>上述代码在ie11和Ie7的效果如下两图所示，可以得出结论： 在ie7下，如果自己没有定位，那么offsetLeft[Top]是到body的距离。 所以会显示100px</p><p><img src="/2018/02/22/元素的各种位置尺寸宽高/ie11标准.png" alt="">  </p><p><img src="/2018/02/22/元素的各种位置尺寸宽高/ie7非标准.png" alt="">  </p><h4 id="当前元素有定位的情况，且定位父级"><a href="#当前元素有定位的情况，且定位父级" class="headerlink" title="当前元素有定位的情况，且定位父级"></a>当前元素有定位的情况，且定位父级</h4><p>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;position: relative;}#div3 {background: orange;position: relative; }&lt;/style&gt;  </code></pre><p>其余部分代码同上个例子。ie11的效果同上个例子，但是Ie7的效果发生了变化，当前元素有定位的情况下，是到定位父级的距离。</p><p><img src="/2018/02/22/元素的各种位置尺寸宽高/有定位.png" alt="">  </p><h4 id="当前元素有定位，但是没有定位父级"><a href="#当前元素有定位，但是没有定位父级" class="headerlink" title="当前元素有定位，但是没有定位父级"></a>当前元素有定位，但是没有定位父级</h4><p>当前元素如果没有定位父级，offsetLeft默认的情况下是到body的，但是在Ie7下是指向到html的(在ie7以下body的默认margin-left值是10px)。<br>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;}#div3 {background: orange;position: relative; }&lt;/style&gt;  </code></pre><p>其余部分代码同例子一。  </p><p><img src="/2018/02/22/元素的各种位置尺寸宽高/108.png" alt="">  </p><p><img src="/2018/02/22/元素的各种位置尺寸宽高/110.png" alt="">  </p><h3 id="offsetTop"><a href="#offsetTop" class="headerlink" title="offsetTop"></a>offsetTop</h3><p>css部分：  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;}#div3 {background: orange;position: relative; }&lt;/style&gt;  </code></pre><p>js部分:  </p><pre><code>window.onload = function() {    var oDiv3 = document.getElementById(&apos;div3&apos;);  alert( oDiv3.offsetLeft );    }  </code></pre><p>效果如下,得出结论：ie7下的html默认margin-top是15px</p><p><img src="/2018/02/22/元素的各种位置尺寸宽高/88.png" alt=""> </p><p><img src="/2018/02/22/元素的各种位置尺寸宽高/95.png" alt=""> </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果有定位父级：<br>ie7以下：如果自己没有定位，那么offsetLeft[Top]是到body的距离；<br>如果自己有定位，那么就是到定位父级的距离。<br>其他浏览器：到定位父级的距离。  </p><h3 id="元素宽高"><a href="#元素宽高" class="headerlink" title="元素宽高"></a>元素宽高</h3><p>html部分：  </p><pre><code>&lt;body&gt;    &lt;div id=&quot;div1&quot; style=&quot;width: 100px; height: 100px; border: 1px solid red; padding: 10px; margin: 10px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;  </code></pre><p>js部分:  </p><pre><code>&lt;script&gt;window.onload = function() {    var oDiv = document.getElementById(&apos;div1&apos;);alert( oDiv.style.width );    //100alert( oDiv.clientWidth );    //样式宽 + padding    120alert( oDiv.offsetWidth );    //样式宽 + padding + border  可视区宽 + 边框    122    }  &lt;script&gt;  </code></pre><p>得到三个宽度分别为:  </p><p><img src="/2018/02/22/元素的各种位置尺寸宽高/宽高1.png" alt="">  </p><p><img src="/2018/02/22/元素的各种位置尺寸宽高/宽高2.png" alt="">  </p><p><img src="/2018/02/22/元素的各种位置尺寸宽高/宽高3.png" alt=""></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/22/%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%B0%BA%E5%AF%B8%E5%AE%BD%E9%AB%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>父节点</title>
      <link>http://yoursite.com/2018/02/22/%E7%88%B6%E8%8A%82%E7%82%B9/</link>
      <guid>http://yoursite.com/2018/02/22/%E7%88%B6%E8%8A%82%E7%82%B9/</guid>
      <pubDate>Thu, 22 Feb 2018 04:25:04 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;元素-parentNode&quot;&gt;&lt;a href=&quot;#元素-parentNode&quot; class=&quot;headerlink&quot; title=&quot;元素.parentNode&quot;&gt;&lt;/a&gt;元素.parentNode&lt;/h3&gt;&lt;p&gt;元素.parentNode:只读，属性，当前节点的父级节点，一个元素的父节点只有一个。在标准下和非标准下都可以，没有什么兼容问题。&lt;br&gt;js部分： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.onload = function() {
var oDiv3 = document.getElementById(&amp;apos;div3&amp;apos;);
alert( oDiv3.parentNode.id );
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="元素-parentNode"><a href="#元素-parentNode" class="headerlink" title="元素.parentNode"></a>元素.parentNode</h3><p>元素.parentNode:只读，属性，当前节点的父级节点，一个元素的父节点只有一个。在标准下和非标准下都可以，没有什么兼容问题。<br>js部分： </p><pre><code>window.onload = function() {var oDiv3 = document.getElementById(&apos;div3&apos;);alert( oDiv3.parentNode.id );}  </code></pre><p><a id="more"></a>html部分：  </p><pre><code>body id=&quot;body1&quot;&gt;    &lt;div id=&quot;div1&quot;&gt;        &lt;div id=&quot;div2&quot;&gt;            &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><p>在标准ie和非标准ie下，div3的父级都是div2，没有什么兼容性问题。<br><img src="/2018/02/22/父节点/标准.jpg" alt=""><br><img src="/2018/02/22/父节点/非标准.jpg" alt=""></p><h3 id="元素-offsetParent"><a href="#元素-offsetParent" class="headerlink" title="元素.offsetParent"></a>元素.offsetParent</h3><p>元素.offsetParent:只读，属性，有定位的父节点。如果多个父节点有定位，就是离它最近的有定位的父节点。如果没有定位父级，默认是body。   </p><h4 id="没有定位父级的例子"><a href="#没有定位父级的例子" class="headerlink" title="没有定位父级的例子"></a>没有定位父级的例子</h4><p>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green; zoom: 1;}#div3 {background: orange;}&lt;/style&gt;  </code></pre><p>js部分：  </p><pre><code>&lt;script&gt;window.onload = function() {        var oDiv3 = document.getElementById(&apos;div3&apos;);    alert( oDiv3.offsetParent );    }  </code></pre><p>html部分：  </p><pre><code>&lt;body id=&quot;body1&quot;&gt;    &lt;div id=&quot;div1&quot;&gt;        &lt;div id=&quot;div2&quot;&gt;            &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><p><img src="/2018/02/22/父节点/offset.jpg" alt=""></p><h4 id="加了定位属性的例子"><a href="#加了定位属性的例子" class="headerlink" title="加了定位属性的例子"></a>加了定位属性的例子</h4><p>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green; zoom: 1;position: relative;}#div3 {background: orange;}&lt;/style&gt;  </code></pre><p>js部分： </p><pre><code>window.onload = function() {        var oDiv3 = document.getElementById(&apos;div3&apos;);    alert( oDiv3.offsetParent.id );    }  </code></pre><p>展示效果如下，可以看出，div2加了定位属性之后，div3的offsetParent就变成了div2,而不是body了。  </p><p><img src="/2018/02/22/父节点/定位.jpg" alt="">  </p><h4 id="ie7以下，当前元素有定位例子"><a href="#ie7以下，当前元素有定位例子" class="headerlink" title="ie7以下，当前元素有定位例子"></a>ie7以下，当前元素有定位例子</h4><p>ie7以下，如果当前元素没有定位默认是body，如果有定位则是html.<br>css部分：</p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green; zoom: 1;}#div3 {background: orange;position: relative;}&lt;/style&gt;  </code></pre><p>js部分：  </p><pre><code>window.onload = function() {            var oDiv3 = document.getElementById(&apos;div3&apos;);        alert( oDiv3.offsetParent.tagName );        }    </code></pre><p>在ie11的效果如下图：  </p><p><img src="/2018/02/22/父节点/body.png" alt="">  </p><p>在ie7及以下的效果如下图:  </p><p><img src="/2018/02/22/父节点/html.png" alt="">  </p><h4 id="ie7以下，当前元素某个父级触发layout"><a href="#ie7以下，当前元素某个父级触发layout" class="headerlink" title="ie7以下，当前元素某个父级触发layout"></a>ie7以下，当前元素某个父级触发layout</h4><p>ie7以下，如果当前元素的某个父级触发了layout，那么offsetParent就会指向到触发了layout特性的父节点上。<br>css部分：  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green; zoom: 1;}#div3 {background: orange;}&lt;/style&gt;</code></pre><p>js部分：  </p><pre><code>window.onload = function() {                            alert( oDiv3.offsetParent.id);        }  </code></pre><p>效果如下所示，因为div2有zoom属性，zoom触发了layout,所以div3的offsetParent是触发了layout特性的父节点div2  </p><p><img src="/2018/02/22/父节点/layout.png" alt=""></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/22/%E7%88%B6%E8%8A%82%E7%82%B9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>子节点和兄弟节点的操作</title>
      <link>http://yoursite.com/2018/02/21/%E5%AD%90%E8%8A%82%E7%82%B9%E5%92%8C%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C/</link>
      <guid>http://yoursite.com/2018/02/21/%E5%AD%90%E8%8A%82%E7%82%B9%E5%92%8C%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C/</guid>
      <pubDate>Wed, 21 Feb 2018 14:51:44 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;元素-firstChild&quot;&gt;&lt;a href=&quot;#元素-firstChild&quot; class=&quot;headerlink&quot; title=&quot;元素.firstChild&quot;&gt;&lt;/a&gt;元素.firstChild&lt;/h3&gt;&lt;p&gt;元素.firstChild:只读，属性，第一个子节点  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;ul id=&amp;quot;ul1&amp;quot;&amp;gt;
        &amp;lt;li&amp;gt;11111&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;22222&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;33333&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;44444&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;添加下列代码来显示第一个子节点&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="元素-firstChild"><a href="#元素-firstChild" class="headerlink" title="元素.firstChild"></a>元素.firstChild</h3><p>元素.firstChild:只读，属性，第一个子节点  </p><pre><code>&lt;body&gt;    &lt;ul id=&quot;ul1&quot;&gt;        &lt;li&gt;11111&lt;/li&gt;        &lt;li&gt;22222&lt;/li&gt;        &lt;li&gt;33333&lt;/li&gt;        &lt;li&gt;44444&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;  </code></pre><p>添加下列代码来显示第一个子节点  <a id="more"></a> 下图说明在标准ie浏览器下:firstChild会包含文本类型的节点；在非标准的ie下：只包含元素节点</p><pre><code>alert( oUl.firstChild );  </code></pre><p><img src="/2018/02/21/子节点和兄弟节点的操作/firstChild.png" alt="">  </p><p><img src="/2018/02/21/子节点和兄弟节点的操作/firstChild非标准.png" alt="">  </p><h3 id="元素-firstElementChild"><a href="#元素-firstElementChild" class="headerlink" title="元素.firstElementChild"></a>元素.firstElementChild</h3><p>元素.firstElementChild:只读，属性，标准下获取第一个元素类型的子节点（所以在非标准的ie下是不支持这个属性的),所以非标准下会输出下图所示undefined </p><p><img src="/2018/02/21/子节点和兄弟节点的操作/非标准firstele.png" alt=""><br>可以用以下代码，这样的话在标准下和非标准下都可以正常。</p><pre><code>if ( oUl.firstElementChild ) {     oUl.firstElementChild.style.background = &apos;red&apos;; //在标准浏览器下 } else {     oUl.firstChild.style.background = &apos;red&apos;;   //在非标准ie下 }  </code></pre><p>简化这段代码：  </p><pre><code>var oFirst=oUl.firstElementChild || oUl.firstChild;if(oFirst){    oFirst.style.background=&apos;red&apos;;}else{    alert(&apos;没有子节点可以设置&apos;);    }  </code></pre><h3 id="元素-lastChild-元素-lastElementChild"><a href="#元素-lastChild-元素-lastElementChild" class="headerlink" title="元素.lastChild || 元素.lastElementChild"></a>元素.lastChild || 元素.lastElementChild</h3><p>元素.lastChild || 元素.lastElementChild:最后一个子节点  </p><pre><code>var oLast=oUl.lastElementChild || oUl.lastChild;if(oLast){    oLast.style.background=&apos;yellow&apos;;}else{    alert(&apos;没有子节点可以设置&apos;);    }  </code></pre><h3 id="元素-nextSibling-元素-nextElementSibling"><a href="#元素-nextSibling-元素-nextElementSibling" class="headerlink" title="元素.nextSibling || 元素.nextElementSibling"></a>元素.nextSibling || 元素.nextElementSibling</h3><p>元素.nextSibling || 元素.nextElementSibling:下一个兄弟节点  </p><pre><code>var oNext=oFirst.nextElementSibling || oFirst.nextSibling;  oNext.style.background=&apos;blue&apos;;  </code></pre><h3 id="元素-previousSibling-元素-previousElementSibling"><a href="#元素-previousSibling-元素-previousElementSibling" class="headerlink" title="元素.previousSibling || 元素.previousElementSibling"></a>元素.previousSibling || 元素.previousElementSibling</h3><p>元素.previousSibling || 元素.previousElementSibling：上一个兄弟节点  </p><pre><code>var oPrev=oLast.previousElementSibling || oLast.previousSibling;  oPrev.style.background=&apos;orange&apos;;</code></pre>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/21/%E5%AD%90%E8%8A%82%E7%82%B9%E5%92%8C%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>DOM之childNodes</title>
      <link>http://yoursite.com/2018/02/21/DOM%E4%B9%8BchildNodes/</link>
      <guid>http://yoursite.com/2018/02/21/DOM%E4%B9%8BchildNodes/</guid>
      <pubDate>Wed, 21 Feb 2018 06:25:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;写在前面的话：工作当中不太推荐使用childNodes，兼容性问题比较多。推荐使用children&lt;br&gt;DOM是javascript操作网页的接口，全称为文档对象模型（Document Object Model）。它的作用是将网页转为一个JavaScript对象，从而可以使用JavaScript对网页进行各种操作（比如增删内容）。浏览器会根据DOM模型，将HTML文档解析成一系列的节点，再由这些节点组成一个树状结构。DOM的最小组成单位叫做节点（node），文档的树形结构由12种类型的节点组成。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>写在前面的话：工作当中不太推荐使用childNodes，兼容性问题比较多。推荐使用children<br>DOM是javascript操作网页的接口，全称为文档对象模型（Document Object Model）。它的作用是将网页转为一个JavaScript对象，从而可以使用JavaScript对网页进行各种操作（比如增删内容）。浏览器会根据DOM模型，将HTML文档解析成一系列的节点，再由这些节点组成一个树状结构。DOM的最小组成单位叫做节点（node），文档的树形结构由12种类型的节点组成。 <a id="more"></a><br>小结：一般地，节点至少拥有nodeType、nodeName和nodeValue这三个基本属性。节点类型不同，三个属性的值也不相同。  </p><h3 id="childNodes-子节点"><a href="#childNodes-子节点" class="headerlink" title="childNodes 子节点"></a>childNodes 子节点</h3><p>元素.childNodes为子节点列表集合（只读），注意childNodes只包含一级子节点，不包含后辈孙级以下的节点。</p><h3 id="nodeType-节点类型"><a href="#nodeType-节点类型" class="headerlink" title="nodeType 节点类型"></a>nodeType 节点类型</h3><p>nodeType属性返回节点类型的常数值(无符号短整型)。不同的类型对应不同的常数值，12种类型分别对应12种不同的常数值  </p><table><thead><tr><th style="text-align:left">节点类型</th><th>名称</th><th style="text-align:center">对应的常数值</th></tr></thead><tbody><tr><td style="text-align:left">元素节点</td><td>Node.ELEMENT_NODE</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">属性节点</td><td>Node.ATTRIBUTE_NODE</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">文本节点</td><td>Node.TEXT_NODE</td><td style="text-align:center">3</td></tr><tr><td style="text-align:left">CDATA节点</td><td>Node.CDATA_SECTION_NODE</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">实体引用名称节点</td><td>Node.ENTRY_REFERENCE_NODE</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">实体名称节点</td><td>Node.ENTITY_NODE</td><td style="text-align:center">6</td></tr><tr><td style="text-align:left">处理指令节点</td><td>Node.PROCESSING_INSTRUCTION_NODE</td><td style="text-align:center">7</td></tr><tr><td style="text-align:left">注释节点</td><td>Node.COMMENT_NODE</td><td style="text-align:center">8</td></tr><tr><td style="text-align:left">文档节点</td><td>Node.DOCUMENT_NODE</td><td style="text-align:center">9</td></tr><tr><td style="text-align:left">文档类型节点</td><td>Node.DOCUMENT_TYPE_NODE</td><td style="text-align:center">10</td></tr><tr><td style="text-align:left">文档片段节点</td><td>Node.DOCUMENT_FRAGMENT_NODE</td><td style="text-align:center">11</td></tr><tr><td style="text-align:left">DTD声明节点</td><td>Node.NOTATION_NODE</td><td style="text-align:center">12  </td></tr></tbody></table><h3 id="元素节点和文本节点"><a href="#元素节点和文本节点" class="headerlink" title="元素节点和文本节点"></a>元素节点和文本节点</h3><p>下面这段代码在标准的ie下面显示是9个节点，在非标准的ie下显示4个节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.onload = function() &#123;</span><br><span class="line"></span><br><span class="line">var oUl = document.getElementById(&apos;ul1&apos;);</span><br><span class="line">alert( oUl.childNodes.length );</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul id=&quot;ul1&quot;&gt;</span><br><span class="line">        &lt;li&gt;11111&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;22222&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;33333&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;44444&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>这是因为在标准ie下包含了文本和元素类型的节点，也会包含非法嵌套的节点。而在非标准的浏览器下，只包含元素类型的节点，ie7以下不会包含非法嵌套的节点。所以在这个例子中，在标准浏览器下，会把标签元素之间的回车换行符当作文本类型的节点（有5个）+4个元素节点，合起来就是9个；在非标准下只有4个元素节点。如果删掉其中的一个回车换行符，则会在标准浏览器下减少一个节点。<br>区分了这一点，再看下面这个例子：  </p><pre><code>for (var i=0; i&lt;oUl.childNodes.length; i++) {            oUl.childNodes[i].style.background = &apos;red&apos;;        }</code></pre><p>如果要循环当前oUl下的所有的子节点列表，给所有子节点加上一个背景色。则在非标准的ie下可以很正常地显示：<br><img src="/2018/02/21/DOM之childNodes/非标准浏览器.jpg" alt="正常显示"><br>而在标准ie下，会显示出错。这是因为回车换行符被当作文本节点，所以第0个子节点其实是一个文本，文本是没有style也没有background的属性的。<br><img src="/2018/02/21/DOM之childNodes/标准ie.jpg" alt="正常显示"><br><img src="/2018/02/21/DOM之childNodes/出错.jpg" alt="正常显示"><br> 这里我们可以添加以下代码来验证第0个元素的节点类型: </p><pre><code>alert(oUl.childNodes[0].nodeType);</code></pre><p>在标准ie下，显示3，说明第0个元素是文本节点。而在非标准ie下显示1，说明第0个节点是元素节点：  </p><p><img src="/2018/02/21/DOM之childNodes/文本类型.jpg" alt=""></p><p><img src="/2018/02/21/DOM之childNodes/元素节点.jpg" alt="">  </p><h3 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h3><p>元素.attributes用来获取当前的属性（只读，属性列表集合)    </p><pre><code>alert( oUl.attributes.length );获取并显示元素属性个数alert(oUl.attributes[1].value);显示属性值</code></pre><h3 id="children"><a href="#children" class="headerlink" title="children"></a>children</h3><p>工作中推荐使用children，只读属性，子节点列表集合。和child差不多，有一点区别就是：  </p><pre><code>&lt;body&gt;    &lt;ul id=&quot;ul1&quot; &gt;        &lt;li&gt;11111 &lt;span&gt;span&lt;/span&gt;&lt;/li&gt;        &lt;li&gt;22222&lt;/li&gt;        &lt;li&gt;33333&lt;/li&gt;        &lt;li&gt;44444&lt;/li&gt;        &lt;p&gt;pppppppp&lt;/p&gt;    &lt;/ul&gt;&lt;/body&gt;</code></pre><p>上述这段代码，在标准ie下，显示的children.length为5，可以看出使用children的时候不会再把文本节点算进去了，但是把非法嵌套的P也包括进去了  </p><p><img src="/2018/02/21/DOM之childNodes/children.png" alt="">  </p><p><img src="/2018/02/21/DOM之childNodes/children标准结构.png" alt=""><br>而在非标准ie下，显示的children.length为4，这是因为p没有算进去，不认这种非法嵌套。<br><img src="/2018/02/21/DOM之childNodes/children1.png" alt="">  </p><p><img src="/2018/02/21/DOM之childNodes/children非标准结构.png" alt=""> </p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/21/DOM%E4%B9%8BchildNodes/#disqus_thread</comments>
    </item>
    
    <item>
      <title>XHTML+CSS2笔记1</title>
      <link>http://yoursite.com/2018/02/20/XHTML-CSS2%E7%AC%94%E8%AE%B01/</link>
      <guid>http://yoursite.com/2018/02/20/XHTML-CSS2%E7%AC%94%E8%AE%B01/</guid>
      <pubDate>Tue, 20 Feb 2018 05:09:20 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://yoursite.com/2018/02/20/XHTML-CSS2%E7%AC%94%E8%AE%B01/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
