<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Isabelle的博客小站</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="%5Bobject%20Object%5D" rel="hub"/>
    <description>Isabelle的博客小站</description>
    <pubDate>Fri, 23 Feb 2018 13:46:36 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>给博客添加feed</title>
      <link>http://yoursite.com/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed/</link>
      <guid>http://yoursite.com/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed/</guid>
      <pubDate>Fri, 23 Feb 2018 13:36:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;安装hexo-generator-feed  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install hexo-generator-feed --save  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置到站点配置文件_config.yml&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>安装hexo-generator-feed  </p><pre><code>$ npm install hexo-generator-feed --save  </code></pre><p>配置到站点配置文件_config.yml  <a id="more"></a></p><pre><code># Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20  </code></pre><p>最后，在你next主题下的_config.yml下，添加RSS订阅链接即可：  </p><pre><code>rss: /atom.xml</code></pre>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed/#disqus_thread</comments>
    </item>
    
    <item>
      <title>给博客添加站点地图</title>
      <link>http://yoursite.com/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/</link>
      <guid>http://yoursite.com/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/</guid>
      <pubDate>Fri, 23 Feb 2018 13:29:12 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;安装hexo-generator-seo-friendly-sitemap  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install hexo-generator-seo-friendly-sitemap --save  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在站点配置文件
        
      
      </description>
      
      <content:encoded><![CDATA[<p>安装hexo-generator-seo-friendly-sitemap  </p><pre><code>$ npm install hexo-generator-seo-friendly-sitemap --save  </code></pre><p>在站点配置文件_config.yml中添加  </p><pre><code>sitemap:    path: sitemap.xml</code></pre>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo添加站内搜索</title>
      <link>http://yoursite.com/2018/02/23/hexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/</link>
      <guid>http://yoursite.com/2018/02/23/hexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/</guid>
      <pubDate>Fri, 23 Feb 2018 12:49:43 GMT</pubDate>
      <description>
      
        &lt;p&gt;NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。<a id="more"></a> </p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="安装hexo-generator-search"><a href="#安装hexo-generator-search" class="headerlink" title="安装hexo-generator-search"></a>安装hexo-generator-search</h4><p>在站点的根目录下执行：  </p><pre><code>$ npm install hexo-generator-search --save  </code></pre><h4 id="安装hexo-generator-searchdb"><a href="#安装hexo-generator-searchdb" class="headerlink" title="安装hexo-generator-searchdb"></a>安装hexo-generator-searchdb</h4><p>在站点的根目录下执行：  </p><pre><code>$ npm install hexo-generator-searchdb --save  </code></pre><h4 id="启用搜索"><a href="#启用搜索" class="headerlink" title="启用搜索"></a>启用搜索</h4><p>编辑站点配置文件，加入以下代码： </p><pre><code>search:  path: search.xml  field: post  format: html  limit: 10000</code></pre>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/23/hexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>元素各种位置宽高</title>
      <link>http://yoursite.com/2018/02/23/%E5%85%83%E7%B4%A0%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%AE%BD%E9%AB%98/</link>
      <guid>http://yoursite.com/2018/02/23/%E5%85%83%E7%B4%A0%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%AE%BD%E9%AB%98/</guid>
      <pubDate>Thu, 22 Feb 2018 19:40:33 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;offsetLeft&quot;&gt;&lt;a href=&quot;#offsetLeft&quot; class=&quot;headerlink&quot; title=&quot;offsetLeft&quot;&gt;&lt;/a&gt;offsetLeft&lt;/h3&gt;&lt;p&gt;offsetLeft[Top]:只读，属性，当前元素到定位父级的距离（偏移值），就是到当前元素的offsetParent的距离。  &lt;/p&gt;
&lt;h4 id=&quot;当前元素没有定位，但是有定位父级&quot;&gt;&lt;a href=&quot;#当前元素没有定位，但是有定位父级&quot; class=&quot;headerlink&quot; title=&quot;当前元素没有定位，但是有定位父级&quot;&gt;&lt;/a&gt;当前元素没有定位，但是有定位父级&lt;/h4&gt;&lt;p&gt;css部分：&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="offsetLeft"><a href="#offsetLeft" class="headerlink" title="offsetLeft"></a>offsetLeft</h3><p>offsetLeft[Top]:只读，属性，当前元素到定位父级的距离（偏移值），就是到当前元素的offsetParent的距离。  </p><h4 id="当前元素没有定位，但是有定位父级"><a href="#当前元素没有定位，但是有定位父级" class="headerlink" title="当前元素没有定位，但是有定位父级"></a>当前元素没有定位，但是有定位父级</h4><p>css部分：  <a id="more"></a></p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;position: relative;}#div3 {background: orange; }&lt;/style&gt;  </code></pre><p>js部分：  </p><pre><code>window.onload = function() {    var oDiv3 = document.getElementById(&apos;div3&apos;);  alert( oDiv3.offsetLeft );    }  </code></pre><p>html部分:  </p><pre><code>&lt;body id=&quot;body1&quot;&gt;    &lt;div id=&quot;div1&quot;&gt;        &lt;div id=&quot;div2&quot;&gt;            &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;  </code></pre><p>上述代码在ie11和Ie7的效果如下两图所示，可以得出结论： 在ie7下，如果自己没有定位，那么offsetLeft[Top]是到body的距离。 所以会显示100px</p><p><img src="/2018/02/23/元素各种位置宽高/ie11标准.png" alt="">  </p><p><img src="/2018/02/23/元素各种位置宽高/ie7非标准.png" alt="">  </p><h4 id="当前元素有定位的情况，且定位父级"><a href="#当前元素有定位的情况，且定位父级" class="headerlink" title="当前元素有定位的情况，且定位父级"></a>当前元素有定位的情况，且定位父级</h4><p>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;position: relative;}#div3 {background: orange;position: relative; }&lt;/style&gt;  </code></pre><p>其余部分代码同上个例子。ie11的效果同上个例子，但是Ie7的效果发生了变化，当前元素有定位的情况下，是到定位父级的距离。</p><p><img src="/2018/02/23/元素各种位置宽高/有定位.png" alt="">  </p><h4 id="当前元素有定位，但是没有定位父级"><a href="#当前元素有定位，但是没有定位父级" class="headerlink" title="当前元素有定位，但是没有定位父级"></a>当前元素有定位，但是没有定位父级</h4><p>当前元素如果没有定位父级，offsetLeft默认的情况下是到body的，但是在Ie7下是指向到html的(在ie7以下body的默认margin-left值是10px)。<br>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;}#div3 {background: orange;position: relative; }&lt;/style&gt;  </code></pre><p>其余部分代码同例子一。  </p><p><img src="/2018/02/23/元素各种位置宽高/108.png" alt="">  </p><p><img src="/2018/02/23/元素各种位置宽高/110.png" alt="">  </p><h3 id="offsetTop"><a href="#offsetTop" class="headerlink" title="offsetTop"></a>offsetTop</h3><p>css部分：  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;}#div3 {background: orange;position: relative; }&lt;/style&gt;  </code></pre><p>js部分:  </p><pre><code>window.onload = function() {    var oDiv3 = document.getElementById(&apos;div3&apos;);  alert( oDiv3.offsetLeft );    }  </code></pre><p>效果如下,得出结论：ie7下的html默认margin-top是15px</p><p><img src="/2018/02/23/元素各种位置宽高/88.png" alt=""> </p><p><img src="/2018/02/23/元素各种位置宽高/95.png" alt=""> </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果有定位父级：<br>ie7以下：如果自己没有定位，那么offsetLeft[Top]是到body的距离；<br>如果自己有定位，那么就是到定位父级的距离。<br>其他浏览器：到定位父级的距离。  </p><h3 id="元素宽高"><a href="#元素宽高" class="headerlink" title="元素宽高"></a>元素宽高</h3><p>html部分：  </p><pre><code>&lt;body&gt;    &lt;div id=&quot;div1&quot; style=&quot;width: 100px; height: 100px; border: 1px solid red; padding: 10px; margin: 10px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;  </code></pre><p>js部分:  </p><pre><code>&lt;script&gt;window.onload = function() {    var oDiv = document.getElementById(&apos;div1&apos;);alert( oDiv.style.width );    //样式宽100alert( oDiv.clientWidth );    //样式宽 + padding=可视区宽    120alert( oDiv.offsetWidth );    //样式宽 + padding + border  可视区宽 + 边框    122    }  &lt;script&gt;  </code></pre><p>得到三个宽度分别为:  </p><p><img src="/2018/02/23/元素各种位置宽高/宽高1.png" alt="">  </p><p><img src="/2018/02/23/元素各种位置宽高/宽高2.png" alt="">  </p><p><img src="/2018/02/23/元素各种位置宽高/宽高3.png" alt=""></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/23/%E5%85%83%E7%B4%A0%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%AE%BD%E9%AB%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>父节点</title>
      <link>http://yoursite.com/2018/02/22/%E7%88%B6%E8%8A%82%E7%82%B9/</link>
      <guid>http://yoursite.com/2018/02/22/%E7%88%B6%E8%8A%82%E7%82%B9/</guid>
      <pubDate>Thu, 22 Feb 2018 04:25:04 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;元素-parentNode&quot;&gt;&lt;a href=&quot;#元素-parentNode&quot; class=&quot;headerlink&quot; title=&quot;元素.parentNode&quot;&gt;&lt;/a&gt;元素.parentNode&lt;/h3&gt;&lt;p&gt;元素.parentNode:只读，属性，当前节点的父级节点，一个元素的父节点只有一个。在标准下和非标准下都可以，没有什么兼容问题。&lt;br&gt;js部分： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.onload = function() {
var oDiv3 = document.getElementById(&amp;apos;div3&amp;apos;);
alert( oDiv3.parentNode.id );
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="元素-parentNode"><a href="#元素-parentNode" class="headerlink" title="元素.parentNode"></a>元素.parentNode</h3><p>元素.parentNode:只读，属性，当前节点的父级节点，一个元素的父节点只有一个。在标准下和非标准下都可以，没有什么兼容问题。<br>js部分： </p><pre><code>window.onload = function() {var oDiv3 = document.getElementById(&apos;div3&apos;);alert( oDiv3.parentNode.id );}  </code></pre><p><a id="more"></a>html部分：  </p><pre><code>body id=&quot;body1&quot;&gt;    &lt;div id=&quot;div1&quot;&gt;        &lt;div id=&quot;div2&quot;&gt;            &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><p>在标准ie和非标准ie下，div3的父级都是div2，没有什么兼容性问题。<br><img src="/2018/02/22/父节点/标准.jpg" alt=""><br><img src="/2018/02/22/父节点/非标准.jpg" alt=""></p><h3 id="元素-offsetParent"><a href="#元素-offsetParent" class="headerlink" title="元素.offsetParent"></a>元素.offsetParent</h3><p>元素.offsetParent:只读，属性，有定位的父节点。如果多个父节点有定位，就是离它最近的有定位的父节点。如果没有定位父级，默认是body。   </p><h4 id="没有定位父级的例子"><a href="#没有定位父级的例子" class="headerlink" title="没有定位父级的例子"></a>没有定位父级的例子</h4><p>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green; zoom: 1;}#div3 {background: orange;}&lt;/style&gt;  </code></pre><p>js部分：  </p><pre><code>&lt;script&gt;window.onload = function() {        var oDiv3 = document.getElementById(&apos;div3&apos;);    alert( oDiv3.offsetParent );    }  </code></pre><p>html部分：  </p><pre><code>&lt;body id=&quot;body1&quot;&gt;    &lt;div id=&quot;div1&quot;&gt;        &lt;div id=&quot;div2&quot;&gt;            &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><p><img src="/2018/02/22/父节点/offset.jpg" alt=""></p><h4 id="加了定位属性的例子"><a href="#加了定位属性的例子" class="headerlink" title="加了定位属性的例子"></a>加了定位属性的例子</h4><p>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green; zoom: 1;position: relative;}#div3 {background: orange;}&lt;/style&gt;  </code></pre><p>js部分： </p><pre><code>window.onload = function() {        var oDiv3 = document.getElementById(&apos;div3&apos;);    alert( oDiv3.offsetParent.id );    }  </code></pre><p>展示效果如下，可以看出，div2加了定位属性之后，div3的offsetParent就变成了div2,而不是body了。  </p><p><img src="/2018/02/22/父节点/定位.jpg" alt="">  </p><h4 id="ie7以下，当前元素有定位例子"><a href="#ie7以下，当前元素有定位例子" class="headerlink" title="ie7以下，当前元素有定位例子"></a>ie7以下，当前元素有定位例子</h4><p>ie7以下，如果当前元素没有定位默认是body，如果有定位则是html.<br>css部分：</p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green; zoom: 1;}#div3 {background: orange;position: relative;}&lt;/style&gt;  </code></pre><p>js部分：  </p><pre><code>window.onload = function() {            var oDiv3 = document.getElementById(&apos;div3&apos;);        alert( oDiv3.offsetParent.tagName );        }    </code></pre><p>在ie11的效果如下图：  </p><p><img src="/2018/02/22/父节点/body.png" alt="">  </p><p>在ie7及以下的效果如下图:  </p><p><img src="/2018/02/22/父节点/html.png" alt="">  </p><h4 id="ie7以下，当前元素某个父级触发layout"><a href="#ie7以下，当前元素某个父级触发layout" class="headerlink" title="ie7以下，当前元素某个父级触发layout"></a>ie7以下，当前元素某个父级触发layout</h4><p>ie7以下，如果当前元素的某个父级触发了layout，那么offsetParent就会指向到触发了layout特性的父节点上。<br>css部分：  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green; zoom: 1;}#div3 {background: orange;}&lt;/style&gt;</code></pre><p>js部分：  </p><pre><code>window.onload = function() {                            alert( oDiv3.offsetParent.id);        }  </code></pre><p>效果如下所示，因为div2有zoom属性，zoom触发了layout,所以div3的offsetParent是触发了layout特性的父节点div2  </p><p><img src="/2018/02/22/父节点/layout.png" alt=""></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/22/%E7%88%B6%E8%8A%82%E7%82%B9/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
