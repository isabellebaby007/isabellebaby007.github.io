<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Isabelle的博客小站</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="%5Bobject%20Object%5D" rel="hub"/>
    <description>Isabelle的博客小站</description>
    <pubDate>Mon, 05 Mar 2018 04:53:19 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>运算符与流程控制</title>
      <link>http://yoursite.com/2018/03/05/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <guid>http://yoursite.com/2018/03/05/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <pubDate>Mon, 05 Mar 2018 04:51:36 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://yoursite.com/2018/03/05/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js作用域</title>
      <link>http://yoursite.com/2018/03/04/js%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <guid>http://yoursite.com/2018/03/04/js%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <pubDate>Sun, 04 Mar 2018 14:51:22 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;预解析机制&quot;&gt;&lt;a href=&quot;#预解析机制&quot; class=&quot;headerlink&quot; title=&quot;预解析机制&quot;&gt;&lt;/a&gt;预解析机制&lt;/h3&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="预解析机制"><a href="#预解析机制" class="headerlink" title="预解析机制"></a>预解析机制</h3><a id="more"></a>  <h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>域：空间、范围、区域……<br>作用：读、写<br>script        全局变量、全局函数,自上而下<br>函数  由里到外<br>浏览器：“JS解析器”<br>1）“找一些东西”    ：var  function 参数<br>a = …<br>所有的变量，在正式运行代码之前，都提前赋了一个值：未定义<br>fn1 = function fn1(){ alert(2); }<br>所有的函数，在正式运行代码之前，都是整个函数块<br>JS 的预解析<br>遇到重名的：只留一个<br>变量和函数重名了，就只留下函数</p><p>2）逐行解读代码：<br>表达式：= + - * / % ++ – ! 参数……<br>表达式可以修改预解析的值！  </p><h4 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h4><pre><code>    alert(a);                    // 输出   function a (){ alert(4); }//因为预解析之后，变量和函数重名了就只留下函数，所以a是整个函数块   function a(){alert(4)};    var a = 1;     alert(a);                    // 输出  1//表达式var a=1;修改了预解析的值    function a (){ alert(2); }    alert(a);                    // 输出  1//    函数不修改值    var a = 3;            alert(a);                    // 输出  3//表达式var a=3;修改了预解析的值    function a (){ alert(4); }    alert(a);                    // 输出  3//函数不修改值    alert( typeof a );          //number    // a();                                    // 报错  </code></pre><h3 id="js单线程运行"><a href="#js单线程运行" class="headerlink" title="js单线程运行"></a>js单线程运行</h3><pre><code>&lt;script&gt;alert(a);   //报错&lt;/script&gt;&lt;script&gt;var a=1;   //1alert(a);&lt;/script&gt;</code></pre><p>前一个script区域运行完之后，值会保存。</p><pre><code>&lt;script&gt;var a=1;   //1alert(a);&lt;/script&gt;  &lt;script&gt;alert(a);   //1&lt;/script&gt;</code></pre><h3 id="函数也是一个局部的域"><a href="#函数也是一个局部的域" class="headerlink" title="函数也是一个局部的域"></a>函数也是一个局部的域</h3><p>函数调用：预解析+逐行解读代码<br>1)预解析： var function 参数….<br>a=…<br>fn1=function(){<br>  alert(a);<br>  var a=2；<br>}<br>2）逐行解读代码：<br>表达式<br>函数调用<br>2.1）预解析：<br>  a=…  这里的a是局部变量<br>2.2)逐行解读代码：<br>  a=2;</p><pre><code>var a = 1;function fn1(){    alert(a);                        // undefined    var a = 2;                      //a=2}fn1();alert(a);                            // 1</code></pre><p>下面看看  不加var的影响<br>1)预解析： var function 参数….<br>a=…<br>fn1=function(){<br>  alert(a);<br>  a=2；<br>}<br>2）逐行解读代码：<br>表达式<br>函数调用<br>2.1）局部预解析：<br>因为函数里面没有var 所有没有找到，<br>2.2)局部逐行解读代码：<br>  a=2;</p><pre><code>var a = 1;function fn1(){    alert(a);                        // 1  所以返回父级去找。由里到外（作用域链）找到外面那个a    a = 2;                          //这里修改的是外面的那个a}fn1();alert(a);                            // 2  </code></pre><p>小结：先找东西，后执行。执行过程中遇到表达式就会去修改原来库里面的东西，如果遇到函数调用就开了一个新的作用域，一旦新的作用域开始了，又会重复以上步骤，新的作用域中如果没找到里面有东西，又会返回父级里面去找。  </p><h3 id="带参数的函数"><a href="#带参数的函数" class="headerlink" title="带参数的函数"></a>带参数的函数</h3><p>1)预解析： var function 参数….<br>a=…<br>fn1=function(a){<br>  alert(a);<br>  a=2；<br>}<br>2）逐行解读代码：<br>表达式<br>函数调用<br>2.1）局部预解析：<br>因为函数里面没有var ,也没有找到函数，所有没有找到。参数本质上就是一个局部变量。找到了参数，但是这个例子里函数调用并没有传进来。<br>参数 a=…未定义<br>2.2)局部逐行解读代码：<br>  局部变量a就是undefined  </p><pre><code>var a = 1;                           //全局变量a=1function fn1(a){    alert(a);                        // undefined    a = 2;                          //这句把a改成2}fn1();alert(a);                            // 这里读取父级的a=1  </code></pre><h3 id="函数调用带参数"><a href="#函数调用带参数" class="headerlink" title="函数调用带参数"></a>函数调用带参数</h3><p>1)预解析： var function 参数….<br>a=…<br>fn1=function(a){<br>  alert(a);<br>  a=2；<br>}<br>2）逐行解读代码：<br>表达式<br>函数调用fn1(a)<br>2.1）局部预解析：<br>参数本质上就是一个局部变量，因为这个例子里面传递了参数进来，所以a=undefined。<br>参数 a=…未定义<br>2.2)局部逐行解读代码：<br>因为传递进来的a=1,所以局部变量a=1,再下一步就是局部变量a=2。  全局变量a仍然是1</p><pre><code> var a = 1;function fn1(a){    alert(a);                        // 1    a = 2;}fn1(a);alert(a);                            // 1</code></pre><h3 id="任何函数都可以改全局变量"><a href="#任何函数都可以改全局变量" class="headerlink" title="任何函数都可以改全局变量"></a>任何函数都可以改全局变量</h3><p>因为函数内部没有这个变量的话，会从里往外找。</p><pre><code>var num = 0;function fn1(){    num++;}function fn2(){    num--;}fn2();fn1();fn2();alert(num);  </code></pre><h3 id="获取函数内的值"><a href="#获取函数内的值" class="headerlink" title="获取函数内的值"></a>获取函数内的值</h3><p>巧妙利用全局变量来去获取函数内的内容</p><pre><code>var str = &apos;&apos;;function fn1(){    var a = &apos;大鸡腿~&apos;;    str = a;}fn1();alert( str );   //大鸡腿</code></pre><p>另一种方法：</p><pre><code>function fn2(){    var a = &apos;9999999克拉钻石23456789&apos;;    fn3(a);}fn2();function fn3(a){    alert(a);}  </code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>if(){}和for(){}、do{}while不是作用域，函数是作用域。<br>firefox不能对下面的函数进行预解析,除了火狐以外，其他的浏览器都可以。   </p><pre><code>alert( fn1 );        // FF 不能对下面的函数进行预解析if( true ){    var a = 1;    function fn1(){    alert(123);}}  </code></pre><p>解决这个兼容性问题的方法是：以后尽量不要在if语句里面定义函数，全局变量。改成下面这种写法：  </p><h3 id="for里面包了一个函数，在函数里面不要直接使用i"><a href="#for里面包了一个函数，在函数里面不要直接使用i" class="headerlink" title="for里面包了一个函数，在函数里面不要直接使用i"></a>for里面包了一个函数，在函数里面不要直接使用i</h3><p>下例会出现undefined的原因是：点击事件函数是一个作用域，只要有作用域，就会有域解析，点击事件函数里面域解析的时候会找到var i=undefined,所以这里alert(i)是undefined。但是如果把for循环里面的var去掉的话，那么点击事件函数里面就没有变量，所以i就会到父级里面去找，父级i是3,所以此时alert(i)会弹出3。</p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;    &lt;title&gt;无标题文档&lt;/title&gt;    &lt;script&gt;    window.onload = function() {        var aBtn = document.getElementsByTagName(&apos;input&apos;);        for (var i = 0; i &lt; aBtn.length; i++) {            aBtn[i].onclick = function() {                 alert( i );                                for (var i = 0; i &lt; aBtn.length; i++) {                    aBtn[i].style.background = &apos;yellow&apos;;                }            };        }    };    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type=&quot;button&quot; value=&quot;按钮1&quot; /&gt;    &lt;input type=&quot;button&quot; value=&quot;按钮2&quot; /&gt;    &lt;input type=&quot;button&quot; value=&quot;按钮3&quot; /&gt;&lt;/body&gt;&lt;/html&gt;  </code></pre><p><img src="/2018/03/04/js作用域/zuoyongyu.gif" alt=""><br>但是如果把js代码改成以下就会出错  </p><pre><code>&lt;script&gt;window.onload = function() {    var aBtn = document.getElementsByTagName(&apos;input&apos;);    for (var i = 0; i &lt; aBtn.length; i++) {        aBtn[i].onclick = function() {             alert( i );                // 3             aBtn[i].style.background = &apos;yellow&apos;;          };    }};&lt;/script&gt;  </code></pre><p><img src="/2018/03/04/js作用域/ccuowu.gif" alt=""> </p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/04/js%E4%BD%9C%E7%94%A8%E5%9F%9F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>函数传参项目</title>
      <link>http://yoursite.com/2018/03/04/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E9%A1%B9%E7%9B%AE/</link>
      <guid>http://yoursite.com/2018/03/04/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E9%A1%B9%E7%9B%AE/</guid>
      <pubDate>Sun, 04 Mar 2018 14:37:36 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;搜狐视频纪录片列表展示&quot;&gt;&lt;a href=&quot;#搜狐视频纪录片列表展示&quot; class=&quot;headerlink&quot; title=&quot;搜狐视频纪录片列表展示&quot;&gt;&lt;/a&gt;搜狐视频纪录片列表展示&lt;/h3&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="搜狐视频纪录片列表展示"><a href="#搜狐视频纪录片列表展示" class="headerlink" title="搜狐视频纪录片列表展示"></a>搜狐视频纪录片列表展示</h3><a id="more"></a> <p><img src="/2018/03/04/函数传参项目/souhu.gif" alt=""></p><h3 id="修改文本框的值"><a href="#修改文本框的值" class="headerlink" title="修改文本框的值"></a>修改文本框的值</h3><p><img src="/2018/03/04/函数传参项目/修改文本框的值.gif" alt=""></p><h3 id="选择卡里套选择卡"><a href="#选择卡里套选择卡" class="headerlink" title="选择卡里套选择卡"></a>选择卡里套选择卡</h3><p><img src="/2018/03/04/函数传参项目/选择卡里套选择卡.gif" alt=""></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/04/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E9%A1%B9%E7%9B%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>绝对定位与相对定位</title>
      <link>http://yoursite.com/2018/03/04/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E4%B8%8E%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D/</link>
      <guid>http://yoursite.com/2018/03/04/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E4%B8%8E%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D/</guid>
      <pubDate>Sun, 04 Mar 2018 07:56:39 GMT</pubDate>
      <description>
      
        &lt;p&gt;通常情况下，元素的position属性的值默认为static，也就是没有定位，元素出现再正常的文档流中，这个时候如果给元素设置left、right、bottom、top这些偏移属性，都不会生效，z-index也不会生效。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>通常情况下，元素的position属性的值默认为static，也就是没有定位，元素出现再正常的文档流中，这个时候如果给元素设置left、right、bottom、top这些偏移属性，都不会生效，z-index也不会生效。<a id="more"></a></p><h3 id="相对定位relative"><a href="#相对定位relative" class="headerlink" title="相对定位relative"></a>相对定位relative</h3><p>注意：使用相对定位时，就算元素被偏移了，但是它仍然会占据着没偏移之前的空间。  </p><p><img src="/2018/03/04/绝对定位与相对定位/relative1.png" alt=""></p><p><img src="/2018/03/04/绝对定位与相对定位/relative2.png" alt=""><br>上图，第二个块针对本身的位置发生了一个偏移，但是它原来所占据的那个位置空间仍然还在，即使它完全离开原来的位置，但是它原来位于文档流中的位置仍然会存在，不会被第三个浮动过来填补掉；同时它的偏移也不会把别的块从文档流中原来的位置挤开，如果有重叠的地方它会重叠再其他文档流元素之上，可以通关过设置z-index属性来调整他的堆叠顺序。  </p><h3 id="绝对定位absolute"><a href="#绝对定位absolute" class="headerlink" title="绝对定位absolute"></a>绝对定位absolute</h3><p>被设置了绝对定位的元素，在文档流中是不占据空间的，如果某元素设置了绝对定位，那么它在文档流中的位置会被删除，其实这个元素是浮了起来，它与relative的不同点在于：相对定位不会删除它本身在文档流中占据的那块空间，而绝对定位则会删除该元素在文档流中的位置，完全从文档流中抽出来。 </p><p>绝对定位是如何定位的？  </p><p>一、如果它的父级元素设置了除static之外的定位，比如position：relative 或者position：absolute或者position：fixed,那么它就会相对于它的父级元素来定位，位置通过left、top、right、bottom（刚好一个顺时针）属性来规定。</p><p>二、如果它的父级元素没有设置定位，那么就得看它父元素得父元素有没有设置定位，如果还是没有，就继续向更高层得祖先元素类推。  </p><p>小结：总之它的定位就是相对于设置了除static定位之外得定位得第一个祖先元素，如果以上情况都不存在，那么他就会相对于文档body来定位（并非窗口，相对于窗口来定位得是fixed）绝对定位得元素相对于谁来定位，我们就把这个“谁”叫做参照物。  </p><p><img src="/2018/03/04/绝对定位与相对定位/juedui1.png" alt=""><br>下面是使用了绝对定位得效果：  </p><p><img src="/2018/03/04/绝对定位与相对定位/juedui2.png" alt="">  </p><p><img src="/2018/03/04/绝对定位与相对定位/juedui3.png" alt="">  </p><p>注意：在设置偏移量得时候，可以设置负值。  </p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/04/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E4%B8%8E%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>函数传参</title>
      <link>http://yoursite.com/2018/03/04/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/</link>
      <guid>http://yoursite.com/2018/03/04/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/</guid>
      <pubDate>Sun, 04 Mar 2018 03:39:42 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;函数传参&quot;&gt;&lt;a href=&quot;#函数传参&quot; class=&quot;headerlink&quot; title=&quot;函数传参&quot;&gt;&lt;/a&gt;函数传参&lt;/h3&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><a id="more"></a><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;    &lt;title&gt;无标题文档&lt;/title&gt;    &lt;script&gt;    /*        函数传递参数        参数=JS的数据类型：            数字、字符串、布尔、函数、对象、未定义    */    fn1(100, &apos;px&apos;);    function fn1(a, b) {        // alert( a+b );    }    fn2(&apos;miaov&apos;);    fn2(&apos;妙味课堂&apos;);    function fn2(a) {        // alert(a.charAt(2));    }    //传递一个有名字的函数，不用带括号    function fn4() {        alert(4);    }    fn3(fn4);    fn3(function(a) { alert(a); });    function fn3(fn) {        fn(100);        fn();    }    //传递对象    fn5(window, document);    function fn5(w, d) {        w.onload = function() {            d.body.innerHTML = 123;        };    }    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;  </code></pre><h3 id="代码重用"><a href="#代码重用" class="headerlink" title="代码重用"></a>代码重用</h3><p>1、尽量保证 HTML 代码结构一致，可以通过父级选取子元素<br>2、把核心主程序实现，用函数包起来<br>3、把每组里不同的值找出来，通过传参实现  </p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;    &lt;title&gt;无标题文档&lt;/title&gt;    &lt;style&gt;    ul {        padding: 0;        margin: 0;    }    li {        list-style: none;    }    body {        background: #333;    }    .box {        width: 400px;        height: 500px;        position: relative;        background: url(img/loader_ico.gif) no-repeat center #fff;        float: left;        margin-right: 60px;    }    .box img {        width: 400px;        height: 500px;    }    .box ul {        width: 40px;        position: absolute;        top: 0;        right: -50px;    }    .box li {        width: 40px;        height: 40px;        margin-bottom: 4px;        background: #666;    }    .box .active {        background: #FC3;    }    .box span {        top: 0;    }    .box p {        bottom: 0;        margin: 0;    }    .box p,    .box span {        position: absolute;        left: 0;        width: 400px;        height: 30px;        line-height: 30px;        text-align: center;        color: #fff;        background: #000;    }    &lt;/style&gt;    &lt;script&gt;    window.onload = function() {        fnTab(&apos;pic1&apos;, [&apos;img/1.png&apos;, &apos;img/2.png&apos;, &apos;img/3.png&apos;, &apos;img/4.png&apos;], [&apos;小宠物&apos;, &apos;图片二&apos;, &apos;图片三&apos;, &apos;面具&apos;], &apos;onclick&apos;);        fnTab(&apos;pic2&apos;, [&apos;img/2.png&apos;, &apos;img/3.png&apos;, &apos;img/4.png&apos;], [&apos;图片二&apos;, &apos;图片三&apos;, &apos;面具&apos;], &apos;onmouseover&apos;);    };    function fnTab(id, arrUrl, arrText, evt) {        var oDiv = document.getElementById(id);        var oImg = oDiv.getElementsByTagName(&apos;img&apos;)[0];        var oSpan = oDiv.getElementsByTagName(&apos;span&apos;)[0];        var oP = oDiv.getElementsByTagName(&apos;p&apos;)[0];        var oUl = oDiv.getElementsByTagName(&apos;ul&apos;)[0];        var aLi = oUl.getElementsByTagName(&apos;li&apos;);        var num = 0;        for (var i = 0; i &lt; arrUrl.length; i++) {            oUl.innerHTML += &apos;&lt;li&gt;&lt;/li&gt;&apos;;        }        // 初始化        function fnTab() {            oImg.src = arrUrl[num];            oSpan.innerHTML = 1 + num + &apos; / &apos; + arrUrl.length;            oP.innerHTML = arrText[num];            for (var i = 0; i &lt; aLi.length; i++) {                aLi[i].className = &apos;&apos;;            }            aLi[num].className = &apos;active&apos;;        }        fnTab();        for (var i = 0; i &lt; aLi.length; i++) {            aLi[i].index = i; // 索引值            aLi[i][evt] = function() {                num = this.index;                fnTab();            };        }    }    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;pic1&quot; class=&quot;box&quot;&gt;        &lt;img src=&quot;&quot; /&gt;        &lt;span&gt;数量正在加载中……&lt;/span&gt;        &lt;p&gt;文字说明正在加载中……&lt;/p&gt;        &lt;ul&gt;&lt;/ul&gt;    &lt;/div&gt;    &lt;div id=&quot;pic2&quot; class=&quot;box&quot;&gt;        &lt;img src=&quot;&quot; /&gt;        &lt;span&gt;数量正在加载中……&lt;/span&gt;        &lt;p&gt;文字说明正在加载中……&lt;/p&gt;        &lt;ul&gt;&lt;/ul&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;  </code></pre><p><img src="/2018/03/04/函数传参/hanshu.gif" alt="">  </p><h3 id="应用：仿淘宝购物车计算"><a href="#应用：仿淘宝购物车计算" class="headerlink" title="应用：仿淘宝购物车计算"></a>应用：仿淘宝购物车计算</h3><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;    &lt;title&gt;无标题文档&lt;/title&gt;    &lt;script&gt;    window.onload = function() {        var oUl = document.getElementById(&apos;list&apos;);        var aLi = oUl.getElementsByTagName(&apos;li&apos;);        for (var i = 0; i &lt; aLi.length; i++) {            fn1(aLi[i]);        }        function fn1(oLi) {            var aBtn = oLi.getElementsByTagName(&apos;input&apos;);            var oStrong = oLi.getElementsByTagName(&apos;strong&apos;)[0];            var oEm = oLi.getElementsByTagName(&apos;em&apos;)[0];            var oSpan = oLi.getElementsByTagName(&apos;span&apos;)[0];            var n1 = Number(oStrong.innerHTML); //动态获取 &apos;0&apos;        =&gt;   0            var n2 = parseFloat(oEm.innerHTML); //动态获取   &apos;12.5元&apos; =&gt; 12.5            aBtn[0].onclick = function() {                n1--;                if (n1 &lt; 0) {                    n1 = 0;                }                oStrong.innerHTML = n1;                oSpan.innerHTML = n1 * n2 + &apos;元&apos;;            };            aBtn[1].onclick = function() {                n1++;                oStrong.innerHTML = n1;                oSpan.innerHTML = n1 * n2 + &apos;元&apos;;            };        }    };    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul id=&quot;list&quot;&gt;        &lt;li&gt;            &lt;input type=&quot;button&quot; value=&quot;-&quot; /&gt;            &lt;strong&gt;0&lt;/strong&gt;            &lt;input type=&quot;button&quot; value=&quot;+&quot; /&gt; 单价：            &lt;em&gt;12.5元&lt;/em&gt; 小计：            &lt;span&gt;0元&lt;/span&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;input type=&quot;button&quot; value=&quot;-&quot; /&gt;            &lt;strong&gt;0&lt;/strong&gt;            &lt;input type=&quot;button&quot; value=&quot;+&quot; /&gt; 单价：            &lt;em&gt;10.5元&lt;/em&gt; 小计：            &lt;span&gt;0元&lt;/span&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;input type=&quot;button&quot; value=&quot;-&quot; /&gt;            &lt;strong&gt;0&lt;/strong&gt;            &lt;input type=&quot;button&quot; value=&quot;+&quot; /&gt; 单价：            &lt;em&gt;8.5元&lt;/em&gt; 小计：            &lt;span&gt;0元&lt;/span&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;input type=&quot;button&quot; value=&quot;-&quot; /&gt;            &lt;strong&gt;0&lt;/strong&gt;            &lt;input type=&quot;button&quot; value=&quot;+&quot; /&gt; 单价：            &lt;em&gt;8元&lt;/em&gt; 小计：            &lt;span&gt;0元&lt;/span&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;input type=&quot;button&quot; value=&quot;-&quot; /&gt;            &lt;strong&gt;0&lt;/strong&gt;            &lt;input type=&quot;button&quot; value=&quot;+&quot; /&gt; 单价：            &lt;em&gt;14.5元&lt;/em&gt; 小计：            &lt;span&gt;0元&lt;/span&gt;        &lt;/li&gt;    &lt;/ul&gt;    &lt;p&gt;        商品合计共：0件，共花费了：0元        &lt;br /&gt; 其中最贵的商品单价是：0元    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;  </code></pre><p><img src="/2018/03/04/函数传参/gouwuche.gif" alt=""></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/04/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
