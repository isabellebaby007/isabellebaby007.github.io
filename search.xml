<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react router之router参数传递]]></title>
    <url>%2F2018%2F03%2F21%2Freact-router%E4%B9%8Brouter%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[react router之router概念]]></title>
    <url>%2F2018%2F03%2F21%2Freact-router%E4%B9%8Brouter%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[react样式之Ant Design样式框架使用]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E6%A0%B7%E5%BC%8F%E4%B9%8BAnt-Design%E6%A0%B7%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[react样式之Ant Design样式框架介绍]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E6%A0%B7%E5%BC%8F%E4%B9%8BAnt-Design%E6%A0%B7%E5%BC%8F%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[react样式之JSX样式与CSS的互转]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E6%A0%B7%E5%BC%8F%E4%B9%8BJSX%E6%A0%B7%E5%BC%8F%E4%B8%8ECSS%E7%9A%84%E4%BA%92%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[在线转换网址： https://staxmanade.com/CssToReact/ 其他前端工程师写好的一个css模块代码，可以直接通过这个工具在线转换为react可用的样式，提高协同工作的效率。 转成JSX之后可以直接在react项目里面使用 123456789101112131415161718192021222324import React from 'react';//var footerCss = require("../../css/footer.css");export default class ComponentFooter extends React.Component &#123; render() &#123; var footerConvertStyle = &#123; "miniFooter": &#123; "backgroundColor": "#333333", "color": "#ffffff", "paddingLeft": "20px", "paddingTop": "3px", "paddingBottom": "3px" &#125;, "miniFooter_h1": &#123; "fontSize": "15px" &#125; &#125;; //console.log(footerCss); return ( &lt;footer style=&#123;footerConvertStyle.miniFooter&#125;&gt; &lt;h1 style=&#123;footerConvertStyle.miniFooter_h1&#125;&gt;这里是页脚，一般放置版权的一些信息。&lt;/h1&gt; &lt;/footer&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>JSX样式与CSS互转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react样式之css模块化]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E6%A0%B7%E5%BC%8F%E4%B9%8Bcss%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>react样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react样式之内联样式中的表达式]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E6%A0%B7%E5%BC%8F%E4%B9%8B%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[react样式之内联样式]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E6%A0%B7%E5%BC%8F%E4%B9%8B%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>react样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react属性与事件之独立组件间共享Mixins]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BA%8B%E4%BB%B6%E4%B9%8B%E7%8B%AC%E7%AB%8B%E7%BB%84%E4%BB%B6%E9%97%B4%E5%85%B1%E4%BA%ABMixins%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[react属性与事件之组件的Refs]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BA%8B%E4%BB%B6%E4%B9%8B%E7%BB%84%E4%BB%B6%E7%9A%84Refs%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[react属性与事件之可复用组件]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BA%8B%E4%BB%B6%E4%B9%8B%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[react属性与事件之事件与属性的双向绑定]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BA%8B%E4%BB%B6%E4%B9%8B%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[bodyindex.js s1234567891011121314151617181920212223242526272829303132import React from 'react';import BodyChild from './bodychild';export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: "Parry", age: 20 &#125;; //初始化赋值 &#125;; changeUserInfo(age) &#123; this.setState(&#123;age: age&#125;); &#125;; handleChildValueChange(event) &#123; this.setState(&#123;age: event.target.value&#125;); &#125;; render() &#123; // setTimeout(()=&gt;&#123; // //更改 state 的时候 // this.setState(&#123;username: "IMOOC",age : 30&#125;); // &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;p&gt;age: &#123;this.state.age&#125;&lt;/p&gt; &lt;input type="button" value="提交" onClick=&#123;this.changeUserInfo.bind(this,99)&#125;/&gt; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ) &#125;&#125; bodychild.js 12345678910111213import React from 'React';export default class BodyChild extends React.Component&#123; render()&#123; return( &lt;div&gt; &lt;p&gt;子页面输入：&lt;input type="text" onChange=&#123;this.props.handleChildValueChange&#125;/&gt;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; index.js 12345678910111213141516171819202122232425262728293031323334353637var React = require('react');var ReactDOM = require('react-dom');import ComponentHeader from './components/header';import ComponentFooter from './components/footer';import BodyIndex from './components/bodyindex';class Index extends React.Component &#123; componentWillMount()&#123; //定义你的逻辑即可 console.log("Index - componentWillMount"); &#125; componentDidMount()&#123; console.log("Index - componentDidMount"); &#125; render() &#123; /* var component; if (用户已登录) &#123; component = &lt;ComponentLoginedHeader/&gt; &#125; else&#123; component = &lt;ComponentHeader/&gt; &#125; */ return ( &lt;div&gt; &lt;ComponentHeader/&gt; &lt;BodyIndex userid=&#123;123456&#125; username=&#123;"nick"&#125;/&gt; &lt;ComponentFooter/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById('example'));]]></content>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react属性与事件之Props属性]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BA%8B%E4%BB%B6%E4%B9%8BProps%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Props属性对于模块属于外来属性 在index.js里面定义username的值 12345678910111213141516171819202122232425262728293031323334353637var React = require('react');var ReactDOM = require('react-dom');import ComponentHeader from './components/header';import ComponentFooter from './components/footer';import BodyIndex from './components/bodyindex';class Index extends React.Component &#123; componentWillMount()&#123; //定义你的逻辑即可 console.log("Index - componentWillMount"); &#125; componentDidMount()&#123; console.log("Index - componentDidMount"); &#125; render() &#123; /* var component; if (用户已登录) &#123; component = &lt;ComponentLoginedHeader/&gt; &#125; else&#123; component = &lt;ComponentHeader/&gt; &#125; */ return ( &lt;div&gt; &lt;ComponentHeader/&gt; &lt;BodyIndex userid=&#123;123456&#125; username=&#123;"nick"&#125;/&gt; //传递参数 &lt;ComponentFooter/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById('example')); bodyindex.js模块里面引用index.js的username的值 123456789101112131415161718192021222324import React from 'react';export default class BodyIndex extends React.Component &#123; constructor()&#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username : "Parry", age : 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(()=&gt;&#123; //更改 state 的时候 this.setState(&#123;username: "IMOOC",age : 30&#125;); &#125;,4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125; &#123;this.props.userid&#125; &#123;this.props.username&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 小结传递参数 模块中接受参数 this.props.username]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>Props</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react属性与事件之state属性]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BA%8B%E4%BB%B6%E4%B9%8Bstate%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[State属性State属于自身属性，不会污染其他的组件 12345678910111213141516171819202122import React from &apos;react&apos;;export default class BodyIndex extends React.Component &#123; constructor() &#123; super(); //调用基类的所有的初始化方法 this.state = &#123; username: &quot;Parry&quot;, age: 20 &#125;; //初始化赋值 &#125; render() &#123; setTimeout(() =&gt; &#123; //更改 state 的时候 this.setState(&#123;username: &quot;IMOOC&quot;, age: 30&#125;); &#125;, 4000); return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;this.state.username&#125; &#123;this.state.age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 小结state初始化可以放在构造函数constructor里修改state: this.setStatestate的作用域只属于当前的类，不污染其他模块]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>state</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react组件基础之生命周期]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[生命周期12345678componentWillMount()&#123; //页面将要加载的时候 //定义你的逻辑即可 console.log(&quot;Index - componentWillMount&quot;);&#125;componentDidMount()&#123; //页面加载完了的时候 console.log(&quot;Index - componentDidMount&quot;);&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react组件基础之JSX内置表达式]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%E4%B9%8BJSX%E5%86%85%E7%BD%AE%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223import React from &apos;react&apos;;export default class BodyIndex extends React.Component&#123; render()&#123; var userName = &apos;&apos;; var boolInput = false; var html = &quot;IMOOC&amp;nbsp;LESSON&quot;; //comments return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;p&gt;&#123;userName==&apos;&apos; ? &apos;用户还没有登录&apos; : &apos;用户名：&apos; + userName&#125;&lt;/p&gt; &lt;p&gt;&lt;input type=&apos;button&apos; value = &#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;&lt;/p&gt; &#123;/*注释*/&#125; &lt;p&gt;&#123;html&#125;&lt;/p&gt; &#123;/*需要进行 Unicode 的转码*/&#125; &lt;p dangerouslySetInnerHTML =&#123;&#123;__html : html&#125;&#125;&gt;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 小结三元表达式的写法#####属性进行动态值绑定的时候，去掉引号 注释的写法要显示纯html进行unicode转码用dangerouslySetInnerHTML]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>JSX内置表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react组件基础之react多组件嵌套]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%E4%B9%8Breact%E5%A4%9A%E7%BB%84%E4%BB%B6%E5%B5%8C%E5%A5%97%2F</url>
    <content type="text"><![CDATA[多组件嵌套 footer.js组件 12345678910import React from &apos;react&apos;;export default class ComponentFooter extends React.Component&#123; render()&#123; return ( &lt;footer&gt; &lt;h1&gt;这里是页脚，一般放置版权的一些信息。&lt;/h1&gt; &lt;/footer&gt; ) &#125;&#125; bodyindex.js组件 12345678910import React from &apos;react&apos;;export default class BodyIndex extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125; header.js组件 12345678910import React from &apos;react&apos;;export default class ComponentHeader extends React.Component&#123; render()&#123; return ( &lt;header&gt; &lt;h1&gt;这里是头部&lt;/h1&gt; &lt;/header&gt; ) &#125;&#125; index.js 123456789101112131415161718192021222324252627282930var React = require(&apos;react&apos;);var ReactDOM = require(&apos;react-dom&apos;);import ComponentHeader from &apos;./components/header&apos;;import ComponentFooter from &apos;./components/footer&apos;;import BodyIndex from &apos;./components/bodyindex&apos;; //导入三个组件进来，快速构建一个页面class Index extends React.Component &#123; render() &#123; /* var component; if (用户已登录) &#123; component = &lt;ComponentLoginedHeader/&gt; &#125; else&#123; component = &lt;ComponentHeader/&gt; &#125; */ return ( &lt;div&gt; &lt;ComponentHeader/&gt; &lt;BodyIndex/&gt; &lt;ComponentFooter/&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById(&apos;example&apos;)); 小结组件也可以通过参数的形式进行传递组件的return函数里返回的HTML节点必须是一个注意项目命名的规范与文件的结构化]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>react多组件嵌套</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react组件基础之react组件]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%E4%B9%8Breact%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[组件是react的一个主要特性1234567891011import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;export default class ComponentHeader extends React.Component&#123; //这里必须加，否则外部访问不到这个组件 render()&#123; return ( &lt;header&gt; &lt;h1&gt;这里是头部&lt;/h1&gt; &lt;/header&gt; ) &#125;&#125; 123456789101112131415var React = require(&apos;react&apos;);var ReactDOM = require(&apos;react-dom&apos;);import ComponentHeader from &apos;./components/header&apos;;class Index extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;ComponentHeader/&gt; //直接当成一个组件来使用 &lt;h2&gt;页面的主体内容&lt;/h2&gt; &lt;/div&gt; //return里面只能返回一个节点 ); &#125;&#125;ReactDOM.render( &lt;Index/&gt;, document.getElementById(&apos;example&apos;)); //绑定组件 小结组件的return函数里返回的HTML节点必须是一个可以给外部使用的组件定义：export default class ComponentHeader extends React.Component{}入口的定义：ReactDom.render( 要绑定的组件 , document.getElementById(‘example’));#### ###]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>react组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react组件基础之虚拟DOM]]></title>
    <url>%2F2018%2F03%2F21%2Freact%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%99%9A%E6%8B%9FDOM%2F</url>
    <content type="text"><![CDATA[虚拟DOM的结构 为什么快 如何实现的 虚拟DOM的开源算法：https://github.com/Matt-Esch/virsual-dom]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>虚拟DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[atom编辑器使用及配置]]></title>
    <url>%2F2018%2F03%2F21%2Fatom%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[下载和安装官网：https://atom.io/ github地址： https://github.com/atom/atom 插件配置在install里面安装插件 JS支持 atom-ternjs对js支持的一些包 格式化 atom-beautify做格式化的插件 直接打开浏览器 open-in-browser 快速HTML代码 emmet 文件图标 file-icons高亮当前行 highlight-line高亮所有选择highlight-selected]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决npm出现“unexpected end of json input while parsing near错误]]></title>
    <url>%2F2018%2F03%2F21%2F%E8%A7%A3%E5%86%B3npm%E5%87%BA%E7%8E%B0%E2%80%9Cunexpected-end-of-json-input-while-parsing-near%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[解决办法： 1npm cache clean --force 然后重新运行你出错时候的命令。]]></content>
      <categories>
        <category>前端</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发工具之Atom]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BAtom%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[基于react的头条新闻web开发]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%9F%BA%E4%BA%8Ereact%E7%9A%84%E5%A4%B4%E6%9D%A1%E6%96%B0%E9%97%BBweb%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>大项目</category>
        <category>桂林头条</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
        <tag>响应式布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序之环境搭建]]></title>
    <url>%2F2018%2F03%2F16%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less实战之grid布局]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E5%AE%9E%E6%88%98%E4%B9%8Bgrid%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[less实战之内容图片问题]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E5%AE%9E%E6%88%98%E4%B9%8B%E5%86%85%E5%AE%B9%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[less实战之头部]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%B4%E9%83%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[less实战之背景图问题]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E5%AE%9E%E6%88%98%E4%B9%8B%E8%83%8C%E6%99%AF%E5%9B%BE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[less实战之移动端的准备工作]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E5%AE%9E%E6%88%98%E4%B9%8B%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[less之其他内容]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E4%B9%8B%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[less之模式匹配]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E4%B9%8B%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[less之带默认值的参数混合]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E4%B9%8B%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%8F%82%E6%95%B0%E6%B7%B7%E5%90%88%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[less之带参数混合]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E4%B9%8B%E5%B8%A6%E5%8F%82%E6%95%B0%E6%B7%B7%E5%90%88%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[less之混合]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E4%B9%8B%E6%B7%B7%E5%90%88%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[less之变量]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E4%B9%8B%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[less之嵌套]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E4%B9%8B%E5%B5%8C%E5%A5%97%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[less之使用less的几种方法]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E4%B9%8B%E4%BD%BF%E7%94%A8less%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[less简介]]></title>
    <url>%2F2018%2F03%2F16%2Fless%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之seaJs的各种技巧]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8BseaJs%E7%9A%84%E5%90%84%E7%A7%8D%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之exports和module.exports的异同]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8Bexports%E5%92%8Cmodule-exports%E7%9A%84%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之seaJs各种配置信息]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8BseaJs%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之seaJs和gruntJs结合开发]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8BseaJs%E5%92%8CgruntJs%E7%BB%93%E5%90%88%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之seaJs构建的问题]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8BseaJs%E6%9E%84%E5%BB%BA%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之gruntJs的安装流程]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8BgruntJs%E7%9A%84%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之gruntJs的基本使用]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8BgruntJs%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之模块化的历史]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之利用seaJs开发webqq]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8B%E5%88%A9%E7%94%A8seaJs%E5%BC%80%E5%8F%91webqq%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之用require引入依赖模块]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8B%E7%94%A8require%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之用requi引入依赖模块]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8B%E7%94%A8requi%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之全局函数define定义模块]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8B%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0define%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之seaJs的简介]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8BseaJs%E7%9A%84%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js模块化之简介]]></title>
    <url>%2F2018%2F03%2F16%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[实现JQ中的extend]]></title>
    <url>%2F2018%2F03%2F16%2F%E5%AE%9E%E7%8E%B0JQ%E4%B8%AD%E7%9A%84extend%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[实现JQ中链式操作和事件细节]]></title>
    <url>%2F2018%2F03%2F16%2F%E5%AE%9E%E7%8E%B0JQ%E4%B8%AD%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[实现JQ中的常见功能(五)]]></title>
    <url>%2F2018%2F03%2F16%2F%E5%AE%9E%E7%8E%B0JQ%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD-%E4%BA%94%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[实现JQ中的常见功能(四)]]></title>
    <url>%2F2018%2F03%2F16%2F%E5%AE%9E%E7%8E%B0JQ%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD-%E5%9B%9B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[实现JQ中的常见功能(三)]]></title>
    <url>%2F2018%2F03%2F16%2F%E5%AE%9E%E7%8E%B0JQ%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD-%E4%B8%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[实现JQ中的常见功能(二)]]></title>
    <url>%2F2018%2F03%2F16%2F%E5%AE%9E%E7%8E%B0JQ%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD-%E4%BA%8C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[实现JQ中的常见功能(一)]]></title>
    <url>%2F2018%2F03%2F16%2F%E5%AE%9E%E7%8E%B0JQ%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD-%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[vquery的选择元素]]></title>
    <url>%2F2018%2F03%2F16%2Fvquery%E7%9A%84%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[vquery的基本框架形式]]></title>
    <url>%2F2018%2F03%2F16%2Fvquery%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[什么是vquery]]></title>
    <url>%2F2018%2F03%2F16%2F%E4%BB%80%E4%B9%88%E6%98%AFvquery%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery的插件操作]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E7%9A%84%E6%8F%92%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery的工具方法和ajax]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E7%9A%84%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95%E5%92%8Cajax%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery的工具方法]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E7%9A%84%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery事件操作]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E4%BA%8B%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery中的运动]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E4%B8%AD%E7%9A%84%E8%BF%90%E5%8A%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery中的DOM操作和数据操作]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E4%B8%AD%E7%9A%84DOM%E6%93%8D%E4%BD%9C%E5%92%8C%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery的DOM操作]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E7%9A%84DOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery基础的扩展]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E5%9F%BA%E7%A1%80%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery方法之hover和简单动画]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E6%96%B9%E6%B3%95%E4%B9%8Bhover%E5%92%8C%E7%AE%80%E5%8D%95%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery编写拖拽]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E7%BC%96%E5%86%99%E6%8B%96%E6%8B%BD%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery方法之offsetParent、val、size、each]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E6%96%B9%E6%B3%95%E4%B9%8BoffsetParent%E3%80%81val%E3%80%81size%E3%80%81each%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery方法之位置操作]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E6%96%B9%E6%B3%95%E4%B9%8B%E4%BD%8D%E7%BD%AE%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery方法之事件细节]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E6%96%B9%E6%B3%95%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery编写弹窗]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E7%BC%96%E5%86%99%E5%BC%B9%E7%AA%97%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery方法之事件操作和scrollTop]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E6%96%B9%E6%B3%95%E4%B9%8B%E4%BA%8B%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8CscrollTop%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery方法之DOM操作]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E6%96%B9%E6%B3%95%E4%B9%8BDOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery方法之属性操作]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E6%96%B9%E6%B3%95%E4%B9%8B%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery编写选项卡]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E7%BC%96%E5%86%99%E9%80%89%E9%A1%B9%E5%8D%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery方法之next、prev、find、eq、index、attr]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E6%96%B9%E6%B3%95%E4%B9%8Bnext%E3%80%81prev%E3%80%81find%E3%80%81eq%E3%80%81index%E3%80%81attr%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery方法之filter、not、has]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E6%96%B9%E6%B3%95%E4%B9%8Bfilter%E3%80%81not%E3%80%81has%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery设计思想之filter、not、has]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B9%8Bfilter%E3%80%81not%E3%80%81has%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery设计思想之取值和赋值]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B9%8B%E5%8F%96%E5%80%BC%E5%92%8C%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery设计思想之原生关系和链式操作]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B9%8B%E5%8E%9F%E7%94%9F%E5%85%B3%E7%B3%BB%E5%92%8C%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery设计思想之写法]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B9%8B%E5%86%99%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery设计思想之选择元素]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B9%8B%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery简介]]></title>
    <url>%2F2018%2F03%2F16%2FjQuery%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[react学习线路]]></title>
    <url>%2F2018%2F03%2F15%2Freact%E5%AD%A6%E4%B9%A0%E7%BA%BF%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[学习规划 基础：ES6语法 npm管理开发依赖 babel编译ES6和CSS的语法 react基础：JSX语法、Component组件、数据、事件、生命周期 环境搭建nodejs环境https://nodejs.org/en/ 下载文件之后并安装，此时命令行窗口输入node -v并回车可以查看版本。输入以下命令安装： 1npm i -g nrm]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之此publicPath和彼publicPath]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8B%E6%AD%A4publicPath%E5%92%8C%E5%BD%BCpublicPath%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[webpack之输出路径处理]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8B%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[webpack之优化babel-loader的配置]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8B%E4%BC%98%E5%8C%96babel-loader%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[webpack之重新认识babel-loader]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8B%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86babel-loader%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[webpack之使用babel插件和预设]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8B%E4%BD%BF%E7%94%A8babel%E6%8F%92%E4%BB%B6%E5%92%8C%E9%A2%84%E8%AE%BE%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[webpack之babel准备和运行]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8Bbabel%E5%87%86%E5%A4%87%E5%92%8C%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[webpack之使用Less和Scss]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8B%E4%BD%BF%E7%94%A8Less%E5%92%8CScss%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[webpack之css模块化]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8Bcss%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[webpack之引入字体]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8B%E5%BC%95%E5%85%A5%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[webpack之使用url-loader引入图片]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8B%E4%BD%BF%E7%94%A8url-loader%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[增强的file-loader:url-loader安装url-loader 1npm i -D url-loader 注意：url-loader会把图片使用base64的形式编码成另外一种字符串。网页可以识别这种编码的东西，好处是减少了图片的请求。如果图片过大，编码会更加大，这样会得不偿失。解决办法是：当某一个图片文件过大的时候就让他去打包,添加规则的时候，增加一个limit值,当小于这个值得时候，就会直接编码，大于这个值得时候就打包 小结当url-loader使用图片资源的时候，默认会把资源使用base64编码。 超过limit值就会被打包。]]></content>
      <categories>
        <category>前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之引入图片]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8B%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[流程安装file-loader这个库 1npm i -D file-loader 直接在app.js里面引入图片 引入不同格式的图片在配置文件里面添加多个规则]]></content>
      <categories>
        <category>前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之引入css样式]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8B%E5%BC%95%E5%85%A5css%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[流程默认webpack只会打包js的代码，想要webpack打包其他内容的时候，就要使用相应的loader。 安装css-loader 1npm i -D css-loader 安装style-loader 1npm i -D style-loader 在配置文件添加css loader和style loader模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344const HtmlWebpackPlugin = require('html-webpack-plugin');const path = require('path');module.exports = &#123; entry: './src/app.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'app.js', &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'src/index.html' &#125;) ], module: &#123; rules: [ &#123; test: /\.js$/, use: [ &#123; loader: 'babel-loader', options: &#123; presets: ['react'] &#125; &#125; ] &#125;, &#123; test: /\.css$/, use: [ 'style-loader' ,'css-loader' ] &#125; ] &#125;, devServer: &#123; open: true, port: 9000 &#125;&#125;; 在app.js里面引入样式文件,可以引入多个 1234567891011import React from 'react';import ReactDOM from 'react-dom';import './main.css';import './app.css';ReactDOM.render( &lt;div className="ret"&gt;React&lt;/div&gt;, document.getElementById('root')); 打包项目： 1npm run dev 运行项目： 1npm run start 小结1、首先在配置文件添加新的规则来匹配.css格式的文件 2、然后添加 两个loader,处理顺序：当匹配到css这个loader之后，会先启用css-loader来处理里面的内容，当这些内容处理完成得到结果之后会把这些处理完成的东西再继续交给style-loader来处理]]></content>
      <categories>
        <category>前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之devserver介绍]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8Bdevserver%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[dev-server安装开发服务器的库 1npm i -D webpack-dev-server 在packag.json添加运行命令start1234567891011121314151617181920212223242526&#123; "name": "2", "version": "1.0.0", "description": "", "main": "webpack.config.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "webpack --config webpack.config.dev.js", "start": "webpack-dev-server --config webpack.config.dev.js" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "babel-core": "^6.26.0", "babel-loader": "^7.1.2", "babel-preset-react": "^6.24.1", "html-webpack-plugin": "^2.30.1", "webpack": "^3.5.5", "webpack-dev-server": "^2.8.2" &#125;, "dependencies": &#123; "react": "^15.6.1", "react-dom": "^15.6.1" &#125;&#125; 运行,开启服务器，开启服务器的时候，首先找到配置文件，先帮我们打包，打包完成之后，再让我们去访问已经打包好的资源。所以后面要加–config webpack.config.dev.js找到配置文件 1npm run start 注意：这里dev-server打包后的资源并不是放到硬盘里面，而是打包后放到内存里面，所以文件夹下面并没有生成新的打包资源文件。 定制化配置webpack.config.dev.js 12345678910111213141516171819202122232425262728293031const HtmlWebpackPlugin = require('html-webpack-plugin');const path = require('path');module.exports = &#123; entry: './src/app.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'app.js', &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'src/index.html' &#125;) ], module: &#123; rules: [&#123; test: /\.js$/, use: [&#123; loader: 'babel-loader', options: &#123; presets: ['react'] &#125; &#125;] &#125;] &#125;, devServer: &#123; open: true, port: 9000 &#125;&#125;;]]></content>
      <categories>
        <category>前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之loader]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8Bloader%2F</url>
    <content type="text"><![CDATA[loader作用：预处理模块里的内容 安装两个库 1npm i 1npm i -S react react-dom 安装完成后，可以看到package.json里面新增了 我们在app.js文件里面先把这两个库引用进来 使用命令行来进行打包 1npm run dev 这个时候会报错，需要一个model来处理这些文件]]></content>
      <categories>
        <category>前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之插件]]></title>
    <url>%2F2018%2F03%2F15%2Fwebpack%E4%B9%8B%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[插件自动在dist文件夹中添加index.html文件的插件 1r npm i -D html webpack -plugin 在webpack.config.dev.js配置文件添加]]></content>
      <categories>
        <category>前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之异步操作Promise]]></title>
    <url>%2F2018%2F03%2F14%2FES6%E4%B9%8B%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9CPromise%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ES6之函数的扩展、箭头函数]]></title>
    <url>%2F2018%2F03%2F14%2FES6%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ES6之内置对象的扩展]]></title>
    <url>%2F2018%2F03%2F14%2FES6%E4%B9%8B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ES6之Symbol数据类型]]></title>
    <url>%2F2018%2F03%2F14%2FES6%E4%B9%8BSymbol%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ES6之class的继承]]></title>
    <url>%2F2018%2F03%2F14%2FES6%E4%B9%8Bclass%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之class的基本使用]]></title>
    <url>%2F2018%2F03%2F14%2FES6%E4%B9%8Bclass%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[class语法JS语言的传递方法是通过构造函数，定义并生成新对象，是一种基于原型的面向对象系统。这种写法跟传统的面向对象语言差异很大，很容易让新学习这门语言的人感到困惑。所以，在ES6中新增了类的概念，可以使用class关键字声明了一个类，之后以这个类来实例化对象。 基于原型的面向对象系统： 1234567891011121314const Miaov=function(a,b)&#123; this.a=a; this.b=b; return this;&#125;;Miaov.prototype=&#123; constructor:Miaov, print:funvtion()&#123; console.log(this.a+''+this.b); &#125;&#125;;const miaov=new Miaov('hello','world').print(); 1234567891011121314class Miaov&#123; constructor(a,b)&#123; this.a=a; this.b=b; return this; &#125; print()&#123; console.log(this.a+''+this.b); &#125;&#125;;const miaov=new Miaov('hello','world').print();console.log(typeof Miaov); //function 说明：1、Miaov中的constructor方法是构造方法，this关键字则代表实例对象。也就是说，ES5的构造函数Miaov,对应ES6的Miaov这个类的构造方法。 2、Miaov这个类除了构造方法，还定义了一个print方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 3、构造函数的prototype属性，在ES6的类上面继续存在，而且类的所有方法都定义在类的prototype属性上面。 console.log(Miaov.prototype);//object{constructor:function,print:function} 4、定义在类中的方法都是不可以枚举的。 console.log(object.keys(Miaov.prototype));//不能打印出来 5、constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之iterator和foor-of循环]]></title>
    <url>%2F2018%2F03%2F14%2FES6%E4%B9%8Biterator%E5%92%8Cfoor-of%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[基本概念在ES6中新增了Set和Map两种数据结构，再加上JS之前原有的数组和对象，这样就有了四种数据集合，平时还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map,Map的成员是对象等。这样就需要一种统一的接口机制，来处理所有不同的数据结构。 Iterator就是这样一种机制，他是一种接口，为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署Iterator接口，就可以完成遍历操作，而且这种遍历操作是依次处理该数据结构的所有成员。 Iterator遍历器的作用1、为各种数据结构，提供一个统一的、简便的访问接口。 2、使得数据结构的成员能够按照某种次序排列 3、ES6新增了便利命令for….of循环，Iterator接口主要供for…of消费 1、手写Iterrator接口 123456789101112131415161718192021const arr=[1,2,3];function iterator(arr)&#123; let index=0; return&#123; next:function()&#123; return index&lt;arr.length ? &#123;value:arr[index++],done:false&#125;: &#123;value:undefined,done:true&#125;; &#125; &#125;&#125;const it=iterator(arr);console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next()); Iterator的遍历过程1、创建一个指针队形，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 2、第一次调用只针对想的next方法，可以将指针指向数据结构的第一个成员。 3、第二次调用只针对想的next方法，指针就指向数据结构的第二个成员 4、不断调用只针对想的next方法，知道它指向数据结构的结束位置。 5、每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性就是当前成员的值，done属性是一个布尔值，便是遍历是否结束。 小结：凡是具有Symbol.iterator属性的数据结构都具有Iterator接口]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构Map]]></title>
    <url>%2F2018%2F03%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Map%2F</url>
    <content type="text"><![CDATA[Map字典：是用来存储不重复key的Hash结构，不同于集合（Set）的是，字典使用的是[键，值]的形式来储存数据的。 JavaScript的对象(Object:{})只能用字符串当作键。这给它的使用带来了很大的限制。 为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串-值”的对应，Map结构提供了“值-值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。 12345678var data1=&#123;a:1&#125;,data2=&#123;b,2&#125;,obj=&#123;&#125;;obj[data1]=1;obj[data2]=2;console.log(obj);console.log(data1.toString()===data2.toString()); 如何创建一个Map12345678const map=new Map([ ['a',1], ['b',2]]);consolee.log(map); //Map(2)&#123;"a"=&gt;1,"b"=&gt;2&#125; Map类的属性1console.log(map.size); Map类的方法1、set(key,value)设置键名key对应的键值为value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。 12map.set('atom','coco').set('new','fq');console.log(map); 2、get(key) get方法读取key对应的键值，如果找不到key,返回undefined 12console.log(map.get('new'));console.log(map.get('x')); 3、delete(key)删除某个键，返回true。如果删除失败，返回false。 12console.log(map.delete('a'));console.log(map); 4、has(key)方法返回一个布尔值，表示某个键是否在当前Map对象之中。 12console.log(map.has('atom'));console.log(map.has('a')); 5、clear() 清除所有数据，没有返回值 1map.clear(); 6、keys() 返回键名的遍历器 1console.log(map.keys()); 7、values()返回键值的遍历器 1console.log(map.values()); 8、entries() 返回键值对的遍历器 1console.log(map.entries());//返回MapIterator&#123;&#123;"b",2&#125;,&#123;"atom","coco"&#125;&#125; 9、forEach() 使用毁掉函数遍历每个成员 123map.forEach(function(key,value,map)&#123; console.log(key+':'+value);&#125;) 注意事项123map.set(NaN,10).set(NaN,100);console.log(map);]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构set]]></title>
    <url>%2F2018%2F03%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84set%2F</url>
    <content type="text"><![CDATA[集合概念：集合是由一组无序且唯一的项组成的，这个数据解构使用了与有限集合相同的数学概念，应用在计算机的数据结构中。 特点：key和value相同，没有重复的value。 ES6提供了数据结构Set,类似于数组，但是成员的值都是唯一的，没有重复的值。 如何创建一个Set123const s=new Set([1,2,3]);console.log(s); //Set(3)&#123;1,2,3&#125; Set类的属性1console.log(s.size); //3 Set类的方法set.add(value): 添加一个数据，返回Set结构本身 12s.add('a').add('b').add('c');cosole.log(s); set.delete(value); 删除指定的数据，返回一个布尔值，表示删除是否成功 12 set.has(value);判断该值是否为Set成员，返回一个布尔值 set.clear();清楚所有数据，没有返回值 keys();返回键名的遍历器 values();返回键值的遍历器 entries() 返回键值对的遍历器 forEach() 使用回调函数遍历每个成员 12345678s.forEach(function(value,key,set)&#123; console.log(value+'hahaha'); &#125;);console.log(s); //1 hahaha 2 hahaha 3 hahaha b hahaha c hahahas.add(1);console.log(s); //1并没有被添加进去，说明set不允许有重复的数据 思考：利用set进行去重？]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量的解构赋值]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[变量的解构赋值本质上是一种匹配模式。只要等号两边的模式相同，那么左边的变量就可以被赋予对应的值。 解构赋值主要分为： 1、数组的解构赋值 2、对象的解构赋值 3、基本类型的解构赋值 数组的解构赋值1234567891011121314let [a, b,c]=[1,2,3];console.log(a,b,c); //1,2,3let [a,[[b],c]]=[1,[[2],3]];console.log(a,b,c); //1,2,3let [, , c]=[1,2,3];console.log(c); //3let [x]=[];console.log(x); //undefinedlet [y=1]=[];console.log(y); //1 对象的解构赋值先找到同名的属性，然后再赋值给变量 1234567let &#123;a,b&#125;=&#123;b:'bbb', a:'aaa'&#125;;console.log(a,b); //aaa bbblet &#123;a: b&#125;=&#123;a:1&#125;;console.log(b); //1 基本类型的解构赋值null 和undefined不能进行解构赋值 12345678910111213let [a,b,c,d]='1234';console.log(a,b,c,d);let &#123;length;len&#125;='hahah';console.log(len); //5let &#123;toString:ts&#125;=1;let &#123;toString:bs&#125;=true;console.log(ts);console.log(bs); //打印出toString()函数console.log(ts===Number.prototype.toString);console.log(bs===Boolean.prototype.toString);]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let和const]]></title>
    <url>%2F2018%2F03%2F14%2Flet%E5%92%8Cconst%2F</url>
    <content type="text"><![CDATA[let命令用来声明一个变量，和var类似 注意事项： 1、使用let声明的变量只在命令所在的代码块内有效。 1234567&#123; let a=1; var b=2; console.log(a); //可以打印出&#125;console.log(a); //打印不出来console.log（b）； //可以访问到b 2、使用let命令声明的变量在域解析的时候不会被提升。 12345678910111213141516console.log(a); //可以打印出a 因为a域解析的时候被提升了var a=1;console.log(b); //报错，b未定义， 因为b域解析的时候不会被提升let b=2;typeof c; //报错let c=10;let f=10;function fn()&#123; f=7; //暂时性死区 let f=2;&#125;fn(); 3、let不允许在同一个作用于下声明已经存在的变量 123456var a=1;let a; //报错let b=1;let b=2; //报错 let在for循环中的应用 1234567var btns =document.querySelectorAll('button');for (var i=0;i&lt;btns.length;i++)&#123; btns[i].onclik=function()&#123; console.log(i); &#125;&#125; //问题：每次切换的时候，显示最大的那个数 解决方法一 1234567for( var i=0;i&lt;btns.length;i++)&#123; btns[i].index=i; btns[i].onclik=function()&#123; console.log(this.index); &#125;&#125; 解决方法二 12345678//函数表达式，把i当作参数传到函数表达式当中for(var i=0;i&lt;btns.length;i++)&#123; (function(i)&#123; btns[i].onclick=function()&#123; console.log(i); &#125; &#125;)(i)&#125; 解决方法三:用let 12345for(let i=0;i&lt;btns.length;i++)&#123; btns[i].onclick=function()&#123; console.log(i); &#125;;&#125; 注意：let声明的变量在循环语句之内是一个父作用域，在循环体中是一个字作用域 12345for (let i=0;i&lt;3;i++)&#123; let i=10; console.log(i); //每次打印10 不受循环语句中的i影响&#125;console.log(i); //未定义 let声明的变量i只在循环语句中有用，循环完成之后不会泄露到for循环所在的作用域之中 constconst命令同样有上面let的1、2、3条特点，第一：所声明的常量只在其所在的代码块内有效。第二：声明的常量不会被提升。第三:不能声明已经被声明过的常量或变量。除了这些，在使用const声明常量的时候需要注意两点：1、声明的时候必须赋值。2、声明的常量储存简单的数据类型时候不可改变其值，如果储存的是对象，那么引用不可以被改变，至于对象里面的数据如何变化，是没有关系的。 1234const obj=&#123;a:10&#125;;obj.a=20;console.log(obj);]]></content>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6开发环境搭建]]></title>
    <url>%2F2018%2F03%2F14%2FES6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[为什么要用ES6在搭建es6开发环境之前，先简单介绍一下es6。 ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 那么，你肯定又要问，问什么要搭建es的开发环境，上面不都说 es6是JavaScript 语言的下一代标准了嘛，我们平时写的js都不需要搭建环境，直接在浏览器里就能运行。 因为至今各大浏览器厂商所开发的 JavaScript 引擎都还没有完成对 ES2015 中所有特性的完美支持，如果直接使用的话，会报错的。 所以我们既想使用es6带来的新语法、新特性，又想让现在的浏览器支持es6语法，于是乎像 babel、Traceur 等编译器便出现了。它们能将尚未得到支持的 ES2015 特性转换为 ES5 标准的代码，使其得到浏览器的支持。 这里我们就使用Babel把ES6编译成ES5。 建立工程目录先建立项目的工程目录，并在目录下边建立两个文件夹：src和dist src 书写ES6代码的文件夹，写的js程序都放在这里 dist 利用Babel编译成的ES5代码的文件夹，在HTML页面需要引入的时这里的js文件。 文件夹建立好之后，新建一个index.html的文件 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript" src="dist/main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意，在引入js文件时，引入的是dist目录下的文件 1&lt;script type="text/javascript" src="dist/main.js"&gt;&lt;/script&gt;&lt;/body&gt; 编写src文件夹下的main.js文件， 12let a=1;console.log(a); 我们用了let声明，这里let是ES6的一种声明方式，接下来我们需要把这个ES6的语法文件自动编程成ES5的语法文件。 初始化项目在安装Babel之前，需要用npm init先初始化我们的项目。打开终端或者通过cmd打开命令行工具，进入项目目录，输入下边的命令： 1npm init -y -y代表全部默认同意，就不用一次次按回车了。命令执行完成后，会在项目根目录下生产package.json文件。 123456789101112&#123; "name": "es6", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [], "author": "", "license": "ISC"&#125; 全局安装Babel-cli在终端中输入以下命令,如果你安装很慢的话，可以使用淘宝镜像的cnpm来进行安装。安装cnpm的方法，大家自己百度吧。 1cnpm install -g babel-cli 虽然已经安装了babel-cli，只是这样还不能成功进行转换，如果你不相信可以输入下边的命令试一下。 你会发现，在dist目录下确实生产了index.js文件，但是文件并没有变化，还是使用了ES6的语法。因为我们还需要安装转换包才能成功转换，继续往下看吧。 本地安装babel-preset-es2015和babel-cli1cnpm install --save-dev babel-preset-es2015 babel-cli 安装完成后，我们可以看一下我们的package.json文件，已经多了devDependencies选项。 1234"devDependencies": &#123; "babel-cli": "^6.24.1", "babel-preset-es2015": "^6.24.1" &#125; 新建.babelrc在根目录下新建.babelrc文件(注意，以点开头的文件是隐藏文件，需要在linux环境通过命令创建)，并打开录入下面的代码 123456&#123; "presets":[ "es2015" ], "plugins":[]&#125; 这个文件我们建立完成后，现在可以在终端输入的转换命令了，这次ES6成功转化为ES5的语法 1babel src/index.js -o dist/index.js 简化转化命令学习vue 的时候，可以使用npm run build 直接利用webpack进行打包，在这里也希望利用这种方式完成转换。打开package.json文件，把文件修改成下面的样子。 12345678910111213141516&#123; "name": "es6", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "build": "babel src/index.js -o dist/index.js" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "babel-cli": "^6.24.1", "babel-preset-es2015": "^6.24.1" &#125;&#125; 修改好后，以后我们就可以使用 npm run build 来进行转换了。 这样，一个简单的基本的编译环境就OK了。]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5的音频与视频]]></title>
    <url>%2F2018%2F03%2F14%2FHTML5%E7%9A%84%E9%9F%B3%E9%A2%91%E4%B8%8E%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的地理信息、本地存储、离线存储]]></title>
    <url>%2F2018%2F03%2F14%2FHTML5%E7%9A%84%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF%E3%80%81%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E3%80%81%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的跨文档消息通信]]></title>
    <url>%2F2018%2F03%2F14%2FHTML5%E7%9A%84%E8%B7%A8%E6%96%87%E6%A1%A3%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的canvas]]></title>
    <url>%2F2018%2F03%2F14%2FHTML5%E7%9A%84canvas%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5的新特性]]></title>
    <url>%2F2018%2F03%2F14%2FHTML5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[初识HTML5]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%88%9D%E8%AF%86HTML5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[bootstrap]]></title>
    <url>%2F2018%2F03%2F13%2Fbootstrap%2F</url>
    <content type="text"><![CDATA[栅格系统概念：分12列 row col 分辨率阈值：768 992 1200 &lt;768 手机 768&lt; &lt;992 pad 992&lt; &lt;1200 中等屏幕 &gt;1200 大屏幕 容器 container-fluid 流体 container 固定 1170 970 750 auto 针对不同的分辨率有不同的尺寸 1234567891011121314151617181920212223242526&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;link rel="stylesheet" href="css/bootstrap.css"&gt;&lt;style&gt;.container&#123; width:1000px !important; border:1px #000 solid;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--&lt;div class="container-fluid"&gt; aaaaaaaaa&lt;/div&gt;--&gt;&lt;div class="container"&gt; aaaaaaaaa&lt;/div&gt;&lt;/body&gt;&lt;script src="js/jquery-1.11.1.js"&gt;&lt;/script&gt;&lt;script src="js/bootstrap.js"&gt;&lt;/script&gt;&lt;/html&gt; 语法 col-lg-* col-md-* col-sm-* col-xs-* 列偏移 col-[]-offset- 列排序 col-[]-push- col-[]-pull- 嵌套 嵌套的一行按照父级进行分配 清浮动 cleanfix 响应式概念：针对不同设备展示或隐藏页面内容。 可见类 visible-- lg md sm xs block inline inline-block hidden-* 打印类 visible-print-* hidden-print 固定定位 affix 字体图标Glyphicons字体图标 好处： 1、减少请求 2、容易控制样式 用法：font-face 字体路径 自制图标：http://jingyan.baidu.com/article/f79b7cb346cf499145023e78.html 预定义样式风格 预定义样式风格 primary 首选项 success 成功 info 一般信息 warning 警告 danger 危险 按钮基类：btn 样式 btn-default 默认 btn-link 链接 大小 btn-*[lg,sm,xs] 状态 active disabled 种类 a input button 块级 btn-block 比较适合用在移动设备上，自适应的按钮 按钮组 btn-group btn-group-justified 按钮组的端点对齐 btn-group-vertical 按钮组从横向的改成纵向的，一般写纵向的不用加btn-group 标签页 头部 nav nav-tabs nav-justified 端点对齐 nav-tabs-justified nav-pills nav-stacked 竖状菜单 内容 tab-content tab-pane data-toggle=”tab” href对应id 淡入淡出方式 鼠标移入方式 导航条 导航条 navbar navbar-default nav navbar-nav navbar-inverse 相反的色调 navbar-static-top navbar-fixed-top navbar-fixed-bottom 导航条 navbar-header navbar-brand navbar-left navbar-right navbar-btn navbar-link navbar-text navbar-form 例子：知乎导航条 响应式导航条 navbar-toggle collapse navbar-collapse 滚动监听 data-spy data-target data-offset]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>框架</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面向对象之组件开发]]></title>
    <url>%2F2018%2F03%2F13%2Fjs%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>js面向对象及组件开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象基础]]></title>
    <url>%2F2018%2F03%2F12%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[什么是面向对象用对象的思想去写程序，就是面向对象编程 -过程式写法 -面向对象写法 例如：数组Array时间Date 1234567891011var arr=new Array(); //系统自带的对象，叫做系统对象var date=new Date();arr.lengtharr.push();arr.sort();date.getDate();var t1=new Tab();t1.over();t1.autoPlay(); 面向对象编程（OOP）的特点 抽象 抓住核心问题 封装 只能通过对象来访问方法 继承 从已有对象上继承出新的对象 多态 多对象的不同形态 面向对象的基本写法何组成对象的组成方法（行为、操作）–函数：过程、动态的 属性-变量：状态、静态的 创建第一个面向对象程序对象下面的变量：叫做对象的属性 对象下面的函数：叫做对象的方法 为对象添加属性和方法 object对象 this指向 创建两个对象：重复代码过多 12345678910var arr=[];arr.number=10;arr.test=function()&#123; alert(123);&#125;;arr.test();arr.push();arr.sort(); 12345var obj=new object();//创建了一个空的对象obj.name='小明';obj.showName=function()&#123; alert(obj.name);&#125;; 工厂方式与构造函数1234567891011121314151617function createPerson(name)&#123; //原料 var obj =new Object(); //加工 obj.name=name; obj.showName=function()&#123; alert(this.name); &#125;; //出场 return obj;&#125;var p1=createPerson('小明');p1.showName();var p2=createPerson('小明');p2.showName(); 当new去调用一个函数：这个时候函数中的this就是创建出来的对象，而且函数的返回值直接就是this （隐式返回） 12345678910111213function CreatePerson(name)&#123; this.name=name; this.shortName=function()&#123; alert(this.name); &#125;; &#125;var p1=new CreatePerson('小明');p1.showName();var p2=CreatePerson('小明');p2.showName(); 对象引用是什么和它的问题1234567891011function CreatePerson(name)&#123; this.name=name; this.shortName=function()&#123; alert(this.name); &#125;;&#125;var p1=new CreatePerson('小强');var p2=new CreatePerson('小明');alert(p1.showName==p2.showName); //false 这里为什么会出现false? 原因：因为基本类型的比较，只要值相同就可以了；而对象类型的比较，值和引用都要相同才可以。p1.showName和p2.showName分别在不同的地址创建了对象，所以这里返回的是false。但是会造成很大的内存浪费 1234567891011121314151617181920212223242526var a = 5;var b = a;b += 3;alert(b); //8alert(a); //5 基本类型 : 赋值的时候只是值的复制var a = [1,2,3];var b = a;b.push(4);alert(b); //[1,2,3,4]alert(a); //[1,2,3,4] 对象类型 : 赋值不仅是值的复制，而且也是引用的传递//var a = [1,2,3];//var b = a;//b = [1,2,3,4];////alert(b); //[1,2,3,4]//alert(a); //[1,2,3]var a = 5;var b = 5;alert(a == b); // true 基本类型 : 值相同就可以var a = [1,2,3];var b = [1,2,3];alert( a == b ); //false //对象类型 : 值和引用都相同才行 面向对象之原型学习原型：去改写对象下面公用的方法或者属性，让同样的公用的东西在内存当中只存在一份（目的是为了提高性能） 类比：原型就像css中的class一样 ，而普通方法就像CSS中的style一样 注意：原型prototype : 要写在构造函数的下面 普通方法的例子123456789101112131415161718192021222324var arr = [1,2,3,4,5]; var arr2 = [2,2,2,2,2]; arr.sum = function()&#123; var result = 0; for(var i=0;i&lt;this.length;i++)&#123; result += this[i]; &#125; return result; &#125;; arr2.sum = function()&#123; var result = 0; for(var i=0;i&lt;this.length;i++)&#123; result += this[i]; &#125; return result; &#125;; //alert( arr.sum() ); //15 //alert( arr2.sum() ); //10*/ 原型的例子12345678910111213var arr = [1, 2, 3, 4, 5]; var arr2 = [2, 2, 2, 2, 2]; Array.prototype.sum = function() &#123; var result = 0; for (var i = 0; i &lt; this.length; i++) &#123; result += this[i]; &#125; return result; &#125;; alert(arr.sum()); //15 alert(arr2.sum()); //10 类比css中style的优先级大于class,所以这里的优先级也是 12345var arr = [];arr.number = 10;Array.prototype.number = 20;alert(arr.number); //10 1234var arr = [];Array.prototype.number = 20;alert(arr.number); //20 工厂方式之原型1234567891011121314151617181920212223242526 function CreatePerson(name) &#123; this.name = name; &#125; CreatePerson.prototype.showName = function() &#123; alert(this.name); &#125;; var p1 = new CreatePerson('小明'); //p1.showName(); var p2 = new CreatePerson('小强'); //p2.showName(); alert(p1.showName == p2.showName); //true 不仅值相同，而且地址相同，在内存中只存在一份 var arr = new Array(); var date = new Date(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 小结：面向对象的写法1234567891011function 构造函数()&#123; this.属性&#125;构造函数.原型.方法 = function()&#123;&#125;;var 对象1 = new 构造函数();对象1.方法(); 传统的过程式编写选项卡12 用面向对象封装通用选项卡12]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>js面向对象及组件开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM优化]]></title>
    <url>%2F2018%2F03%2F11%2FDOM%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[DOM优化DOM与浏览器 重排 改变页面的内容 重绘 浏览器显示内容 添加顺序 尽量在appendChild之前添加操作 合并dom操作 利用cssText 缓存布局信息 文档碎片 缓存布局优化 12345678window.onload=function()&#123; var oDiv=document.getElementById('div1'); setInterval(function()&#123; oDiv.style.left=oDiv.offsetLeft+1+'px'; oDiv.style.top=oDiv.offsetTight+1+'px'; &#125;,30);&#125;; 123456789101112window.onload=function()&#123; var oDiv=document.getElementById('div1'); var L=oDiv.offsetLeft; var T=oDiv.offsetTop; setInterval(function)&#123; L++: T++; oDiv.style.left=L+'px'; oDiv.style.left=T+'px'; &#125;,30);&#125;; 文档碎片 12345678910111213window.onload=function()&#123; var oUl=document.getElementById('ul1'); var oFrag=document.createDocumentFragment(); console.time('hello'); for(var i=0;i&lt;5000;i++)&#123; var oLi=document.createElement('li'); oFrag.appendChild(oLi); &#125; oUl.appendChild(oFrag); console.timeEnd('hello');&#125;; DOM与事件事件委托 DOM与前端模板能更好的对逻辑和视图分离，MVC架构的基础]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5的历史管理]]></title>
    <url>%2F2018%2F03%2F11%2Fhtml5%E7%9A%84%E5%8E%86%E5%8F%B2%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[历史管理onhashchange :改变hash值来管理 history pushState 三个参数：数据 标题 (都没实现) 地址（可选） popstate事件 读取数据 event.state 注意:网址是虚假的，需要在服务器指定对应 页面，不然刷新找不到页面]]></content>
  </entry>
  <entry>
    <title><![CDATA[Firebug]]></title>
    <url>%2F2018%2F03%2F11%2FFirebug%2F</url>
    <content type="text"><![CDATA[命令 console.dir(cat); //输出所有信息 console.dirxml（）；//显示当前元素的代码结构 console.assert(a); //断言，如果a是真，返回断言成功 a是假，返回断言失败 console.trace();//显示当前函数的执行过程 1234567891011function a()&#123; return b();&#125;function b()&#123; return c();&#125;function c()&#123; console.trace(); return 1;&#125;a(); 12345console.time('计时器');for(var i=0;i&lt;1000000;i++)&#123; &#125;console.timend('计时器'); 查看性能 1234567891011121314151617function a()&#123; for(var i=0;i&lt;10;i++)&#123; b(); &#125; for(var i=0;i&lt;5;i++)&#123; c(); &#125; function b()&#123; var b=10; &#125; function c()&#123; var c=20; &#125;&#125;console.profile();a();console.profileEnd(); 在其他浏览器下使用firebug1&lt;script type="text/javascript" src="https://getfirebug.com/firebug-lite.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>工具</tag>
        <tag>firebug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2018%2F03%2F11%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[什么是闭包函数嵌套函数，内部函数可以引用外部函数的参数和变量，参数和变量不会被垃圾回收机制所收回 123456789function aaa()&#123; var a=5; function bbb()&#123; alert(a); &#125; return bbb;&#125;var c=aaa();c(); 闭包有什么好处1、希望一个变量长期驻扎在内存当中 2、避免全局变量的污染 123456789var a=1;function aaa()&#123; a++; alert(a);&#125;aaa(); //2aaa(); //3alert(a); 既让a是局部变量，又让a可以累加 123456789101112function aaa()&#123; var a=1; return function()&#123; a++; alert(a); &#125;&#125;var b=aaa();b();b();alert(a); 函数声明转变为函数表达式12345678function aaa()&#123; alert(1);&#125;aaa();(function aaa()&#123; alert(1);&#125;)();]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式布局]]></title>
    <url>%2F2018%2F03%2F11%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[css3分栏布局 column-width 栏目宽度 column-count 栏目列数 column-gap 栏目距离 column-rule 栏目间隔线 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .wrap &#123; width: 900px; border: 1px solid #000; font: 14px/28px "宋体"; color: #000; text-indent: 2em; -webkit-column-count: 4; -webkit-column-gap: 30px; -webkit-column-rule: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 响应式12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="indexa.css" media="screen and (min-width:800px)"&gt; &lt;link rel="stylesheet" type="text/css" href="indexb.css" media="screen and (min-width:400px) and (max-width:800px)"&gt; &lt;link rel="stylesheet" type="text/css" href="indexc.css" media="screen and (min-width:400px)"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 横屏竖屏自适应引入样式表的方法 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" media="all and (arientation:portrait)" href="indexb.css"&gt; &lt;link rel="stylesheet" type="text/css" media="all and (arientation:landscape)" href="indexa.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; style里面直接处理的方法 12345678&lt;style&gt; @media screen and (min-width:600px)&#123; 样式 &#125; @media screen and (min-width:400px) and(max-width:800px)&#123; 样式 &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>盒模型设计和响应式布局</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>响应式布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3盒模型新增属性]]></title>
    <url>%2F2018%2F03%2F10%2Fcss3%E7%9B%92%E6%A8%A1%E5%9E%8B%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[盒模型阴影box-shadowbox-shadow:[inset] x y blur [spread] color 参数： inset 投影方式 inset:内投影 不给 ：外投影 x、y 阴影偏移 blur 模糊半径 spread 扩展阴影半径 先扩展原有形状再2开始画阴影 color 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 100px; height: 100px; margin: 100px; background: red; box-shadow: 0 0 30px 30px #000, inset 0 0 10px #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; box-reflect倒影 box-reflect direction above \ below \ left \ right 距离 渐变（可选） 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; body&#123; background: #000; &#125; img &#123; display: block; margin: 200px auto; -webkit-box-reflect:right 10px -webkit-linear-gradient(right rgba(0,0,0,1) 0,rgba(0,0,0,0) 70%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="minguo.jpg" /&gt;&lt;/body&gt;&lt;/html&gt; resize自由缩放 both 水平垂直都可以缩放 horizontal 只有水平方向可以缩放 vertical 只有垂直方向可以缩放 要配合overflow：auto来使用，只有水平方向可以缩放 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 100px; height: 100px; background: url(minguo.jpg); border: 5px solid #000; resize: both; overflow: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; box-sizing盒模型的解析模式 content-box 标准盒模型 width\ height=border+padding+content border-box 怪异盒模型 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 200px; height: 200px; padding: 50px; border: 10px solid #000; box-sizing: border-box; &#125; .div &#123; height: 50px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="div"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>盒模型设计和响应式布局</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3弹性盒模型]]></title>
    <url>%2F2018%2F03%2F10%2Fcss3%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[弹性盒模型注意在使用弹性盒模型的时候，父元素必须要加display:box 或 inline-box box-orient 定义盒模型的布局方向 horizontal 水平方向 vertical 垂直显示 box-direction 元素排列顺序 normal 正序 reverse 反序 box-ordinal-group 设置元素的具体位置 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; height: 100px; border: 10px solid #000; padding: 10px; display: -webkit-box; -webkit-box-orient: vertical; &#125; .box div &#123; width: 100px; height: 100px; background: red; border: 1px solid #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 混序排列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; height: 100px; border: 10px solid #000; padding: 10px; display: -webkit-box; &#125; .box div &#123; width: 100px; height: 100px; background: red; border: 1px solid #fff; &#125; .box div:nth-of-type(1) &#123; -webkit-box-ordinal-group: 2; &#125; .box div:nth-of-type(2) &#123; -webkit-box-ordinal-group: 4; &#125; .box div:nth-of-type(3) &#123; -webkit-box-ordinal-group: 1; &#125; .box div:nth-of-type(4) &#123; -webkit-box-ordinal-group: 5; &#125; .box div:nth-of-type(5) &#123; -webkit-box-ordinal-group: 3; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; box-flex定义盒子的弹性空间 子元素的尺寸=盒子的尺寸*子元素的box-flex属性值/所有子元素的box-flex属性值之和 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; height: 100px; border: 10px solid #000; padding: 10px; display: -webkit-box; &#125; .box div &#123; width: 100px; height: 100px; background: red; border: 1px solid #fff; box-orient:horizontal; &#125; .box div:nth-of-type(1) &#123; -webkit-box-flex:1; &#125; .box div:nth-of-type(2) &#123; -webkit-box-flex:1; &#125; .box div:nth-of-type(3) &#123; width: 300px; &#125; .box div:nth-of-type(4) &#123; -webkit-box-flex:1; &#125; .box div:nth-of-type(5) &#123; -webkit-box-flex:1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; box-pack对盒子富裕的空间进行管理 start 所有子元素在盒子左侧显示，富裕空间在右侧 end 所有子元素在盒子右侧显示，富裕空间在左侧 center 所有子元素居中 justify 富裕空间在子元素之间平均分布]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>盒模型设计和响应式布局</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>弹性盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3新增UI样式]]></title>
    <url>%2F2018%2F03%2F10%2Fcss3%E6%96%B0%E5%A2%9EUI%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[圆角border-radiusborder-radius:1-4个数字/1-4个数字 前面是水平，后面是垂直 不给”/“,则水平和垂直一样 border-radius:10px/5px 参数：各种长度单位都可以：px,%, %有时候很方便，但是宽高不一致时不太好 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; .box &#123; width: 400px; height: 400px; margin: 50px auto; transition: 5s linear; &#125; .box div &#123; width: 180px; height: 180px; margin: 10px; border: 1px solid #000; box-sizing: border-box; float: left; background: url(new_bg.png) no-repeat; &#125; .box div:nth-child(1), .box div:nth-child(4) &#123; border-radius: 0 70%; &#125; .box div:nth-child(2), .box div:nth-child(3) &#123; border-radius: 70% 0; &#125; .box:hover &#123; -webkit-transform: rotate(720deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>新增UI样式</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>UI样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3文本新增属性]]></title>
    <url>%2F2018%2F03%2F10%2Fcss3%E6%96%87%E6%9C%AC%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[新增颜色模式 rgba r red 红 0-255 g green 绿 0-255 b blue 蓝 0-255 a Alpha 透明 0-1 例子：背景透明，文字不透明text-shadow 文字透明属性text-shadow:第一个参数表示x轴的偏移量 第二个参数表示y轴的偏移量 第三个参数表示模糊程度 第四个参数表示阴影颜色 阴影效果可以多层叠加，中间用,隔开 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p&#123; font；100px/200px "微软雅黑"； text-align: center; text-shadow: -5px -10px 1px red,5px 10px 1px green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;北京邮电&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子：层叠12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p&#123; color: red; font-size: 100px; font-weight: bold; text-shadow: 2px 2px 0px white,4px 4px 0px red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;北京邮电&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子：光晕1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; color: white; font-size: 100px; text-shadow: 0px 0px 10px #fff, 0px 0px 20px #fff, 0 0 30px #fff, 0 0 40px #fff, 0 0 40px #ff00de, 0 0 70px #ff00de, 0 0 80px #ff00de, 0 0 100px #ff00de, 0 0 150px #ff00de; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;北京邮电&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子：火焰文字123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; color: white; font-size: 100px; text-shadow: 0px 0px 20px #fefcc9, 10px -10px 30px #feec85, -20px -20px 40px #ffae34, 20px -40px 50px #ec760c, -20px -60px 60px #cd4606, 0 -80px 70px #973716, 10px -90px 80px #451b0e; font-family: Verdana,Geneva,sans-serif; font-size: 100px; font-weight: bold; color: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;北京邮电&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子：模糊效果123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; h1&#123; font:100px/200px "微软雅黑"; text-align: center; color: #000; text-shadow: 0 0 0 rgba(0,0,0,1); border:1px solid #000; transition:1s; &#125; h1:hover&#123; color: rgba(0,0,0,0); text-shadow: 0 0 100px rgba(0,0,0,0.5); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;北京邮电&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 文字描边只有webkit内核的浏览器才支持。-webkit-text-stroke:宽度 颜色； 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; h1 &#123; font: 100px/200px "微软雅黑"; text-align: center; color: #000; -webkit-text-stroke: 3px red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;北京邮电&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 文字排版direction 定义文字排列方式 Rtl 从右到左排列 ltr 从左到右排列 注意要配合unicode-bili一块使用 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; width: 300px; border: 1px solid #000; font: 14px/30px "宋体"; direction: rtl; unicode-bidi: bidi-override; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;北京邮电&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 文本省略text-overflow定义省略文本的处理方式 clip 无省略号 ellipsis 省略号 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; width: 300px; border: 1px solid #000; font: 14px/30px "宋体"; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;简称北邮，是中华人民共和国教育部直属，工业和信息化部共建的一所以信息科技为特色，工学门类为主体，管理学、文学、理学等多个学科门类协调发展的全国重点大学&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 自定义文字工具：asia font studio4 格式： @font-face{ font-family:’isabelle’; src:url(‘111-webfont.eot’); src:url(‘111-webfont.eot?#iefix’)format(‘embedded-opentype’), url(‘111-webfont.woff’)format(‘woff’), url(‘111-webfont.ttf’)format(‘truetype’), url(‘111-webfont.svg#untitledregular’)format(‘svg’); font-weight:normal; font-style:normal; } 转换字体格式生成兼容代码： http://www.fontsquirrel.com/fontface/generator]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>css3基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>文本新增属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3伪类和伪元素]]></title>
    <url>%2F2018%2F03%2F10%2Fcss3%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[伪类 E:target 表示当前的URL片段的元素类型，这个元素必须是E E:disabled 表示不可点击的表单控件 E:enabled 表示可点击的表单控件 E:checked 表示已选中的checkbox或radio E:first-line 表示E元素中的第一行 E:first-letter 表示E元素中的第一个字母 E::selection 表示E元素在用户选中文字时 E::before 生成内容在E元素前 E::after 生成内容在E元素之后 E：not(s) 表示E元素不被匹配 E~F 表示E元素毗邻的F元素,是指在E后面的标签 content 内容属性 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 300px; height: 200px; background: #000; font: 50px/200px "微软雅黑"; color: #fff; text-align: center; display: none; &#125; div:target &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="#div1"&gt;div1&lt;/a&gt; &lt;a href="#div2"&gt;div2&lt;/a&gt; &lt;a href="#div3"&gt;div3&lt;/a&gt; &lt;div id="div1"&gt;div1&lt;/div&gt; &lt;div id="div2"&gt;div2&lt;/div&gt; &lt;div id="div3"&gt;div3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; input &#123; width: 100px; height: 30px; color: #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" name="" value="请输入" /&gt;&lt;/body&gt;&lt;/html&gt; 例子：模拟单选框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; label &#123; float: left; margin: 0 5px; overflow: hidden; position: relative; &#125; label input &#123; position: absolute; left: -50px; top: -50px; &#125; span &#123; float: left; width: 50px; height: 50px; border: 3px solid #000; &#125; input:checked~span &#123; background: red; s &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;label&gt; &lt;input type="radio" name="tab"&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt; &lt;label&gt; &lt;input type="radio" name="tab"&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt; &lt;label&gt; &lt;input type="radio" name="tab"&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt; &lt;label&gt; &lt;input type="radio" name="tab"&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; width: 300px; border: 1px solid #000; font: 12px/30px "宋体"; padding: 10px; &#125; p:first-line &#123; background: red; &#125; p:first-letter &#123; font-size: 30px; &#125; p::selection &#123; background: #F60; color: #690; &#125; p::before &#123; content: "BUPT" &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 北京邮电大学（Beijing University of Posts and Telecommunications），简称北邮，是中华人民共和国教育部直属，工业和信息化部共建的一所以信息科技为特色，工学门类为主体，管理学、文学、理学等多个学科门类协调发展的全国重点大学，是北京高科大学联盟成员高校[1] 、国家首批“双一流”世界一流学科建设高校[2] 。系国家“211工程”、“985工程优势学科创新平台”项目重点建设，列入首批“卓越工程师教育培养计划”、“111计划”。被誉为“中国信息科技人才的摇篮”。[3] 前身是1955年成立的新中国第一所邮电高等学府——北京邮电学院。1960年被国务院确定为全国重点高校。 1993年更名为“北京邮电大学”。2000年，划入教育部直属高校行列。2012年，信息与通信工程一级学科全国排名第一。 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; h1:not(.h2)&#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;h1&lt;/h1&gt;&lt;h1 class="h2"&gt;h1&lt;/h1&gt;&lt;h1&gt;h1&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>css3基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>伪类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3结构选择器]]></title>
    <url>%2F2018%2F03%2F10%2Fcss3%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[结构性伪类nth-child() 找到父级下第几个子节点 表示 含义 E:first-child 表示E元素中的第一个子节点 E:last-child 表示E元素的最后一个子节点 E:first-of-type 表示E元素中的第一个子节点且节点类型是E E:last-of-type 表示E元素中的最后一个子节点且节点类型是E的 E:only-child 表示E元素中只有一个子节点。注意：子节点不包含文本节点 E:only-of-type 表示E的父元素中只有一个子节点，且这个唯一的子节点的类型必须是E.注意：子节点不包含文本节点 E：empty 表示E元素中没有子节点。注意：子节点包含文本节点 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; height: 30px; border: 1px solid #000; &#125; p:nth-child(odd) &#123; background: red; &#125; /*p:nth-child(2)找到父级下的第二个子元素，并且这个元素还得是p标签 body:*:nth-child(2)找到body下第二个子节点，不管是什么标签 p:nth-last-child(2) 从后往前数 p:nth-of-type(2) 找到父级下的第二个p类型的标签 p:nth-of-last-type(2) 从后往前找 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;p&gt;p4&lt;/p&gt; &lt;p&gt;p5&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子：新浪新闻导航头部1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .list &#123; margin: 0; padding: 0; list-style: none; &#125; .list li &#123; width: 150px; border: 1px solid #000; float: left; &#125; .list li:last-of-type &#123; border: none; &#125; .list a &#123; float: left; width: 40px; margin: 0 5px; font: 12px/30px "宋体"; text-align: center; &#125; .list li a:nth-of-type(3n+1) &#123; font-weight: bold; &#125; .list li:ntn-child(3) a:nth-child(2) &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="list"&gt; &lt;li&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>css3基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>结构选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3属性选择器]]></title>
    <url>%2F2018%2F03%2F09%2Fcss3%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[transition向前兼容问题 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 100px; height: 100px; background: red; transition: 1s; &#125; .box:hover &#123; width: 200px; height: 200px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 测试得到其他浏览器都没问题，但是ie9和9以下，transition属性就失效了，不兼容。 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 100px; height: 100px; background: red; /*transition: 1s;*/ -webkit-transition:1s;/*兼容老版的chrome，safari*/ -moz-transition:1s; /*兼容老版的火狐*/ -o-transition:1s; /*兼容老版的opera*/ transition: 1s;/*标准的*/ &#125; .box:hover &#123; width: 200px; height: 200px; background: blue; &#125; /* js里面不支持横杠,所以前缀去掉横杠，改成大写 WebKitTransition OTransition MozTransition */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css3属性选择器12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; height: 30px; border: 1px solid #000; &#125; p[xichen] &#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p xichen="leo"&gt;leo&lt;/p&gt; &lt;p xichen="kris"&gt;kris&lt;/p&gt; &lt;p xichen="jasper"&gt;jasper&lt;/p&gt; &lt;p xichen="hades"&gt;hades&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 属性选择器 表示 含义 E[attr] 只使用属性名，但没有确定任何属性值 E[attr=”value”] 指定属性名，并制定了该属性的属性值 E[attr~=”value”] 指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表包含了一个value词，而且等号前面的”~”不能不写 E[attr^=”value”] 指定属性名，并且具有属性值，属性值是以value开头的 E[attr$=”value”] 指定属性名，并且具有属性值，属性值是以value结束的 E[attr*=”value”] 指定属性名，并且具有属性值，而且属性值中包含了value E[attr\ =”value”] 指定属性名，并且具有属性值，而且属性值是以value或者以”value-“开头的值（比如zh-cn） 小例子:仿百度文库分类图标 做出不同的文档类型前面加上不同的图标的效果 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; height: 30px; line-height: 30px; font-size: 12px; border: 1px solid #000; &#125; p a &#123; background: url(img/w.gif) no-repeat 3px center; padding-left: 20px; display: block; &#125; p a[href*=text] &#123; background-image: url(img/text.gif); &#125; p a[href*=pdf] &#123; background-image: url(img/pdf.gif); &#125; p a[href*=excel] &#123; background-image: url(img/excel.gif); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;a href="http://www.baidu.com/doc/javascript.html"&gt;百度文库&lt;/a&gt; &lt;/p&gt; &lt;p&gt; &lt;a href="http://www.baidu.com/pdf/javascript.html"&gt;百度文库&lt;/a&gt; &lt;/p&gt; &lt;p&gt; &lt;a href="http://www.baidu.com/text/javascript.html"&gt;百度文库&lt;/a&gt; &lt;/p&gt; &lt;p&gt; &lt;a href="http://www.baidu.com/excel/javascript.html"&gt;百度文库&lt;/a&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>css3基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>属性选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2018%2F03%2F09%2Fwebpack%2F</url>
    <content type="text"><![CDATA[webpack开发一个项目，业务逻辑非常多，开发会按照功能逻辑拆分成一个一个的模块，这个时候开发会更加地有条理，维护起来也会更加方便，但是这样会涉及到一个问题，模块之间会有着复杂的依赖关系，在处理这些依赖的时候，对于前端开发来说，会遇到一个很棘手的问题：因为代码都是从后端请求过来的，没办法像后端那样同步地引用代码，这个时候就需要模块打包器了。 模块打包器会先分析你的项目依赖，然后会按照一些复杂的规则打包，最后会得到一个新的js文件，这个时候你只需要加载这个js文件就可以了。webpack天生拥有这种模块打包的能力，他不仅拥有js打包的能力，还能帮你打包你所有的资源（css文件、字体、图片），在打包过程中，有各种各样的loader来帮助处理各种而样的内容。还有各种插件来辅助开发和项目构建，从而加快开发效率。频繁使用到CommonJS和ES6语法。]]></content>
      <categories>
        <category>前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax小项目-留言板瀑布流]]></title>
    <url>%2F2018%2F03%2F09%2Fajax%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E7%95%99%E8%A8%80%E6%9D%BF%E7%80%91%E5%B8%83%E6%B5%81%2F</url>
    <content type="text"><![CDATA[瀑布流瀑布流实现原理分析特点：每一列的宽度一样的，分批加载， 分类 特点 固定列 可视区域宽度变化，列数不变 非固定列 可视区域宽度变化，列数变化 固定列的瀑布流布局：在页面放一个ul,定好列数量，三个li，浮动布局，每一列的高度统一都为0，通过ajax异步请求数据，把数据动态地往页面添加，数据是分批请求过来的，每请求一批，把数据动态填充到li里面。为了让高度相差不会太大，把当前数据往三个总高度最短的一列去添加，就可以保证三个li之间的总高度不会相差太远 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload=function()&#123; var oUl=document.getElementById("ul1"); var aLi=oUl.getElementsByTagName('li'); var iLen=aLi.length; //初始化数据处理 ajax('get','getPics.php','cpage=1',function(data))&#123; var data= JSON.parse(data); for (var i = 0; i &lt; data.length; i++) &#123; //获取高度最短的li var _index=getShort(); var oDiv=document.createElement('div'); var oImg=document.createElement('img'); oImg.src=data[i].preview; //oImg.style.width =data[i].width+'px'; oImg.style.width =225px; oImg.style.height =data[i].height+'px'; oDiv.appendChild(oImg); var oP=document.createElement('p'); oDiv.appendChild(oP); oP.innerHTML=data[i]. aLi[_index].appendChild(oDiv); &#125; &#125;); function getShort()&#123; var index=0; var ih=aLi[index].offsetHeight; for(var i=1;i&lt;data.length;i++)&#123; if (aLi[index].offsetHeight) &#123; index=i; ih=aLi[i].offsetHeight; &#125; &#125; return index; &#125; &#125; &lt;/script&gt; &lt;style type="text/css"&gt; body&#123;margin: 0; &#125; #ul1 &#123; width: 1080px; margin: 100px auto 0; &#125; li &#123; width: 247px; list-style: none; float: left; margin-right: 10px; &#125; li div &#123; border: 1px solid #000 ; padding: 10px; margin-bottom: 10px; &#125; li div img &#123; width: 225px; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt; &lt;div&gt; &lt;img src="http://s3.mogucdn.com/mlcdn/c45406/171227_2da0h5dl13dgedj4j8k62la45h5kf_640x960.jpg_240x360.v1cAC.70.webp"&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt; &lt;img src="http://s3.mogucdn.com/mlcdn/c45406/171227_2da0h5dl13dgedj4j8k62la45h5kf_640x960.jpg_240x360.v1cAC.70.webp"&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt; &lt;img src="http://s3.mogucdn.com/mlcdn/c45406/171227_2da0h5dl13dgedj4j8k62la45h5kf_640x960.jpg_240x360.v1cAC.70.webp"&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt; &lt;img src="http://s3.mogucdn.com/mlcdn/c45406/171227_2da0h5dl13dgedj4j8k62la45h5kf_640x960.jpg_240x360.v1cAC.70.webp"&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 流的实现当我们往下拉的时候，动态地再添加一批数据过来，条件是当前最短的一列li，出现在可视区的时候，也就是只要下面有一列没数据了，就可以开始加载下一批数据了。 当li的top值加上自身的高小于滚动条滚动的高加上可视区自身的高的时候，说明当前最短的一列已经进入可视区了。 12 留言本项目]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ajax</tag>
        <tag>前端练习小项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的标准模式与怪异模式]]></title>
    <url>%2F2018%2F03%2F08%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%80%AA%E5%BC%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[标准模式与怪异模式的由来在HTML与CSS的标准化未完成之前，各个浏览器对于HTML和CSS的解析有各自不同的实现，而有很多旧的网页都是按照这些非标准的实现去设计的。在HTML与CSS标准确定之后，浏览器一方面要按照标准去实现对HTML与CSS的支持，另一方面又要保证对非标准的旧网页设计的后向兼容性。因此，现代的浏览器一般都有两种渲染模式：标准模式和怪异模式。在标准模式下，浏览器按照HTML与CSS标准对文档进行解析和渲染；而在怪异模式下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。这样的话，对于旧有的网页，浏览器启动怪异模式，就能够使得旧网页正常显示；对于新的网页，则可以启动标准模式，使得新网页能够使用HTML与CSS的标准特性。 浏览器如何确定使用哪种渲染模式知道了这两种渲染模式的来由，那剩下的问题就是浏览器如何能够确定应该使用哪种模式了。其实归根结底就是，浏览器如何能将旧网页与新网页区分开来。 平常编写网页的时候，一般都会见到HTML文档的头部会有文档类型声明：DOCTYPE。当浏览器遇到正确的文档声明时，浏览器就会启动标准模式，按照制定的文档类型标准解析和渲染文档。而对于旧有的网页，由于网页编写的当时标准还没有确定，所以一般是不会有文档类型声明的。所以，对于没有文档类型声明或者文档类型声明不正确的文档，浏览器就会认为它是一个旧的HTML文档，就会使用怪异模式解析和渲染该文档。关于DOCTYPE的更详细说明，请戳这里 DOCTYPE声明作用及用法详解。 标准模式与怪异模式的区别盒模型的处理差异标准CSS盒模型的宽度和高度等于内容区的高度和宽度，不包含内边距和边框，而IE6之前的浏览器实现的盒模型的宽高计算方式是包含内边距和边框的。因此，对于IE，怪异模式和标准模式下的盒模型宽高计算方式是不一样的； 行内元素的垂直对齐很多早期的浏览器对齐图片至包含它们的盒子的下边框，虽然CSS的规范要求它们被对齐至盒内文本的基线。标准模式下，基于Gecko的浏览器将会对齐至基线，而在quirks模式下它们会对齐至底部。最直接的例子就是图片的显示。在标准模式下，图片并不是与父元素的下边框对齐的，如果仔细观察，你会发现图片与父元素下边框之间存在一点小空隙。那是因为标准模式下，图片是基线对齐的。而怪异模式下，则不存在这个问题。具体请看这篇文章 CSS深入理解vertical-align和line-height的基友关系。 参考文章 CSS深入理解vertical-align和line-height的基友关系 DOCTYPE声明作用及用法详解 怪异模式 作者：tsyeyuanfeng链接：https://www.jianshu.com/p/dcab7cde8c04來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>html</tag>
        <tag>面试</tag>
        <tag>标准模式与怪异模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js之getpos()]]></title>
    <url>%2F2018%2F03%2F08%2Fjs%E4%B9%8Bgetpos%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>DOM</tag>
        <tag>getpos()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工具]]></title>
    <url>%2F2018%2F03%2F08%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[ie浏览器测试工具：IETESTERhttp://www.ietester.cn/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax原理]]></title>
    <url>%2F2018%2F03%2F07%2Fajax%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是ajaxAsynchronous JavaScript and XML(异步JavaScript和XML)。作用1、节省用户操作，时间，提高用户体验，减少数据请求。2、传输获取数据 使用Ajax：使用Ajax获取某一文本文件的内容 ,可以使页面在无刷新的情况下去获取数据。因为网页是单次请求的，如果不再去刷新，请求的话，页面是不会变化的。 Ajax过程详解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; //打开浏览器 /*1、创建一个ajax对象*/ //ie6以下 new ActiveXObject('Microsoft.XMLHTTP') var xhr=null; /* if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest(); &#125;else&#123; xhr= new ActiveXObject('Microsoft.XMLHTTP'); &#125;*/ try&#123; xhr = new XMLHttpRequest(); &#125;catch(e)&#123; xhr= new ActiveXObject('Microsoft.XMLHTTP'); &#125; //在地址栏输入地址 /* open方法 参数 1、打开方式 2、地址 3、是否异步 异步：非阻塞，前面的代码不会影响后面代码的执行 同步：阻塞，前面的代码会影响后面代码的执行 */ xhr.open('get', '1.txt', true);//true代表异步 false代表同步 //提交，发送请求 xhr.send(); //等待服务器返回内容 //readyState:ajax工作状态 //responseText:ajax请求返回的内容就被存放在这个属性下民 //on readystate change :当readyState改变的时候触发 //status:服务器状态，http状态码 xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if(xhr.status==200)&#123; alert(xhr.responseText);&#125; else&#123; alert("出错了"+"err:404"); &#125; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" name="按钮" id="btn" /&gt;&lt;/body&gt;&lt;/html&gt; 表单表单：数据的提交 action 数据提交的地址，默认是当前页面 method 数据提交的方式，分为get和post，默认是get enctype 提交的数据的格式,默认是application/x-www-form-urlencoded get方式：把数据名称和数据对应的数据值用=连接，如果有多个的话，那么他会把多个数据组合用&amp;进行连接，然后把数据放到url?的后面传到指定页面。url长度限制的原因，我们不要通过get方式传递过多的数据 post方式：理论上传递数据长度无限制 数据的获取onreadystatechange事件 readyState属性 请求状态 0 未初始化，还没有调用open()方法 1 载入，已调用send()方法，正在发送请求 2 载入完成，send()方法完成，已收到全部响应内容 3 解析，正在解析相应内容 4 完成，相应内容解析完成，可以在客户端调用了 status属性：服务器请求资源的状态 responeseText 返回以文本形式存放的内容 responseXML 返回XML形式的内容 ajax获取数据的处理和实例JSONchrome,ie7以上都支持，Ie7和Ie7以下不支持。可以去json.org官网下载对应的语言的包，来支持json互转。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="json.js"&gt;&lt;/script&gt; //这里的json.js文件是从json.org官网复制的json2.js库,这样就可以解决ie7及ie7以下不兼容的问题 &lt;script&gt; alert(JSON); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; stringify可以把一个对象转换成一个字符串。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="json.js"&gt;&lt;/script&gt; &lt;script&gt; //alert(JSON); var arr=[1,2,3]; var j=&#123;left:100&#125;; alert(JSON.stringify(arr));//把数组转成字符串 alert(JSON.stringify(j));//把JSON转成字符串 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; parse可以把字符串转换成对应的对象。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="JSON.js"&gt;&lt;/script&gt; &lt;script&gt; var s1='[100,200,300]'; var a1=JSON.parse(s1); //字符串转换成数组 alert(a1[0]); var s2='&#123;"left":100&#125;'; //JSON将作为key的值必须用双引号括起来 var a2=JSON.parse(s2); //字符串转换成JSON alert(a2.left); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 实例：获取并显示新闻数据php后端部分：getNews.php 123456789101112131415&lt;?phpheader('content-type:text/html;charset="utf-8"');error_reporting(0);$news =array( array（'title' =&gt;'很穷但很自豪！实拍朝鲜农村生活现状','data'=&gt;'2015-7-8' ）, array（'title' =&gt;'周冬雨登杂志封面 清新灵动别具一格','data'=&gt;'2015-9-10' ）, array（'title' =&gt;'听说桂林这个壕要过生日，这些大牌都来了','data'=&gt;'2015-9-10' ）, array（'title' =&gt;'妈妈把老公旧衣改成宝宝的新衣','data'=&gt;'2015-9-10' ）, array（'title' =&gt;'事实告诉你 中餐在美到底有多受欢迎!','data'=&gt;'2015-9-10' ）, array（'title' =&gt;'海外体检全知道：去日本体检该办哪种签证？','data'=&gt;'2015-9-10' ）,);echo json_encode($news); 前端部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="JSON.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn'); var xhr = null; oBtn.onclick = function() &#123; try &#123; xhr = new XMLHttpRequest(); &#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHttp'); &#125; xhr.open('get', 'getNews.php', true); xhr.send(); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; // alert(xhr.responseText); var data = JSON.parse(xhr.responseText); //把字符串转换成对应的对象 var oUl = document.getElementById('ul1'); var html = ''; for (var i = 0; i &lt; data.length; i++) &#123; html += '&lt;li&gt;&lt;a href=""&gt;' + data[i].title + '&lt;/a&gt;[&lt;span&gt;' + data[i].date + '&lt;/span&gt;]&lt;/li&gt;'; &#125; oUl.innerHTML = html; &#125; else &#123; alert('出错了，err:' + xhr.status); &#125; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" name="按钮" value="按钮" id="btn" /&gt; &lt;ul id="ul1"&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 应用中get和post的区别处理get方式：缓存问题解决方法：在url?后面连接一个随机数，时间戳。 get方式：中文乱码问题解决方法：编码encodeURI,中文进行编码再传输。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="JSON.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn'); var xhr = null; oBtn.onclick = function() &#123; try &#123; xhr = new XMLHttpRequest(); &#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHttp'); &#125; /*解决缓存问题：在url?后面连接一个随机数，时间戳 2、乱码：编码encodeURI,中文进行编码再传输 */ xhr.open('get', '2.get.php?username=' + encodeURI('李明') + '&amp;age=30&amp;' + new Date().getTime(), true); xhr.send(); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; alert(xhr.responseText); &#125; else &#123; alert('出错了，err:' + xhr.status); &#125; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" name="按钮" value="按钮" id="btn" /&gt; &lt;ul id="ul1"&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; post方式：数据放在send()方法里面作为参数传递，记得要申明发送的数据类型。 注意：post方式没有缓存问题，因为是往服务器提交数据，不产生缓存。post方式，中文也不会乱码，无需编码 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="JSON.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn'); var xhr = null; oBtn.onclick = function() &#123; try &#123; xhr = new XMLHttpRequest(); &#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHttp'); &#125; xhr.open('post', '2.get.php', true); xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded'); //申明发送的数据类型 xhr.send('username=leo&amp;age=30'); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; alert(xhr.responseText); &#125; else &#123; alert('出错了，err:' + xhr.status); &#125; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" name="按钮" value="按钮" id="btn" /&gt; &lt;ul id="ul1"&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 后端部分： 12345678&lt;?phpheader('content-type:text/html;charset="utf-8"');error_reporting(0);$username=$_POST['username'];$age=$_POST['age'];echo "你的名字：&#123;$username&#125;,年龄：&#123;$age&#125;";]]></content>
      <categories>
        <category>前端</category>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax:服务器环境搭建]]></title>
    <url>%2F2018%2F03%2F07%2Fajax-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js中的正则表达式]]></title>
    <url>%2F2018%2F03%2F06%2Fjs%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[字符串indexOf 查找substring 获取子字符串charAt 获取某个字符串split 分割字符串，获得数组 字符串比较字符串可以进行比较，所以可以用来判断字符串是不是数字类型1234567891011&lt;script&gt; //alert( 'a'&lt;'b' ); var str = '5'; if (str &lt;= '9' &amp;&amp; str &gt;= '0') &#123; alert('是数字类型的字符串'); &#125; else &#123; alert('不是数字类型的字符串'); &#125; &lt;/script&gt; 找出字符串中所有的数字123456789101112131415161718192021222324252627282930313233&lt;script&gt; var str = 'haj123sdk54hask33dkhalsd879'; function findNum(str) &#123; var arr = []; var tmp = ''; for (var i = 0; i &lt; str.length; i++) &#123; if (str.charAt(i) &lt;= '9' &amp;&amp; str.charAt(i) &gt;= '0') &#123; tmp += str.charAt(i); &#125; else &#123; if (tmp) &#123; arr.push(tmp); tmp = ''; &#125; &#125; &#125; if (tmp) &#123; arr.push(tmp); tmp = ''; &#125; return arr; &#125; alert(findNum(str)); &lt;/script&gt; 上述功能正则表达式的写法:12345function findNum(str) &#123; return str.match(/\d+/g); &#125; alert(findNum(str)); 什么是正则正则，也叫规则，让计算机能够读懂人类的规则。12var re= //; //大部分用这种 简写的 var re= new RegExp(); 正则中的test方法test:正则去匹配字符串，如果匹配成功就返回真，如果匹配失败就返回假 。test的写法：正则.test(字符串)。 写法 含义 \s 空格 \S 非空格 \d 数字 \D 非数字 \w 字符 \W 非字符 12345678910var str = '374829348791';var re = /\D/;if( re.test(str) )&#123; alert('不全是数字');&#125;else&#123; alert('全是数字');&#125; 正则中的search方法search : 正则去匹配字符串 , 如果匹配成功，就返回匹配成功的位置，如果匹配失败就返回 -1。 search的写法 : 字符串.search(正则)。正则中的默认 : 是区分大小写的 如果不区分大小写的话，在正则的最后加标识 i 。12345678910111213141516171819202122&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var str = 'abcdef'; var re = /B/i; //不区分大小写的简写写法 //var re = new RegExp('B','i'); //全称的写法 alert(str.search(re)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 正则中的match方法match : 正则去匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null。match的写法 : 字符串.match(正则)。正则默认：正则匹配成功就会结束，不会继续匹配;如果想全部查找，就要加标识 g(全局匹配)。量词 : 匹配不确定的位置 +: 至少出现一次,可以看成大于等于1 12345var str = 'haj123sdk54hask33dkhalsd879'; var re = /\d+/g; //如果这里去掉g的话，那么显示结果就是123.第一次匹配成功就会结束 alert(str.match(re)); 正则中的replacereplace : 正则去匹配字符串，匹配成功的字符去替换成新的字符串。replace的写法 : 字符串.replace(正则,新的字符串)。1234567891011121314151617181920&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var str = 'aaa'; var re = /a+/g; //如果把这里改成/a/g 则替换后显示为bbb; 改成/a/，则替换后显示为baa str = str.replace(re, 'b'); alert(str); //显示一个b &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; replace的应用：敏感词过滤1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; //菲称仁爱礁附近17艘中国船均在菲军监视之下 //| : 或的意思 //replace : 第二个参数：可以是字符串，也可以是一个回调函数 window.onload = function() &#123; var aT = document.getElementsByTagName('textarea'); var oInput = document.getElementById('input1'); var re = /菲称|中国船|监视之下/g; oInput.onclick = function() &#123; //aT[1].value = aT[0].value.replace(re,'*'); aT[1].value = aT[0].value.replace(re, function(str) &#123; //函数的第一个参数：就是匹配成功的字符 //alert( str ); var result = ''; for (var i = 0; i &lt; str.length; i++) &#123; result += '*'; &#125; return result; &#125;); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 替换前 &lt;br /&gt; &lt;textarea&gt; &lt;/textarea&gt; &lt;br /&gt; 替换后 &lt;br /&gt; &lt;textarea&gt; &lt;/textarea&gt; &lt;br /&gt; &lt;input type="button" value="确定" id="input1" /&gt;&lt;/body&gt;&lt;/html&gt; 匹配子项（用小括号）匹配子项 : 小括号 () (还有另外一个意思，分组操作)把正则的整体叫做（母亲）, 然后把左边第一个小括号里面的正则，叫做这个第一个子项(母亲的第一个孩子), 第二个小括号就是第二个孩子 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var str = '2015-6-7'; var re = /(\d+)(-)/g; str = str.replace(re, function($0, $1, $2) &#123; //第一个参数：$0（母亲）,第二个参数 : $1(第一个孩子) //,第二个参数 : $1(第二个孩子) //alert( $2 ); //return $1 + '.'; return $0.substring(0, $0.length - 1) + '.';//$0表示正则的整体，这里是截取匹配到的正则的整体减去一个长度的字符，后面再加上. 相当于直接替换掉了- &#125;); alert(str); //2013.6.7 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 也可以用match方法实现1234567&lt;script&gt; var str = 'abc'; var re = /(a)(b)(c)/; alert(str.match(re)); //[abc,a,b,c](当match不加g的时候才可以获取到子项的集合) &lt;/script&gt; 1234567&lt;script&gt; var str = 'abc'; var re = /(a)(b)(c)/g; alert(str.match(re)); &lt;/script&gt; 正则中的字符类字符类 : 一组相似的元素 [] 中括号的整体代表一个字符，[ ]里面代表“或”的关系。 123 var str = 'abdc'; var re = /a[bde]c/;alert( re.test(str) ); //显示false,因为[]中的代表一个整体，第三个字符c与字符串中的d不匹配 字符类中的排除排除：用符号^ 如果^写在[]里面的话，就代表排除的意思。 123var str = 'abc'; var re = /a[^bde]c/;alert( re.test(str) ); //显示false,因为[]中的代表一个整体，正则中第二个字符要排除掉bde,字符串中第二个字符是b，所以错了。如果把字符串中第二个字符b改成除了bde以外的字符，就返回true 字符类的范围用-来表示范围 123var str = 'abc';var re = /a[a-z0-9A-Z]c/;alert(re.test(str)); //显示true，说明匹配上了 字符类应用：过滤标签123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aT = document.getElementsByTagName('textarea'); var oInput = document.getElementById('input1'); //var re = /&lt;\w+&gt;/g; var re = /&lt;[^&gt;]+&gt;/g; oInput.onclick = function() &#123; aT[1].value = aT[0].value.replace(re, ''); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 替换前 &lt;br /&gt; &lt;textarea&gt; &lt;/textarea&gt; &lt;br /&gt; 替换后 &lt;br /&gt; &lt;textarea&gt; &lt;/textarea&gt; &lt;br /&gt; &lt;input type="button" value="确定" id="input1" /&gt;&lt;/body&gt;&lt;/html&gt; 正则中的转义字符 符号 含义 . 任意字符 .前面加一个反斜杠 真正的点 123var str = 'a.c';var re = /a.c/;alert(re.test(str)); //显示true 符号 含义 \b 独立的部分 \B 非独立的部分 123var str = 'onetwo';var re = /one\b/;alert(re.test(str)); //显示false 获取class的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;//alert('\'');window.onload = function() &#123; var aLi = getByClass(document, 'box1'); for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].style.background = 'red'; &#125; /*function getByClass(oParent,sClass)&#123; var arr = []; var aEle = oParent.getElementsByTagName('*'); for(var i=0;i&lt;aEle.length;i++)&#123; if( aEle[i].className == sClass )&#123; arr.push( aEle[i] ); &#125; &#125; return arr; &#125;*/ function getByClass(oParent, sClass) &#123; var arr = []; var aEle = oParent.getElementsByTagName('*'); //var re = /sClass/; //当正则需要传参的时候，一定要用全称的写法 var re = new RegExp('\\b' + sClass + '\\b'); for (var i = 0; i &lt; aEle.length; i++) &#123; if (re.test(aEle[i].className)) &#123; arr.push(aEle[i]); &#125; &#125; return arr; &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li class="box1"&gt;111&lt;/li&gt; &lt;li&gt;111&lt;/li&gt; &lt;li class="box1box2"&gt;111&lt;/li&gt; &lt;li&gt;111&lt;/li&gt; &lt;li class="box1 box2"&gt;111&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 正则中的重复的子项 字符 含义\1 \1 重复的第一个子项 \2 重复的第二个子项 12345var str = 'abca';var re = /(a)(b)(c)\2/;alert( re.test(str) ); //显示false 12var re=/\w\w/; //这两个字符虽然长的一样，但是不一定是同一个字符，匹配ab或者cd也是成功的var re=/(\w)\1/; //这种情况，匹配的两个字符必须一样才可以,因为\1要跟第一个子项完全一样 应用：找重复项最多的字符和个数123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var str = 'assssjdssskssalsssdkjsssdss'; var arr = str.split(''); //分割成数组 str = arr.sort().join(''); //排序，然后再转成字符串 //alert(str); var value = ''; var index = 0; var re = /(\w)\1+/g; str.replace(re, function($0, $1) &#123; //alert($0); if (index &lt; $0.length) &#123; index = $0.length; value = $1; &#125; &#125;); alert('最多的字符:' + value + ',重复的次数:' + index); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 正则中的量词和首尾匹配 表示 含义 {4，7} 最少出现4次，最多出现7次 {4，} 最少出现4次 {4} 正好出现4次 表示 含义 + {1，} 至少出现1次 ？ {0，1} 出现0次或者1次 * {0，} 至少出现0次 1234var str = 'ac';var re = /ab*/;alert(re.test(str)); //显示true 例子1：用正则判断是不是QQ号 表示 含义 ^ 正则的最开始位置，就代表起始的意思 $ 正则的最后位置 , 就代表结束的意思 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload = function()&#123; var aInput = document.getElementsByTagName('input'); var re = /^[1-9]\d&#123;4,11&#125;$/; //起始的位置必须为1-9的一个数字，后面为4到11位的数字，最后要加结束符$ aInput[1].onclick = function()&#123; if( re.test(aInput[0].value) )&#123; alert('是QQ号'); &#125; else&#123; alert('不是QQ号'); &#125; &#125;; &#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" /&gt;&lt;input type="button" value="确定" /&gt;&lt;/body&gt;&lt;/html&gt; 例子2：去掉前后空格123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;var str = ' hello ';alert( '('+trim(str)+')' );function trim(str)&#123; var re = /^\s+|\s+$/g; return str.replace(re,''); &#125;//now777@qq.com//^\w+@[a-z0-9]+(\.[a-z]+)&#123;1,3&#125;$/*var re = &#123; qq : /[1-9][0-9]&#123;4,9&#125;/, email : /^\w+@[a-z0-9]+(\.[a-z]+)&#123;1,3&#125;$/, number : /\d+/&#125;;re.email*/&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>正则</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>字符串</tag>
        <tag>正则</tag>
        <tag>敏感词过滤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数返回值]]></title>
    <url>%2F2018%2F03%2F06%2F%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[函数返回值]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度文库评分和百度音乐全选效果]]></title>
    <url>%2F2018%2F03%2F05%2F%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E8%AF%84%E5%88%86%E5%92%8C%E7%99%BE%E5%BA%A6%E9%9F%B3%E4%B9%90%E5%85%A8%E9%80%89%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[百度文库评分效果 百度音乐全选效果]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>前端练习小项目</tag>
        <tag>运算符</tag>
        <tag>流程控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符流程控制]]></title>
    <url>%2F2018%2F03%2F05%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[运算符 算术运算符：+ 、- 、 、 / 、 %（取模)赋值： = 、+= 、 -= 、 = 、 /= 、 %=关系： &lt; 、 &gt; 、 &lt;= 、 &gt;= 、 == 、 != 、 === 、 !==逻辑：&amp;&amp; 、 || 、 ！运算符优先级： 括号 取余效果：鼠标划过，隔行改变颜色，鼠标离开，恢复原来的灰色。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aLi = document.getElementsByTagName('li'); var arr = ['red', 'yellow', 'blue']; for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index = i; aLi[i].style.background = arr[i % arr.length]; aLi[i].onmouseover = function() &#123; this.style.background = 'gray'; &#125;; aLi[i].onmouseout = function() &#123; this.style.background = arr[this.index % arr.length]; &#125;; &#125; &#125;; &lt;/script&gt; &lt;style&gt; li &#123; height: 24px; margin-bottom: 3px; list-style: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 隔行变色扩展1234567&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 window.onload = function() &#123; var aLi = document.getElementsByTagName('li'); var arr = ['red', 'yellow']; var str = ''; for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index = i; aLi[i].style.background = arr[i % arr.length]; aLi[i].onmouseover = function() &#123; str = this.style.background; // 先存颜色 this.style.background = 'gray'; &#125;; aLi[i].onmouseout = function() &#123; // this.style.background = arr[this.index%arr.length]; this.style.background = str; &#125;; &#125; &#125;; &lt;/script&gt; &lt;style&gt; li &#123; height: 24px; margin-bottom: 3px; list-style: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 京东商城秒转时间1234&lt;script&gt; var s = 3605; // 秒alert(Math.floor(s / 60) + '分' + s % 60 + '秒');&lt;/script&gt; ==与===的区别== 只判断值,而===先判断类型，再判断值。 逻辑运算符注意：！还可以转换数据类型，如果！后面跟的是非零数，则结果为false。以下例子里，alert(120&lt;90 || 20),结果为20 ，因为左边为false,继续往下找，直接把20赋给它。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; // &amp;&amp; 与、|| 或、! 否 alert( 12&lt;90 &amp;&amp; 230&lt;80 ); // false var a = 120 &lt; 90 &amp;&amp; 20; alert( a ); // false alert( 120&lt;90 || 230&lt;80 ); //false var b = 120 &lt; 90 || 20; alert(b); // 20 var c = !!true; alert( c ); //true var d = !200; alert( d ); //false &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 反选小例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aInp = document.getElementsByTagName('input'); // aInp[1].checked = false; // aInp[2].checked = true; aInp[0].onclick = function() &#123; for (var i = 1; i &lt; aInp.length; i++) &#123; aInp[i].checked = !aInp[i].checked; /* if( aInp[i].checked ) &#123; aInp[i].checked = false; &#125; else &#123; aInp[i].checked = true; &#125; */ &#125; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="反选" /&gt; &lt;ul&gt; &lt;li&gt; &lt;input type="checkbox" checked /&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="checkbox" /&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="checkbox" checked /&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="checkbox" /&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="checkbox" /&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 流程控制判断：if 、 switch 、 三目运算？：循环： while、 for跳出：break、continue跳过什么是真：非零的数字、字符串、true、函数、object、[]、{}、元素（存在）什么是假：零、NaN、空字符串、false、null、未定义]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js作用域]]></title>
    <url>%2F2018%2F03%2F04%2Fjs%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[预解析机制 作用域域：空间、范围、区域……作用：读、写script 全局变量、全局函数,自上而下函数 由里到外浏览器：“JS解析器”1）“找一些东西” ：var function 参数a = …所有的变量，在正式运行代码之前，都提前赋了一个值：未定义fn1 = function fn1(){ alert(2); }所有的函数，在正式运行代码之前，都是整个函数块JS 的预解析遇到重名的：只留一个变量和函数重名了，就只留下函数​2）逐行解读代码：表达式：= + - * / % ++ – ! 参数……表达式可以修改预解析的值！ 小例子12345678910111213141516 alert(a); // 输出 function a ()&#123; alert(4); &#125;//因为预解析之后，变量和函数重名了就只留下函数，所以a是整个函数块 function a()&#123;alert(4)&#125;; var a = 1; alert(a); // 输出 1//表达式var a=1;修改了预解析的值 function a ()&#123; alert(2); &#125; alert(a); // 输出 1// 函数不修改值 var a = 3; alert(a); // 输出 3//表达式var a=3;修改了预解析的值 function a ()&#123; alert(4); &#125; alert(a); // 输出 3//函数不修改值 alert( typeof a ); //number // a(); // 报错 js单线程运行12345678&lt;script&gt;alert(a); //报错&lt;/script&gt;&lt;script&gt;var a=1; //1alert(a);&lt;/script&gt; 前一个script区域运行完之后，值会保存。 12345678&lt;script&gt;var a=1; //1alert(a);&lt;/script&gt; &lt;script&gt;alert(a); //1&lt;/script&gt; 函数也是一个局部的域函数调用：预解析+逐行解读代码1)预解析： var function 参数….a=…fn1=function(){ alert(a); var a=2；}2）逐行解读代码：表达式函数调用2.1）预解析： a=… 这里的a是局部变量2.2)逐行解读代码： a=2; 1234567var a = 1; function fn1()&#123; alert(a); // undefined var a = 2; //a=2 &#125; fn1(); alert(a); // 1 下面看看 不加var的影响1)预解析： var function 参数….a=…fn1=function(){ alert(a); a=2；}2）逐行解读代码：表达式函数调用2.1）局部预解析：因为函数里面没有var 所有没有找到，2.2)局部逐行解读代码： a=2; 1234567var a = 1; function fn1()&#123; alert(a); // 1 所以返回父级去找。由里到外（作用域链）找到外面那个a a = 2; //这里修改的是外面的那个a &#125; fn1(); alert(a); // 2 小结：先找东西，后执行。执行过程中遇到表达式就会去修改原来库里面的东西，如果遇到函数调用就开了一个新的作用域，一旦新的作用域开始了，又会重复以上步骤，新的作用域中如果没找到里面有东西，又会返回父级里面去找。 带参数的函数1)预解析： var function 参数….a=…fn1=function(a){ alert(a); a=2；}2）逐行解读代码：表达式函数调用2.1）局部预解析：因为函数里面没有var ,也没有找到函数，所有没有找到。参数本质上就是一个局部变量。找到了参数，但是这个例子里函数调用并没有传进来。参数 a=…未定义2.2)局部逐行解读代码： 局部变量a就是undefined 1234567var a = 1; //全局变量a=1function fn1(a)&#123; alert(a); // undefined a = 2; //这句把a改成2&#125;fn1();alert(a); // 这里读取父级的a=1 函数调用带参数1)预解析： var function 参数….a=…fn1=function(a){ alert(a); a=2；}2）逐行解读代码：表达式函数调用fn1(a)2.1）局部预解析：参数本质上就是一个局部变量，因为这个例子里面传递了参数进来，所以a=undefined。参数 a=…未定义2.2)局部逐行解读代码：因为传递进来的a=1,所以局部变量a=1,再下一步就是局部变量a=2。 全局变量a仍然是1 1234567var a = 1; function fn1(a)&#123; alert(a); // 1 a = 2; &#125; fn1(a); alert(a); // 1 任何函数都可以改全局变量因为函数内部没有这个变量的话，会从里往外找。 123456789101112var num = 0;function fn1()&#123; num++;&#125;function fn2()&#123; num--;&#125;fn2();fn1();fn2();alert(num); 获取函数内的值巧妙利用全局变量来去获取函数内的内容 1234567var str = '';function fn1()&#123; var a = '大鸡腿~'; str = a;&#125;fn1(); alert( str ); //大鸡腿 另一种方法： 123456789function fn2()&#123; var a = '9999999克拉钻石23456789'; fn3(a);&#125;fn2();function fn3(a)&#123; alert(a);&#125; 注意事项if(){}和for(){}、do{}while不是作用域，函数是作用域。firefox不能对下面的函数进行预解析,除了火狐以外，其他的浏览器都可以。 1234567alert( fn1 ); // FF 不能对下面的函数进行预解析if( true )&#123; var a = 1; function fn1()&#123; alert(123);&#125;&#125; 解决这个兼容性问题的方法是：以后尽量不要在if语句里面定义函数，全局变量。改成下面这种写法： for里面包了一个函数，在函数里面不要直接使用i下例会出现undefined的原因是：点击事件函数是一个作用域，只要有作用域，就会有域解析，点击事件函数里面域解析的时候会找到var i=undefined,所以这里alert(i)是undefined。但是如果把for循环里面的var去掉的话，那么点击事件函数里面就没有变量，所以i就会到父级里面去找，父级i是3,所以此时alert(i)会弹出3。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].onclick = function() &#123; alert( i ); for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].style.background = 'yellow'; &#125; &#125;; &#125; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button" value="按钮1" /&gt; &lt;input type="button" value="按钮2" /&gt; &lt;input type="button" value="按钮3" /&gt; &lt;/body&gt; &lt;/html&gt; 但是如果把js代码改成以下就会出错 12345678910111213&lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].onclick = function() &#123; alert( i ); // 3 aBtn[i].style.background = 'yellow'; &#125;; &#125; &#125;; &lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>作用域</tag>
        <tag>预解析</tag>
        <tag>易错点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数传参项目]]></title>
    <url>%2F2018%2F03%2F04%2F%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[搜狐视频纪录片列表展示 修改文本框的值 选择卡里套选择卡]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>前端练习小项目</tag>
        <tag>函数传参</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绝对定位与相对定位]]></title>
    <url>%2F2018%2F03%2F04%2F%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E4%B8%8E%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[通常情况下，元素的position属性的值默认为static，也就是没有定位，元素出现再正常的文档流中，这个时候如果给元素设置left、right、bottom、top这些偏移属性，都不会生效，z-index也不会生效。 相对定位relative注意：使用相对定位时，就算元素被偏移了，但是它仍然会占据着没偏移之前的空间。 上图，第二个块针对本身的位置发生了一个偏移，但是它原来所占据的那个位置空间仍然还在，即使它完全离开原来的位置，但是它原来位于文档流中的位置仍然会存在，不会被第三个浮动过来填补掉；同时它的偏移也不会把别的块从文档流中原来的位置挤开，如果有重叠的地方它会重叠再其他文档流元素之上，可以通关过设置z-index属性来调整他的堆叠顺序。 绝对定位absolute被设置了绝对定位的元素，在文档流中是不占据空间的，如果某元素设置了绝对定位，那么它在文档流中的位置会被删除，其实这个元素是浮了起来，它与relative的不同点在于：相对定位不会删除它本身在文档流中占据的那块空间，而绝对定位则会删除该元素在文档流中的位置，完全从文档流中抽出来。 绝对定位是如何定位的？ 一、如果它的父级元素设置了除static之外的定位，比如position：relative 或者position：absolute或者position：fixed,那么它就会相对于它的父级元素来定位，位置通过left、top、right、bottom（刚好一个顺时针）属性来规定。 二、如果它的父级元素没有设置定位，那么就得看它父元素得父元素有没有设置定位，如果还是没有，就继续向更高层得祖先元素类推。 小结：总之它的定位就是相对于设置了除static定位之外得定位得第一个祖先元素，如果以上情况都不存在，那么他就会相对于文档body来定位（并非窗口，相对于窗口来定位得是fixed）绝对定位得元素相对于谁来定位，我们就把这个“谁”叫做参照物。 下面是使用了绝对定位得效果： 注意：在设置偏移量得时候，可以设置负值。]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>相对定位绝对定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数传参]]></title>
    <url>%2F2018%2F03%2F04%2F%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[函数传参 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; /* 函数传递参数 参数=JS的数据类型： 数字、字符串、布尔、函数、对象、未定义 */ fn1(100, 'px'); function fn1(a, b) &#123; // alert( a+b ); &#125; fn2('miaov'); fn2('妙味课堂'); function fn2(a) &#123; // alert(a.charAt(2)); &#125; //传递一个有名字的函数，不用带括号 function fn4() &#123; alert(4); &#125; 1234567891011121314151617181920212223 fn3(fn4); fn3(function(a) &#123; alert(a); &#125;); function fn3(fn) &#123; fn(100); fn(); &#125; //传递对象 fn5(window, document); function fn5(w, d) &#123; w.onload = function() &#123; d.body.innerHTML = 123; &#125;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 代码重用1、尽量保证 HTML 代码结构一致，可以通过父级选取子元素2、把核心主程序实现，用函数包起来3、把每组里不同的值找出来，通过传参实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; ul &#123; padding: 0; margin: 0; &#125; li &#123; list-style: none; &#125; body &#123; background: #333; &#125; .box &#123; width: 400px; height: 500px; position: relative; background: url(img/loader_ico.gif) no-repeat center #fff; float: left; margin-right: 60px; &#125; .box img &#123; width: 400px; height: 500px; &#125; .box ul &#123; width: 40px; position: absolute; top: 0; right: -50px; &#125; .box li &#123; width: 40px; height: 40px; margin-bottom: 4px; background: #666; &#125; .box .active &#123; background: #FC3; &#125; .box span &#123; top: 0; &#125; .box p &#123; bottom: 0; margin: 0; &#125; .box p, .box span &#123; position: absolute; left: 0; width: 400px; height: 30px; line-height: 30px; text-align: center; color: #fff; background: #000; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; fnTab('pic1', ['img/1.png', 'img/2.png', 'img/3.png', 'img/4.png'], ['小宠物', '图片二', '图片三', '面具'], 'onclick'); fnTab('pic2', ['img/2.png', 'img/3.png', 'img/4.png'], ['图片二', '图片三', '面具'], 'onmouseover'); &#125;; function fnTab(id, arrUrl, arrText, evt) &#123; var oDiv = document.getElementById(id); var oImg = oDiv.getElementsByTagName('img')[0]; var oSpan = oDiv.getElementsByTagName('span')[0]; var oP = oDiv.getElementsByTagName('p')[0]; var oUl = oDiv.getElementsByTagName('ul')[0]; var aLi = oUl.getElementsByTagName('li'); var num = 0; for (var i = 0; i &lt; arrUrl.length; i++) &#123; oUl.innerHTML += '&lt;li&gt;&lt;/li&gt;'; &#125; // 初始化 function fnTab() &#123; oImg.src = arrUrl[num]; oSpan.innerHTML = 1 + num + ' / ' + arrUrl.length; oP.innerHTML = arrText[num]; for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].className = ''; &#125; aLi[num].className = 'active'; &#125; fnTab(); for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index = i; // 索引值 aLi[i][evt] = function() &#123; num = this.index; fnTab(); &#125;; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="pic1" class="box"&gt; &lt;img src="" /&gt; &lt;span&gt;数量正在加载中……&lt;/span&gt; &lt;p&gt;文字说明正在加载中……&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div id="pic2" class="box"&gt; &lt;img src="" /&gt; &lt;span&gt;数量正在加载中……&lt;/span&gt; &lt;p&gt;文字说明正在加载中……&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 应用：仿淘宝购物车计算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oUl = document.getElementById('list'); var aLi = oUl.getElementsByTagName('li'); for (var i = 0; i &lt; aLi.length; i++) &#123; fn1(aLi[i]); &#125; function fn1(oLi) &#123; var aBtn = oLi.getElementsByTagName('input'); var oStrong = oLi.getElementsByTagName('strong')[0]; var oEm = oLi.getElementsByTagName('em')[0]; var oSpan = oLi.getElementsByTagName('span')[0]; var n1 = Number(oStrong.innerHTML); //动态获取 '0' =&gt; 0 var n2 = parseFloat(oEm.innerHTML); //动态获取 '12.5元' =&gt; 12.5 aBtn[0].onclick = function() &#123; n1--; if (n1 &lt; 0) &#123; n1 = 0; &#125; oStrong.innerHTML = n1; oSpan.innerHTML = n1 * n2 + '元'; &#125;; aBtn[1].onclick = function() &#123; n1++; oStrong.innerHTML = n1; oSpan.innerHTML = n1 * n2 + '元'; &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="list"&gt; &lt;li&gt; &lt;input type="button" value="-" /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type="button" value="+" /&gt; 单价： &lt;em&gt;12.5元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="button" value="-" /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type="button" value="+" /&gt; 单价： &lt;em&gt;10.5元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="button" value="-" /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type="button" value="+" /&gt; 单价： &lt;em&gt;8.5元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="button" value="-" /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type="button" value="+" /&gt; 单价： &lt;em&gt;8元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="button" value="-" /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type="button" value="+" /&gt; 单价： &lt;em&gt;14.5元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt; 商品合计共：0件，共花费了：0元 &lt;br /&gt; 其中最贵的商品单价是：0元 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>前端练习小项目</tag>
        <tag>函数传参</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型转换练习]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[找到合适的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; body &#123; font-size: 20px; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var arr = ['100px', 'abc' - 6, [], -98765, 34, -2, 0, '300', , function() &#123; alert(1); &#125;, null, document, [], true, '200px' - 30, '23.45元', 5, Number('abc'), function() &#123; alert(3); &#125;, 'xyz' - 90]; var ob = document.getElementsByTagName('body')[0]; var a1 = []; var a2 = []; var a3 = []; var a4 = []; var max = 0; /* 1、找到arr里所有的数字：-98765, 34, -2, 0, 5 2、找到可以转成数字的：'100px', -98765, 34, -2, 0, '300', '23.45元', 5 3、把转成数字以后，最大值判断出来：300 4、把 NaN 所在的位置找出来：1 14 17 19 */ //题目一：用函数把数字选择出来，由于NaN在数字类型，所以用ISNaN把NAN去除掉 ob.innerHTML += '&lt;br/&gt;' + '1、找到arr里所有的数字: ' for (var i = 0; i &lt; arr.length; i++) &#123; if (typeof arr[i] == 'number' &amp;&amp; !isNaN(arr[i])) &#123; a1.push(arr[i]); &#125; &#125; for (var i = 0; i &lt; a1.length; i++) &#123; ob.innerHTML += a1[i] + ' ,'; &#125; //题目二：用函数把可以数字转换的找出来，再单独找0,要把中括号去除呢 ob.innerHTML += '&lt;br/&gt;' + '2、找到可以转成数字的: ' for (var i = 0; i &lt; arr.length; i++) &#123; if (parseFloat(arr[i]) || (arr[i] == 0 &amp;&amp; typeof arr[i] == 'number')) &#123; a2.push(arr[i]); &#125; &#125; for (var i = 0; i &lt; a2.length; i++) &#123; ob.innerHTML += a2[i] + ' ,'; &#125; //题目三：用函数把可以数字转换出来，再单独找0输入 for (var i = 0; i &lt; a2.length; i++) &#123; if (parseFloat(a2[i]) || a2[i] == 0) &#123; a3.push(parseFloat(a2[i])); &#125; &#125; ob.innerHTML += '&lt;br/&gt;' + '3、把转换数字后的数组为: ' for (var i = 0; i &lt; a3.length; i++) &#123; if (max &lt; a3[i]) &#123; max = a3[i]; &#125; ob.innerHTML += a3[i] + ' ,'; &#125; ob.innerHTML += ' 排序后最大值：' + max; //题目四：把 NaN 所在的位置找出来：1 14 17 19 ob.innerHTML += '&lt;br/&gt;' + '4、把 NaN 所在的位置找出来: ' for (var i = 0; i &lt; arr.length; i++) &#123; if (isNaN(arr[i]) &amp;&amp; typeof arr[i] == 'number') &#123; a4.push(i); &#125; &#125; for (var i = 0; i &lt; a4.length; i++) &#123; ob.innerHTML += a4[i] + ' ,'; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; QQ号码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;script&gt;window.onload = function() &#123; var oText = document.getElementById('t') var oBtn = document.getElementById('b') var count = 0; oBtn.onclick = function() &#123; if (oText.value == '') &#123; alert('没有输入') count++; &#125; if (isNaN(oText.value)) &#123; alert('非数字') count++; &#125; if (oText.value.charAt(0) == 0) &#123; alert('不能有0在前面') count++; &#125; if (parseFloat(oText.value) != parseInt(oText.value)) &#123; alert('不能是小数') count++; &#125; if (oText.value.length &lt; 5 || oText.value.length &gt; 10) &#123; alert('输入的数字必须在5位以上、10位以内') count++; &#125; if (count == 0) &#123; alert('输入的号码正确呢') &#125; &#125; &#125; &lt;/script&gt; &lt;body&gt; 请输入QQ号码： &lt;input type="text" value="" id="t" /&gt; &lt;input type="button" value="判断" id="b" /&gt; &lt;br /&gt; 1、有没有输入 &lt;br /&gt; 2、输入的是不是数字 &lt;br /&gt; 3、不能有0在前面 &lt;br /&gt; 4、不能是小数 &lt;br /&gt; 5、输入的数字必须在5位以上、10位以内 &lt;br /&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>前端练习小项目</tag>
        <tag>数据类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链简介]]></title>
    <url>%2F2018%2F03%2F02%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js数据类型、类型转换]]></title>
    <url>%2F2018%2F03%2F02%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[js数据类型以及相关操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;/*ECMAScript：标准、核心HTML 标签类型：block、inline、inline-block、table……JS中的数据类型：数字、字符串、布尔、函数、对象(obj、[]、&#123;&#125;、null)、未定义typeof 判断数据类型*/var i = 100;// alert( typeof i ); // numbervar s = ' miaov ';// alert( typeof s ); // string// alert( s.length ); // 7// alert( s.charAt(3) ); // 'a'var b = true; // 布尔值：true false// alert( typeof b ); // booleanif ( true ) &#123;&#125;for ( ; false ; ) &#123; &#125;var fn = function ()&#123; alert(1); &#125;;// fn();function fn1()&#123; alert(2);&#125;// alert( fn1 );// fn1();var obj = document;// alert( typeof obj ); // object 物体、东西、对象obj.abc = 123;obj.onOff = true;obj.fn1 = function ()&#123; alert(1); &#125;;// alert( document.onOff ); // 123// obj.fn1();var arr = [ 1,2,3,4 ];// alert( arr.length );// arr[2] = 345;// alert( arr );// arr.push( 5,6,7 );// alert( arr );// alert( typeof arr ); // objectarr.abc = 999;arr.fn1 = function ()&#123; alert('ok'); &#125;;// alert( arr.abc );// arr.fn1();var json = &#123; name:'miaov', age:5 &#125;;// alert( json.name + '今年' + json.age + '岁了' );// alert( typeof json );//objectvar n = null;// alert( typeof n );//空的东西不能添加属性var u;// alert( typeof u ); // undefined 未定义// 表示你写的程序出问题了~~&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 数据类型转换(显式类型转换)字符串变成数字123456789101112131415161718192021222324252627282930313233343536373839 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var a = '+100'; // alert( a+100 ); // '100100' // alert( Number(a) ); // 100 var a1 = ' '; // alert( Number(a1) ); // 0 var a2 = true; // alert( Number(a2) ); // true-1 false-0 var a3=[]; alert(Number(a3)); //0 var a3=['']; alert(Number(a3)); //0 var a3 = [ 1 ]; // alert( Number(a3) ); // 1 var a4 = null; // alert( Number(a4) ); // 0 var a3=function()&#123;alert(1);&#125;; alert(Number(a3)); //NaN //////////////////////////////////////////////////////////////////////////// var json = &#123;&#125;; // alert( Number(json) ); //NaN var u; // alert( Number(u) ); //NaN var a3 = function ()&#123; alert(1); &#125;; // alert( Number(a3) ); // NaN &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; parseInt与parseFloat的区别与小技巧1234567891011121314151617 var b = ' 200px'; alert( parseInt(b) ); //200 默认十进制 var b = ' 200px'; alert( parseInt(b，16进制) ); //200 十六进制var b = ' 200px1234567'; alert( parseInt(b) ); //200 var c = '12.34元';// alert( parseInt(c) ); //12var c = '12.34元';// alert( parseFloat(c) ); //12.34var c = '12.3.4元';// alert( parseFloat(c) ); //12.3 验证是整数还是小数​123456var num = '200.45'; if( parseInt(num) == parseFloat(num) )&#123; alert( num + '是整数' );&#125;else&#123; alert( num + '是小数' );&#125; js中稀奇古怪的隐式类型转换1234567891011121314151617181920212223242526&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; /* 显式类型转换（强制类型转换）： Number() parseInt() parseFloat() 隐式类型转换： + 200 + '3' 变成字符串 - * / % '200' - 3 变成数字 ++ -- 变成数字 &gt; &lt; 数字的比较 、字符串的比较 ! 取反 把右边的数据类型转成布尔值 == */ // alert( Number('……') ); NaN // alert( '……'-9 ); NaN // alert( '2' == 2 ); 123456789101112131415//字符串的比较 // alert( '10000000' &gt; '9' );//false 一位一位地比较 // 数字的比较与字符串的比较 // '1000000' '9' // alert( '2' == 2 ); //true 判断值，所以两个等号可以转换 alert('2'===2); //三个等号更严谨，先去判断类型，再去判断值 alert(!'ok'); //false &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; NaN1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; // JS中的数据类型：数字（NaN）、字符串、布尔、函数、对象(obj、[]、&#123;&#125;、null)、未定义 var a = Number('abc'); // alert( a ); // NaN // NaN：not a number 不是个 数字 的 数字类型 // alert( typeof (a) ); // number // 一旦写程序中出现：NaN 肯定进行了非法的运算操作 // alert( '200px' - 100 ); // NaN 是 false if (a) &#123; alert( '真' ); &#125; else &#123; alert( '假' ); &#125; var abc = []; // alert( abc === abc ); true // NaN 与自己都不相等！！除了NaN以外，其他的数据类型都是自己和自己相等的 alert(a === a); // false isNaN();//判断某些值是不是数字类型 不是数字true 是数字 false //在内部是根据Number来进行转换，转换之后进行判断 alert(isNaN('250'));//'250'--250--false alert(isNaN(true));//true--1--false alert(isNaN([]));//[]--0--false &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; isNaN()小应用12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aInp = document.getElementsByTagName('input'); var str = ''; aInp[1].onclick = function() &#123; str = aInp[0].value; // HTML 中拿到的内容，类型都是字符串 // alert( typeof str ); if (isNaN(str)) &#123; alert(str + '不是数字'); &#125; else &#123; alert(str + '是数字'); &#125; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" /&gt; &lt;input type="button" value="判断输入值是不是数字" /&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单实现QQ好友列表]]></title>
    <url>%2F2018%2F03%2F02%2F%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0QQ%E5%A5%BD%E5%8F%8B%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[简单实现QQ好友列表需求：实现折叠与展开，实现点击高亮显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; ul, h2 &#123; /*样式重置*/ padding: 0; margin: 0; &#125; li &#123;/* 去掉列表前面的点*/ list-style: none; &#125; #list &#123; width: 240px; border: 1px solid #333; margin: 0 auto; &#125; #list .lis &#123;&#125; #list h2 &#123; height: 30px; line-height: 30px; text-indent: 20px; background: url(img/ico1.gif) no-repeat 5px center #6FF; color: #000; &#125; #list .active &#123; background: url(img/ico2.gif) no-repeat 5px center #FF9; color: #000; &#125; #list ul &#123; display: none; &#125; #list ul li &#123; line-height: 24px; border-bottom: 1px solid #333; text-indent: 24px; &#125; #list ul .hover &#123; background: #6FF; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oUl = document.getElementById('list'); var aH2 = oUl.getElementsByTagName('h2'); var aUl = oUl.getElementsByTagName('ul'); var aLi = null; var arrLi = []; for (var i = 0; i &lt; aH2.length; i++) &#123; aH2[i].index = i; aH2[i].onclick = function() &#123; for (var i = 0; i &lt; aH2.length; i++) &#123; if (i != this.index) &#123; aUl[i].style.display = 'none'; aH2[i].className = ''; &#125; &#125; if (this.className == '') &#123; /*这里两个等号或者三个等号都可以*/ aUl[this.index].style.display = 'block'; this.className = 'active'; &#125; else &#123; aUl[this.index].style.display = 'none'; this.className = ''; &#125; &#125;; &#125; for (var i = 0; i &lt; aUl.length; i++) &#123; aLi = aUl[i].getElementsByTagName('li'); for (var j = 0; j &lt; aLi.length; j++) &#123; arrLi.push(aLi[j]); &#125; &#125; for (var i = 0; i &lt; arrLi.length; i++) &#123; arrLi[i].onclick = function() &#123; for (var i = 0; i &lt; arrLi.length; i++) &#123; if (arrLi[i] != this) &#123; arrLi[i].className = ''; &#125; &#125; if (this.className == '') &#123; this.className = 'hover'; &#125; else &#123; this.className = ''; &#125; &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="list"&gt; &lt;li class="lis"&gt; &lt;h2&gt;我的好友&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li&gt;张三&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class="lis"&gt; &lt;h2&gt;企业好友&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class="lis"&gt; &lt;h2&gt;黑名单&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;张小三&lt;/li&gt; &lt;li&gt;李小四&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>前端练习小项目</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义属性]]></title>
    <url>%2F2018%2F03%2F02%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[什么是自定义属性通俗地讲，就是js往html上添加东西。js可以为任何html元素添加任意个自定义属性。例如下面程序的abc、xyz就是自定义属性 123456789101112131415161718192021222324252627&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].abc = 123; aBtn[i].xyz = true; &#125; alert(aBtn[0].abc); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="按钮1" /&gt; &lt;input type="button" value="按钮2" /&gt; &lt;input type="button" value="按钮3" /&gt;&lt;/body&gt;&lt;/html&gt; 应用1:自定义一组开关应用注意不能当作判断条件的有1、背景不能判断 2、color不能判断 3、相对路径不能当作判断条件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; li &#123; list-style: none; width: 114px; height: 140px; background: url(img/normal.png); float: left; margin-right: 20px; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var aLi = document.getElementsByTagName('li'); // var onOff = true; // 只能控制一组！ for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].onOff = true;//给每个要控制的元素都添加一个开关 aLi[i].onclick = function() &#123; // alert( this.style.background ); if (this.onOff) &#123; this.style.background = 'url(img/active.png)'; this.onOff = false; &#125; else &#123; this.style.background = 'url(img/normal.png)'; this.onOff = true; &#125; &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 应用2：获取自身递增数字及匹配数组内容相当于一个按钮就可以 控制一组东西的变化 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); var arr = ['A', 'B', 'C', 'D']; for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].num = 0; aBtn[i].onclick = function() &#123; // alert( arr[ this.num ] ); this.value = arr[this.num]; this.num++; if (this.num === arr.length) &#123; this.num = 0; &#125; &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="0" /&gt; &lt;input type="button" value="0" /&gt; &lt;input type="button" value="0" /&gt;&lt;/body&gt;&lt;/html&gt; 应用3：添加索引值、匹配数组1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; // 自定义属性（索引值） aBtn[i].onclick = function() &#123; // alert( i ); alert(this.index); //添加索引值，自定义索引值 &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="btn1" /&gt; &lt;input type="button" value="btn2" /&gt; &lt;input type="button" value="btn3" /&gt;&lt;/body&gt;&lt;/html&gt; 索引的引用想建立“匹配”“对应”关系，就用索引值 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); var arr = ['莫涛', '张森', '杜鹏']; for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; // 自定义属性（索引值） aBtn[i].onclick = function() &#123; // alert( arr[ this.index ] ); this.value = arr[this.index]; &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="btn1" /&gt; &lt;input type="button" value="btn2" /&gt; &lt;input type="button" value="btn3" /&gt;&lt;/body&gt;&lt;/html&gt; 通过索引将按钮和P匹配1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); var aP = document.getElementsByTagName('p'); var arr = ['马云', '马化腾', '李彦宏']; for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; // 自定义属性（索引值） aBtn[i].onclick = function() &#123; // alert( arr[ this.index ] ); this.value = arr[this.index]; aP[this.index].innerHTML = arr[this.index]; &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="btn1" /&gt; &lt;input type="button" value="btn2" /&gt; &lt;input type="button" value="btn3" /&gt; &lt;p&gt;a&lt;/p&gt; &lt;p&gt;b&lt;/p&gt; &lt;p&gt;c&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; hexo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; ul &#123; padding: 0; margin: 0; &#125;/*样式的重置*/ li &#123; list-style: none; &#125; body &#123; background: #333; &#125; #pic &#123; width: 400px; height: 500px; position: relative; margin: 0 auto; background: url(img/loader_ico.gif) no-repeat center #fff; &#125; #pic img &#123; width: 400px; height: 500px; &#125; #pic ul &#123; width: 40px; position: absolute; top: 0; right: -50px; &#125; #pic li &#123; width: 40px; height: 40px; margin-bottom: 4px; background: #666; &#125; #pic .active &#123; background: #FC3; &#125; #pic span &#123; top: 0; &#125; #pic p &#123; bottom: 0; margin: 0; &#125; #pic p, #pic span &#123; position: absolute; left: 0; width: 400px; height: 30px; line-height: 30px; text-align: center; color: #fff; background: #000; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oDiv = document.getElementById('pic'); var oImg = oDiv.getElementsByTagName('img')[0]; var oSpan = oDiv.getElementsByTagName('span')[0]; var oP = oDiv.getElementsByTagName('p')[0]; var oUl = oDiv.getElementsByTagName('ul')[0]; var aLi = oUl.getElementsByTagName('li'); var arrUrl = ['img/1.png', 'img/2.png', 'img/3.png', 'img/4.png']; var arrText = ['小宠物', '图片二', '图片三', '面具']; var num = 0; var oldLi = null; for (var i = 0; i &lt; arrUrl.length; i++) &#123; oUl.innerHTML += '&lt;li&gt;&lt;/li&gt;'; &#125; oldLi = aLi[num]; // 初始化 oImg.src = arrUrl[num]; oSpan.innerHTML = 1 + num + ' / ' + arrUrl.length; oP.innerHTML = arrText[num]; aLi[num].className = 'active'; for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index = i; // 索引值 aLi[i].onclick = function() &#123; oImg.src = arrUrl[this.index]; oP.innerHTML = arrText[this.index]; oSpan.innerHTML = 1 + this.index + ' / ' + arrText.length; /* &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; */ // 思路一：全部清空，当前添加 for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].className = ''; &#125; this.className = 'active'; /* // 思路二：清空上个，当前添加 oldLi.className = ''; oldLi = this; this.className = 'active'; */ &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="pic"&gt; &lt;img src="" /&gt; &lt;span&gt;数量正在加载中……&lt;/span&gt; &lt;p&gt;文字说明正在加载中……&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>自定义属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑客入门电子书整理]]></title>
    <url>%2F2018%2F03%2F01%2F%E9%BB%91%E5%AE%A2%E5%85%A5%E9%97%A8%E7%94%B5%E5%AD%90%E4%B9%A6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[黑客攻防电子书整理 链接: https://pan.baidu.com/s/1sm2fjZ3 密码: dvt3]]></content>
      <categories>
        <category>books</category>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>hacker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this指向及this应用]]></title>
    <url>%2F2018%2F02%2F28%2Fthis%E6%8C%87%E5%90%91%E5%8F%8Athis%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[thisthis可以理解为调用当前方法或者函数的那个对象，通俗地说就是谁调用了函数指的就是谁。例如下面程序的this指的是一个按钮。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; // this : 这个 // this： 指的是调用 当前 方法（函数）的那个对象 function fn1() &#123; // this &#125; // fn1(); this =&gt; window // oDiv.onclick = fn1; this =&gt; oDiv /* oDiv.onclick = function ()&#123; fn1(); fn1() 里的this =&gt; window &#125;; &lt;div onclick=" this fn1(); "&gt;&lt;/div&gt; fn1(); 里的 this 指的是 window */ // alert( this ); // object window // window 是 JS “老大” // window.alert( this ); function fn1() &#123; alert(this); // window &#125; // fn1(); // window.fn1(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btn1" type="button" value="按钮" /&gt; &lt;input id="btn2" type="button" onclick=" fn1(); " value="按钮2" /&gt; &lt;script&gt; var oBtn = document.getElementById('btn1'); // oBtn.onclick = fn1; oBtn.onclick = function() &#123; // this fn1(); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ​]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for循环遍历二维数组、嵌套元素]]></title>
    <url>%2F2018%2F02%2F28%2Ffor%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E3%80%81%E5%B5%8C%E5%A5%97%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[二维数组即数组里面的数组，例如常见的好友列表就是这种结构。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var arr = [ [1, 2, 3, 4, '4+'], [4, 5, 6], [7, 8, 9] ]; // arr[1][2] for (var i = 0; i &lt; arr.length; i++) &#123; // arr[i][0] // arr[i][1] // arr[i][2] for (var j = 0; j &lt; arr[i].length; j++) &#123; // alert( arr[i][j] ); &#125; &#125; // for( var i=0; )&#123;&#125; // for( var i=0; )&#123;&#125; window.onload = function() &#123; var oUl = document.getElementById('list'); var aUl = oUl.getElementsByTagName('ul'); var len = aUl.length; var aLi = null; // 空 for (var i = 0; i &lt; len; i++) &#123; aLi = aUl[i].getElementsByTagName('li'); for (var j = 0; j &lt; aLi.length; j++) &#123; aLi[j].style.border = '1px solid red'; &#125; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="list"&gt; &lt;li&gt; &lt;h2&gt;我的好友&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;莫涛&lt;/li&gt; &lt;li&gt;张森&lt;/li&gt; &lt;li&gt;杜鹏&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;ol&gt; &lt;li&gt;no&lt;/li&gt; &lt;li&gt;no&lt;/li&gt; &lt;li&gt;no&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;我的白名单&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;莫小涛&lt;/li&gt; &lt;li&gt;张小森&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;ol&gt; &lt;li&gt;no&lt;/li&gt; &lt;li&gt;no&lt;/li&gt; &lt;li&gt;no&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;我的黑名单&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;莫张&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; cssText在下例中，cssText只是针对div的行间样式做修改，并没有动style里面的样式。后面的cssText会替换掉前面的cssText。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; border: 1px solid #333; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt;123&lt;/div&gt; &lt;input id="btn1" type="button" value="按钮" /&gt; &lt;script&gt; var oDiv = document.getElementById('div1'); var oBtn = document.getElementById('btn1'); oDiv.onclick = function() &#123; // oDiv.style.width = '200px'; oDiv.style.cssText = ' width:200px;height:200px;'; &#125;; oBtn.onclick = function() &#123; // oDiv.style.width = '100px'; oDiv.style.cssText = ''; //这里的cssText会替换掉上面的cssText，类似于innerHTML &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 例子：自动上生成一组新闻1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oUl = document.getElementById('list'); var arr = [ '山西省委附近多次爆炸 官方称尚不确定是恐怖袭击', '甘肃张掖明令禁止转基因 书记:无力辨别只能禁止', '多地制定雾霾预案限行限排被批治标不治本', '韩媒抱怨中国雾霾侵袭韩国 称其为"黑色灾难" ', '伊朗革命卫队高官在叙利亚当"志愿者"被杀(图)' ]; var onOff = true; oBtn.onclick = function() &#123; // oBtn.disabled = true; // oBtn.style.display = 'none'; //思路1、按钮找麻烦 // oUl.innerHTML = ''; //思路2、先清空，再生成，不过影响性能 // onOff = false; no!!!! if (onOff) &#123; //思路3、另设一个变量，做判断 // onOff = false; ok for (var i = 0; i &lt; arr.length; i++) &#123; oUl.innerHTML += '&lt;li&gt;' + arr[i] + '&lt;/li&gt;'; &#125; // onOff = false; ok &#125; onOff = false; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btn1" type="button" value="自动生成5条新闻" /&gt; &lt;ul id="list" style="border:1px solid red;"&gt;&lt;/ul&gt; &lt;script&gt; alert(document.getElementById('list').style.border); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for应用（逢十、V字）]]></title>
    <url>%2F2018%2F02%2F28%2Ffor%E5%BA%94%E7%94%A8%EF%BC%88%E9%80%A2%E5%8D%81%E3%80%81V%E5%AD%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[逢十往下一行用js生成100个div，每行十个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; div &#123; width: 50px; height: 50px; background: red; position: absolute; top: 0; left: 0; font-size: 30px; text-align: center; line-height: 50px; color: #fff; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var aDiv = document.getElementsByTagName('div'); for (var i = 0; i &lt; 100; i++) &#123; document.body.innerHTML += '&lt;div&gt;' + i + '&lt;/div&gt;'; &#125; for (var i = 0; i &lt; aDiv.length; i++) &#123; var m = i % 10; var n = parseInt(i / 10); aDiv[i].style.left = m * 50 + 'px'; aDiv[i].style.top = 10 + n * 50 + 'px'; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 小拓展：可以用这种方法来写一个元素周期表的效果小结：求余数 1document.write(1%4); //结果为1 求商 1console.info(1/4);//结果为0.25 求商，取整 1console.info(parseInt(1/4));//结果为0 天花板取整 1console.info(Math.ceil(1/4));//结果为1 地板取整 1console.info(Math.floor(1/4));//结果为0 V字形js生成20个div,用js写一个v字形图案 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; div &#123; width: 50px; height: 50px; background: red; position: absolute; top: 0; left: 0; font-size: 30px; text-align: center; line-height: 50px; color: #fff; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var aDiv = document.getElementsByTagName('div'); for (var i = 0; i &lt; 20; i++) &#123; document.body.innerHTML += '&lt;div&gt;' + i + '&lt;/div&gt;'; &#125; for (var i = 0; i &lt; aDiv.length / 2; i++) &#123; aDiv[i].style.left = i * 50 + 'px'; aDiv[i].style.top = i * 50 + 'px'; &#125; for (var i = aDiv.length / 2; i &lt; aDiv.length; i++) &#123; aDiv[i].style.left = i * 50 + 'px'; aDiv[i].style.top = 50*aDiv.length - (i+1) * 50 + 'px'; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的for循环]]></title>
    <url>%2F2018%2F02%2F26%2Fjs%E7%9A%84for%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[for应用：选取、生成、性能方法1：document.body.innerHTML添加使用这种方法添加多个元素的时候，性能不好。因为每一次添加元素的时候都要访问一次body 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload = function ()&#123; // 性能有问题！！！ for( var i=0; i&lt;6000; i++ )&#123; document.body.innerHTML += '&lt;input type="button" value="按钮" /&gt;'; &#125; &#125;;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 方法2：只访问一次body这个方法比上个方法，性能好很多，即使添加多个元素速度也很快 12345678910111213141516171819&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function ()&#123; var str = ''; for( var i=0; i&lt;6000; i++ )&#123; str += '&lt;input type="button" value="按钮" /&gt;'; &#125; document.body.innerHTML = str; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 小tips：可以利用循环来生成视频网站每个播放页面的每个第几集的按钮。 for循环生成坐标1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; div &#123; width: 50px; height: 50px; background: red; position: absolute; top: 0; left: 0; font-size: 30px; text-align: center; line-height: 50px; color: #fff; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var aDiv = document.getElementsByTagName('div'); for (var i = 0; i &lt; 11; i++) &#123; document.body.innerHTML += '&lt;div&gt;' + i + '&lt;/div&gt;'; &#125; for (var i = 0; i &lt; aDiv.length; i++) &#123; aDiv[i].style.left = 10 + i * 50 + 'px'; aDiv[i].style.top = 10 + i * 50 + 'px'; &#125; // 逢10 往下一行（小练习） // 来一个小V字形（小练习） &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; for循环遍历二维数组，嵌套元素]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>for循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片切换及函数合并]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%9B%BE%E7%89%87%E5%88%87%E6%8D%A2%E5%8F%8A%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[图片切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; p &#123; margin: 0; &#125; body &#123; text-align: center; &#125; #box &#123; width: 400px; height: 400px; border: 10px solid #ccc; margin: 50px auto 0; position: relative; &#125; a &#123; width: 40px; height: 40px; background: #fff; filter: alpha(opacity:80); opacity: 0.8; position: absolute; top: 160px; font-size: 18px; color: #000; text-align: center; line-height: 40px; text-decoration: none; &#125; a:hover &#123; filter: alpha(opacity:30); opacity: 0.3; &#125; #prev &#123; left: 10px; &#125; #next &#123; right: 10px; &#125; #p1 &#123; width: 400px; height: 30px; line-height: 30px; text-align: center; background: #000; color: #fff; font-size: 14px; filter: alpha(opacity:80); opacity: 0.8; position: absolute; bottom: 0; left: 0; &#125; strong &#123; width: 400px; height: 30px; line-height: 30px; text-align: center; background: #000; color: #fff; font-size: 14px; filter: alpha(opacity:80); opacity: 0.8; position: absolute; top: 0; left: 0; &#125; #img1 &#123; width: 400px; height: 400px; &#125; span &#123; position: absolute; width: 400px; height: 30px; line-height: 30px; text-align: center; top: -50px; left: 0; font-family: '微软雅黑'; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oPrev = document.getElementById('prev'); var oNext = document.getElementById('next'); var oP = document.getElementById('p1'); var oStrong = document.getElementById('strong1'); var oImg = document.getElementById('img1'); var aBtn = document.getElementsByTagName('input'); var arrUrl = ['img/1.jpg', 'img/2.jpg', 'img/3.jpg', 'img/4.jpg']; var arrText = ['文字一', '文字二', '文字三', '识文断字']; var num = 0; var onOff = true; aBtn[0].onclick = function() &#123; onOff = true; document.getElementsByTagName('span')[0].innerHTML = '图片可从最后一张跳转到第一张循环切换'; &#125;; aBtn[1].onclick = function() &#123; onOff = false; document.getElementsByTagName('span')[0].innerHTML = '图片只能到最后一张\或只能到第一张切换'; &#125;; // 初始化 function fnTab() &#123; oP.innerHTML = arrText[num]; oStrong.innerHTML = num + 1 + ' / ' + arrText.length; oImg.src = arrUrl[num]; &#125; fnTab(); oPrev.onclick = function() &#123; num--; if (num == -1) &#123; if (onOff) &#123; num = arrText.length - 1; &#125; else &#123; alert('这已经是第一张了，不能再往前了~~'); num = 0; &#125; //num = arrText.length-1; &#125; fnTab(); &#125;; oNext.onclick = function() &#123; num++; if (num == arrText.length) &#123; if (onOff) &#123; num = 0; &#125; else &#123; alert('已经到最后一张啦~'); num = arrText.length - 1; &#125; &#125; fnTab(); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="循环切换" /&gt; &lt;input type="button" value="顺序切换" /&gt; &lt;div id="box"&gt;&lt;span&gt;图片可从最后一张跳转到第一张循环切换&lt;/span&gt; &lt;a id="prev" href="javascript:;"&gt; &lt;&lt;/a&gt; &lt;a id="next" href="javascript:;"&gt;&gt;&lt;/a&gt; &lt;p id="p1"&gt;图片文字加载中……&lt;/p&gt; &lt;strong id="strong1"&gt;图片数量计算中……&lt;/strong&gt; &lt;img id="img1" /&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>图片切换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态方法ByTagName]]></title>
    <url>%2F2018%2F02%2F25%2F%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95ByTagName%2F</url>
    <content type="text"><![CDATA[ById与ByTagName区别1：ById前面就只能跟document，不能跟别的元素；ByTagName前面可以跟别的元素。123var oUI=document.getElementById('list');document.getElementByTagName('li');var aLi=oUI.getElementsByTagName('li'); 区别2：ById的方法找到的是一个元素，而ByTagName方法实际上找到的是多个东西，是元素的集合，在使用TagName的时候，必须要加上中括号[],即使页面上只有一个该标签元素，其实找到的也是一个集合。也就是说以后只要见到ByTagName方法，后面必须要跟一个中括号。html部分： 1234567&lt;body&gt; &lt;ul id="list"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; js部分： 1234window.onload = function() &#123; // var oUl = document.getElementById('list'); var oUl = document.getElementsByTagName('ul')[0]; var aLi = oUl.getElementsByTagName('li'); 如在下例中，document.getElementByTagName找到的li，既包含了ul里面的li，又包含了ol里面的li。html部分： 1234567891011&lt;body&gt; &lt;ul id="list"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt; js部分： 123window.onload = function() &#123;document.getElementsByTagName('li');&#125; 区别3：ById是静态方法，ByTagName是动态方法 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload = function ()&#123; // document.title = 123; // document.body.innerHTML = 'abc'; var aBtn = document.getElementsByTagName('input'); // alert(aBtn.length); document.body.innerHTML = '&lt;input type="button" value="按钮" /&gt;&lt;input type="button" value="按钮" /&gt;&lt;input type="button" value="按钮" /&gt;'; // alert(aBtn.length); aBtn[0].onclick = function ()&#123; alert(1); &#125;; aBtn[1].onclick = function ()&#123; alert(1); &#125;; aBtn[2].onclick = function ()&#123; alert(1); &#125;; // 重复执行某些代码 // 每次执行的时候，有个数字在变化&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>ByTagName</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟手机短信发送]]></title>
    <url>%2F2018%2F02%2F25%2F%E6%A8%A1%E6%8B%9F%E6%89%8B%E6%9C%BA%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端练习小项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js条件判断]]></title>
    <url>%2F2018%2F02%2F25%2Fjs%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>条件判断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度文库下载破解]]></title>
    <url>%2F2018%2F02%2F24%2F%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E4%B8%8B%E8%BD%BD%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js属性操作]]></title>
    <url>%2F2018%2F02%2F24%2Fjs%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[HTML的属性操作：读、写属性：属性名+属性值。 属性的读操作读操作：获取、找到。元素.属性名 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oText = document.getElementById('text1'); var oSelect = document.getElementById('select1'); oBtn.onclick = function() &#123; alert(oText.value + '在' + oSelect.value); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="text" id="text1" /&gt; &lt;select id="select1"&gt; &lt;option value="北京"&gt;北京&lt;/option&gt; &lt;option value="上海"&gt;上海&lt;/option&gt; &lt;option value="杭州"&gt;杭州&lt;/option&gt; &lt;/select&gt; &lt;input type="button" id="btn1" value="按钮" /&gt; &lt;/body&gt; &lt;/html&gt; 属性的写操作(添加)替换、修改。元素.属性名=新的值。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oText = document.getElementById('text1'); var oSelect = document.getElementById('select1'); oBtn.onclick = function() &#123; //oBtn.value='button'; //oText.value='按钮'; oText.value=oSelect.value; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="text1" /&gt; &lt;select id="select1"&gt; &lt;option value="北京"&gt;北京&lt;/option&gt; &lt;option value="上海"&gt;上海&lt;/option&gt; &lt;option value="杭州"&gt;杭州&lt;/option&gt; &lt;/select&gt; &lt;input type="button" id="btn1" value="按钮" /&gt;&lt;/body&gt;&lt;/html&gt; 读写操作结合的例子在文本框中输入图片地址，点击按钮切换图片。 123456789101112131415161718192021222324252627&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oText = document.getElementById('text1'); var oImg = document.getElementById('img1'); oBtn.onclick = function() &#123; oImg.src = oText.value; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="text1" type="text" /&gt; &lt;input id="btn1" type="button" value="按钮" /&gt; &lt;p id="p1"&gt;这是一些文字&lt;/p&gt; &lt;img id="img1" src="img/1.jpg" width="200" /&gt;&lt;/body&gt;&lt;/html&gt; innerHTML元素.innerHTML:可以读取元素内的所有HTML代码。元素.innerHTML=新的值：修改或者替换元素内的所有HTML内容。12345678910111213141516171819202122232425262728&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oText = document.getElementById('text1'); var oP = document.getElementById('p1'); oBtn.onclick = function() &#123; // oImg.src = oText.value; // alert( oP.innerHTML ); oP.innerHTML = oText.value; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="text1" type="text" /&gt; &lt;input id="btn1" type="button" value="按钮" /&gt; &lt;p id="p1"&gt;这是一些文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子:属性读写操作配合innerHTML1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt;#div1 &#123; width:240px; height:200px; border:1px solid #333; background:#f1f1f1; padding:10px; &#125;&lt;/style&gt;&lt;script&gt;window.onload = function ()&#123; var oDiv = document.getElementById('div1'); var oStrong = document.getElementById('strong1'); var oText = document.getElementById('text1'); var oBtn = document.getElementById('btn1'); oBtn.onclick = function ()&#123; // 原来的内容，你得给我留着，然后再加上新内容 // a = a + b // a += b // 添加：+= // oDiv.innerHTML = oDiv.innerHTML + oText.value + '&lt;br /&gt;'; oDiv.innerHTML += oStrong.innerHTML + oText.value + '&lt;br /&gt;'; oText.value = ''; &#125;;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;strong id="strong1"&gt;张三：&lt;/strong&gt;&lt;input id="text1" type="text" /&gt;&lt;input id="btn1" type="button" value="提交" /&gt;&lt;/body&gt;&lt;/html&gt; 属性操作注意事项JS中不允许出现“-”，都是去掉“-”，后面的单词的首字母大写。如：font-size fontSizepadding-top paddingTopmargin-left marginLeft1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn1 = document.getElementById('btn1'); var oBtn2 = document.getElementById('btn2'); var oP = document.getElementById('p1'); var num = 14; oBtn1.onclick = function() &#123; num -= 2; oP.style.fontSize = num + 'px'; &#125;; oBtn2.onclick = function() &#123; num += 2; oP.style.fontSize = num + 'px'; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btn1" type="button" value="-" /&gt; &lt;input id="btn2" type="button" value="+" /&gt; &lt;p id="p1" style="font-size:16px;"&gt;10月28日晚，中央纪委监察部官网发布消息，贵州省委常委、遵义市委书记廖少华因涉嫌严重违纪违法接受组织调查。3天后中组部宣布对其免职。廖成为十八大后中纪委一连串"打虎"行动中第十一位落马的副省部级以上高官。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; js中的class作为保留字，不能用，样式名用className1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn1 = document.getElementById('btn1'); var oBtn2 = document.getElementById('btn2'); var oBtn3 = document.getElementById('btn3'); var oBtn4 = document.getElementById('btn4'); var oP = document.getElementById('p1'); var num = 14; oBtn1.onclick = function() &#123; num -= 2; oP.style.fontSize = num + 'px'; &#125;; oBtn2.onclick = function() &#123; num += 2; oP.style.fontSize = num + 'px'; &#125;; oBtn3.onclick = function() &#123; oP.className = 'red'; &#125;; oBtn4.onclick = function() &#123; oP.className = 'yellow'; &#125;; &#125;; &lt;/script&gt; &lt;style&gt; .red &#123; width: 400px; border: 10px solid #333; background: red; padding: 20px; color: yellow; &#125; .yellow &#123; width: 500px; border: 5px solid #333; background: yellow; padding: 10px; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btn1" type="button" value="-" /&gt; &lt;input id="btn2" type="button" value="+" /&gt; &lt;input id="btn3" type="button" value="红" /&gt; &lt;input id="btn4" type="button" value="黄" /&gt; &lt;p id="p1" style="font-size:16px;"&gt;10月28日晚，中央纪委监察部官网发布消息，贵州省委常委、遵义市委书记廖少华因涉嫌严重违纪违法接受组织调查。3天后中组部宣布对其免职。廖成为十八大后中纪委一连串"打虎"行动中第十一位落马的副省部级以上高官。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 不能作为判断条件的有:1、所有的相对路径地址:img src href2、颜色值：color：red #f00 rgb(100,0,0)3、innerHTML不能拿来做判断 js修改input的type(ie6/7/8无效)点击按钮变成复选框的例子： 1234567&lt;input id="inp1" type="button"/&gt;&lt;script&gt;var olp=document.getElementById('inp1');olnp.onclick=function()&#123; olnp.type='checkbox'; //注意：这里在ie6/7/8会报错！！！&#125;&lt;/script&gt; 如果要做上面那个效果，还要兼容ie6/7/8，可以这样巧妙地回避：点击按钮，让按钮隐藏起来，checkbox本来是隐藏的，点击按钮之后让他显示出来。 浮动想要一个元素浮动，在IE下用styleFloat,非IE下用cssFloat,简而言之就是下面这样：同时写两句 123456789101112131415161718192021222324252627282930313233343536373839404142434445 oDiv.style.styleFloat='left'; //兼容IE浏览器 oDiv.style.cssFloat='left'; //兼容非IE浏览器下 ``` 还可以采用下面的方法：通过改class，来修改浮动。 ``` javascript .left&#123;float:left;&#125; .right&#123;float:right;&#125; ``` #### 点后面的值无法修改 ```html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oAttr = document.getElementById('attr'); var oVal = document.getElementById('val'); var oBtn = document.getElementById('btn1'); var oDiv = document.getElementById('div1'); oBtn.onclick = function() &#123; oDiv.style[oAttr.value] = oVal.value; //中括号里面的值可以随便改 //js中允许把点换成[] &#125; &#125; &lt;/script&gt; 请输入属性名称： &lt;input type="text" id="attr" /&gt; &lt;br/&gt; 请输入属性值： &lt;input type="text" id="val" /&gt; &lt;input type="button" value="确定" id="btn1" /&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>属性操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端利器——6款开源web性能优化辅助工具]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%89%8D%E7%AB%AF%E5%88%A9%E5%99%A8%E2%80%94%E2%80%946%E6%AC%BE%E5%BC%80%E6%BA%90web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Web 性能优化是一个老生常谈的话题，也是前端页面开发十分重要的部分。当页面加载速度越慢，用户流失的概率就越大，性能和交互直接影响用户体验。下面推荐几款 Web 性能优化辅助工具推荐，希望能对大家有所帮助 LighthouseLighthouse 是 Google 开源的一个自动化工具，用于改进网络应用的质量。你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 当为 Lighthouse 提供一个要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。可以参考失败的测试，看看可以采取哪些措施来改进应用。 Chrom 扩展则会把报告以非常人性化的图形界面展示给你。 传送门：www.oschina.net/p/lighthouse Speed RacerSpeedRacer 是一款性能测试工具，它在 Chrome 中运行脚本，并生成详细的性能报告。 SpeedRacer 是直接借助浏览器来实际测试性能的工具，在实际工作中，可以与其它模拟用户访问流量来评估性能的工具配合使用。 传送门：https://github.com/speedracer/speedracer Yellow Lab ToolsYellow Lab Tools 是一款 Web 性能及前端质量测试工具。与其他工具不同的是，它有一些在其他工具上无法看到的独特功能，例如页面加载时 JavaScript 与 DOM 互动和其他程序代码验证问题。 Yellow Lab Tools 偏向于一个发现不良实践的工具，会综合页面权重、请求数、DOM、错误的 Javascript、错误的 CSS 等方面取得一个评分。并显示出在加载页面的过程中，DOM 是如何相互影响。 传送门：https://yellowlab.tools/ Web Tracing FrameworkWeb Tracing Framework 也是 Google 推出的一组用于跟踪和调查复杂 Web 应用的库、工具和可视化工具合集。它可以帮助发现性能问题，跟踪回归，并构建流畅的 60fps Web 应用。能让你花更少时间来测试代码即可。 传送门：www.oschina.net/p/tracing-framework grunt-perfbudgetgrunt-perfbudget 是一款用于评估性能的 Grunt task，它使用 WebPagetest 的公有或私有实例在特定的 URL 进行测试，并将测试结果和你预期的性能期望做比较。 如果小于预期，那么这个 task 就顺利完成了，如果超过了预期的性能期望，那么就会报告失败，并帮助你分析超出预期的原因。 传送门：https://github.com/tkadlec/grunt-perfbudget Sitespeed.ioSitespeed.io 是一组基于最佳实践以及一些加载时序等量化标准的开源工具，用以帮助开发者分析网页的加载速度和渲染性能。 Sitespeed.io 从开发者的站点收集多个页面的数据，并根据最佳实践等规则来分析这些网页，然后将结果以 HTML 的形式输出，或者以数值的形式发送到 Graphite 。 传送门：https://www-origin.sitespeed.io/]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>工具</tag>
        <tag>web性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客添加feed]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed%2F</url>
    <content type="text"><![CDATA[安装hexo-generator-feed 1$ npm install hexo-generator-feed --save 配置到站点配置文件_config.yml 12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 最后，在你next主题下的_config.yml下，添加RSS订阅链接即可： rss: /atom.xml]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>feed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客添加站点地图]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[安装hexo-generator-seo-friendly-sitemap 1$ npm install hexo-generator-seo-friendly-sitemap --save 在站点配置文件_config.yml中添加 12sitemap: path: sitemap.xml]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>站点地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加站内搜索]]></title>
    <url>%2F2018%2F02%2F23%2Fhexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 安装步骤安装hexo-generator-search在站点的根目录下执行： $ npm install hexo-generator-search --save 安装hexo-generator-searchdb在站点的根目录下执行： $ npm install hexo-generator-searchdb --save 启用搜索编辑站点配置文件，加入以下代码： search: path: search.xml field: post format: html limit: 10000]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素各种位置宽高]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%85%83%E7%B4%A0%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%AE%BD%E9%AB%98%2F</url>
    <content type="text"><![CDATA[offsetLeftoffsetLeft[Top]:只读，属性，当前元素到定位父级的距离（偏移值），就是到当前元素的offsetParent的距离。 当前元素没有定位，但是有定位父级css部分： 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green;position: relative;&#125;#div3 &#123;background: orange; &#125;&lt;/style&gt; js部分： 1234window.onload = function() &#123; var oDiv3 = document.getElementById('div3'); alert( oDiv3.offsetLeft ); &#125; html部分: 1234567&lt;body id="body1"&gt; &lt;div id="div1"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 上述代码在ie11和Ie7的效果如下两图所示，可以得出结论： 在ie7下，如果自己没有定位，那么offsetLeft[Top]是到body的距离。 所以会显示100px 当前元素有定位的情况，且定位父级css部分: 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green;position: relative;&#125;#div3 &#123;background: orange;position: relative; &#125;&lt;/style&gt; 其余部分代码同上个例子。ie11的效果同上个例子，但是Ie7的效果发生了变化，当前元素有定位的情况下，是到定位父级的距离。 当前元素有定位，但是没有定位父级当前元素如果没有定位父级，offsetLeft默认的情况下是到body的，但是在Ie7下是指向到html的(在ie7以下body的默认margin-left值是10px)。css部分: 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green;&#125;#div3 &#123;background: orange;position: relative; &#125;&lt;/style&gt; 其余部分代码同例子一。 offsetTopcss部分： 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green;&#125;#div3 &#123;background: orange;position: relative; &#125;&lt;/style&gt; js部分: 1234window.onload = function() &#123; var oDiv3 = document.getElementById('div3'); alert( oDiv3.offsetLeft ); &#125; 效果如下,得出结论：ie7下的html默认margin-top是15px 小结如果有定位父级：ie7以下：如果自己没有定位，那么offsetLeft[Top]是到body的距离；如果自己有定位，那么就是到定位父级的距离。其他浏览器：到定位父级的距离。 元素宽高html部分： 123&lt;body&gt; &lt;div id="div1" style="width: 100px; height: 100px; border: 1px solid red; padding: 10px; margin: 10px;"&gt;&lt;/div&gt;&lt;/body&gt; js部分: 12345678&lt;script&gt;window.onload = function() &#123; var oDiv = document.getElementById('div1');alert( oDiv.style.width ); //样式宽100alert( oDiv.clientWidth ); //样式宽 + padding=可视区宽 120alert( oDiv.offsetWidth ); //样式宽 + padding + border 可视区宽 + 边框 122 &#125; &lt;script&gt; 得到三个宽度分别为:]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[父节点]]></title>
    <url>%2F2018%2F02%2F22%2F%E7%88%B6%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[元素.parentNode元素.parentNode:只读，属性，当前节点的父级节点，一个元素的父节点只有一个。在标准下和非标准下都可以，没有什么兼容问题。js部分： 1234window.onload = function() &#123;var oDiv3 = document.getElementById('div3');alert( oDiv3.parentNode.id );&#125; html部分：1234567body id="body1"&gt; &lt;div id="div1"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 在标准ie和非标准ie下，div3的父级都是div2，没有什么兼容性问题。 元素.offsetParent元素.offsetParent:只读，属性，有定位的父节点。如果多个父节点有定位，就是离它最近的有定位的父节点。如果没有定位父级，默认是body。 没有定位父级的例子css部分: 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green; zoom: 1;&#125;#div3 &#123;background: orange;&#125;&lt;/style&gt; js部分： 12345&lt;script&gt;window.onload = function() &#123; var oDiv3 = document.getElementById('div3'); alert( oDiv3.offsetParent ); &#125; html部分： 1234567&lt;body id="body1"&gt; &lt;div id="div1"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; ​ 加了定位属性的例子css部分: 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green; zoom: 1;position: relative;&#125;#div3 &#123;background: orange;&#125;&lt;/style&gt; js部分： 1234window.onload = function() &#123; var oDiv3 = document.getElementById('div3'); alert( oDiv3.offsetParent.id ); &#125; 展示效果如下，可以看出，div2加了定位属性之后，div3的offsetParent就变成了div2,而不是body了。 ie7以下，当前元素有定位例子ie7以下，如果当前元素没有定位默认是body，如果有定位则是html.css部分： 123456 &lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green; zoom: 1;&#125;#div3 &#123;background: orange;position: relative;&#125;&lt;/style&gt; js部分： 1234window.onload = function() &#123; var oDiv3 = document.getElementById('div3'); alert( oDiv3.offsetParent.tagName ); &#125; 在ie11的效果如下图： 在ie7及以下的效果如下图: ie7以下，当前元素某个父级触发layoutie7以下，如果当前元素的某个父级触发了layout，那么offsetParent就会指向到触发了layout特性的父节点上。css部分： 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green; zoom: 1;&#125;#div3 &#123;background: orange;&#125;&lt;/style&gt; js部分： 123window.onload = function() &#123; alert( oDiv3.offsetParent.id); &#125; 效果如下所示，因为div2有zoom属性，zoom触发了layout,所以div3的offsetParent是触发了layout特性的父节点div2]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>父节点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子节点和兄弟节点的操作]]></title>
    <url>%2F2018%2F02%2F21%2F%E5%AD%90%E8%8A%82%E7%82%B9%E5%92%8C%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[元素.firstChild元素.firstChild:只读，属性，第一个子节点 12345678&lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 添加下列代码来显示第一个子节点 下图说明在标准ie浏览器下:firstChild会包含文本类型的节点；在非标准的ie下：只包含元素节点 1alert( oUl.firstChild ); 元素.firstElementChild元素.firstElementChild:只读，属性，标准下获取第一个元素类型的子节点（所以在非标准的ie下是不支持这个属性的),所以非标准下会输出下图所示undefined 可以用以下代码，这样的话在标准下和非标准下都可以正常。 12345 if ( oUl.firstElementChild ) &#123; oUl.firstElementChild.style.background = 'red'; //在标准浏览器下&#125; else &#123; oUl.firstChild.style.background = 'red'; //在非标准ie下&#125; 简化这段代码： 123456var oFirst=oUl.firstElementChild || oUl.firstChild;if(oFirst)&#123; oFirst.style.background='red';&#125;else&#123; alert('没有子节点可以设置'); &#125; 元素.lastChild || 元素.lastElementChild元素.lastChild || 元素.lastElementChild:最后一个子节点 123456var oLast=oUl.lastElementChild || oUl.lastChild;if(oLast)&#123; oLast.style.background='yellow';&#125;else&#123; alert('没有子节点可以设置'); &#125; 元素.nextSibling || 元素.nextElementSibling元素.nextSibling || 元素.nextElementSibling:下一个兄弟节点 12var oNext=oFirst.nextElementSibling || oFirst.nextSibling; oNext.style.background='blue'; 元素.previousSibling || 元素.previousElementSibling元素.previousSibling || 元素.previousElementSibling：上一个兄弟节点 12var oPrev=oLast.previousElementSibling || oLast.previousSibling; oPrev.style.background='orange';]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>DOM</tag>
        <tag>子节点和兄弟节点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM之childNodes]]></title>
    <url>%2F2018%2F02%2F21%2FDOM%E4%B9%8BchildNodes%2F</url>
    <content type="text"><![CDATA[写在前面的话：工作当中不太推荐使用childNodes，兼容性问题比较多。推荐使用childrenDOM是javascript操作网页的接口，全称为文档对象模型（Document Object Model）。它的作用是将网页转为一个JavaScript对象，从而可以使用JavaScript对网页进行各种操作（比如增删内容）。浏览器会根据DOM模型，将HTML文档解析成一系列的节点，再由这些节点组成一个树状结构。DOM的最小组成单位叫做节点（node），文档的树形结构由12种类型的节点组成。 小结：一般地，节点至少拥有nodeType、nodeName和nodeValue这三个基本属性。节点类型不同，三个属性的值也不相同。 childNodes 子节点元素.childNodes为子节点列表集合（只读），注意childNodes只包含一级子节点，不包含后辈孙级以下的节点。 nodeType 节点类型nodeType属性返回节点类型的常数值(无符号短整型)。不同的类型对应不同的常数值，12种类型分别对应12种不同的常数值 节点类型 名称 对应的常数值 元素节点 Node.ELEMENT_NODE 1 属性节点 Node.ATTRIBUTE_NODE 2 文本节点 Node.TEXT_NODE 3 CDATA节点 Node.CDATA_SECTION_NODE 4 实体引用名称节点 Node.ENTRY_REFERENCE_NODE 5 实体名称节点 Node.ENTITY_NODE 6 处理指令节点 Node.PROCESSING_INSTRUCTION_NODE 7 注释节点 Node.COMMENT_NODE 8 文档节点 Node.DOCUMENT_NODE 9 文档类型节点 Node.DOCUMENT_TYPE_NODE 10 文档片段节点 Node.DOCUMENT_FRAGMENT_NODE 11 DTD声明节点 Node.NOTATION_NODE 12 元素节点和文本节点下面这段代码在标准的ie下面显示是9个节点，在非标准的ie下显示4个节点。1234567891011121314151617181920212223&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;&lt;/title&gt;&lt;script&gt;window.onload = function() &#123; var oUl = document.getElementById('ul1'); alert( oUl.childNodes.length ); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 这是因为在标准ie下包含了文本和元素类型的节点，也会包含非法嵌套的节点。而在非标准的浏览器下，只包含元素类型的节点，ie7以下不会包含非法嵌套的节点。所以在这个例子中，在标准浏览器下，会把标签元素之间的回车换行符当作文本类型的节点（有5个）+4个元素节点，合起来就是9个；在非标准下只有4个元素节点。如果删掉其中的一个回车换行符，则会在标准浏览器下减少一个节点。区分了这一点，再看下面这个例子：12345for (var i=0; i&lt;oUl.childNodes.length; i++) &#123; oUl.childNodes[i].style.background = 'red'; &#125; 如果要循环当前oUl下的所有的子节点列表，给所有子节点加上一个背景色。则在非标准的ie下可以很正常地显示：而在标准ie下，会显示出错。这是因为回车换行符被当作文本节点，所以第0个子节点其实是一个文本，文本是没有style也没有background的属性的。 这里我们可以添加以下代码来验证第0个元素的节点类型: 1alert(oUl.childNodes[0].nodeType); 在标准ie下，显示3，说明第0个元素是文本节点。而在非标准ie下显示1，说明第0个节点是元素节点： 属性节点元素.attributes用来获取当前的属性（只读，属性列表集合) 12alert( oUl.attributes.length );获取并显示元素属性个数alert(oUl.attributes[1].value);显示属性值 children工作中推荐使用children，只读属性，子节点列表集合。和child差不多，有一点区别就是： 12345678910&lt;body&gt; &lt;ul id="ul1" &gt; &lt;li&gt;11111 &lt;span&gt;span&lt;/span&gt;&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;p&gt;pppppppp&lt;/p&gt; &lt;/ul&gt;&lt;/body&gt; 上述这段代码，在标准ie下，显示的children.length为5，可以看出使用children的时候不会再把文本节点算进去了，但是把非法嵌套的P也包括进去了 而在非标准ie下，显示的children.length为4，这是因为p没有算进去，不认这种非法嵌套。]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XHTML+CSS2笔记1]]></title>
    <url>%2F2018%2F02%2F20%2FXHTML-CSS2%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[H5标签兼容性解决方案]]></title>
    <url>%2F2018%2F02%2F20%2FH5%E6%A0%87%E7%AD%BE%E5%85%BC%E5%AE%B9%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[H5的语义化标签以及属性，可以让开发者非常方便地实现清晰的web页面布局，加上css3的效果渲染，快速建立web页面就容易多了。H5的新增标签有：http://www.w3school.com.cn/html5/html5_reference.asp使用这些标签可以使代码语义化更加直观，而且更方便seo优化，但是H5新标签在ie6/7/8上并不能识别，这里使用JavaScript来解决兼容性问题。一、原理说明 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; header &#123; width: 200px; height: 200px; background-color: red; &#125; section &#123; width: 150px; height: 150px; background-color: yellow; &#125; footer &#123; width: 100px; height: 100px; background-color: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;header&lt;/header&gt; &lt;section&gt;section&lt;/section&gt; &lt;footer&gt;footer&lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; 例如上面这段代使用了header、section、footer标签，这几个H5的标签在ie7浏览器下打开是这个样子的: 这是因为这几个H5的标签在ie以下的浏览器并不兼容，所以显示不出来样式。解决方法：用js来自定义这三个H5标签，但是因为自定义标签默认为内联样式（不支持宽高的设置，靠内容充满),所以看到的如下所示:12345&lt;script type="text/javascript"&gt;document.createElement("header"); document.createElement("section");document.createElement("footer");&lt;/script&gt; 如果要以块级元素显示，显示宽高，则在每个样式里面添加代码display：block; 二、解决方案1:引用js成熟的库–html5shiv.js在之间直接添加以下代码:​1&lt;script type="text/javascript" src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"&gt;&lt;/script&gt; ​ 或者直接添加: 123&lt;!--[if lt IE 9]&gt;&lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt;&lt;![endif]--&gt; 三、解决方案2：自己coding js 123456789101112&lt;script&gt; (function() &#123; if (! /*@cc_on!@*/ 0) return; var e = “abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video”.split(‘, ‘); var i= e.length; while (i–)&#123; document.createElement(e[i]) &#125; &#125;)() &lt;/script&gt; 不管你用上面哪种方式，请记得在CSS中进行如下定义，目的是让这些标签成为块状元素，just like div。 12/*html5*/article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123;display:block&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>H5标签</tag>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你github+hexo搭建博客（基础篇）]]></title>
    <url>%2F2018%2F02%2F14%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[青蛙旅行破解版]]></title>
    <url>%2F2018%2F02%2F13%2Fqingwa%2F</url>
    <content type="text"><![CDATA[链接 密码 gggg hhhhhhhhhhhhh aaaaaaaaaaaaaa aadddddddddddddd rrrrrrrrrrrrrrrrrr ggggggggggggggggg]]></content>
      <categories>
        <category>android</category>
        <category>逆向</category>
        <category>破解</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>破解</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九大排序算法总结]]></title>
    <url>%2F2018%2F02%2F13%2Fercha%2F</url>
    <content type="text"><![CDATA[主要有以下32种： 在右上角或者左上角实现fork me on github添加RSS添加动态背景实现点击出现桃心效果修改文章内链接文本样式修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记修改作者头像并旋转博文压缩修改“代码块自定义样式侧边栏社交小图标设置主页文章添加阴影效果在网站底部加上访问量添加热度网站底部字数统计添加 README.md 文件设置网站的图标Favicon实现统计功能添加顶部加载条在文章底部增加版权信息添加网易云跟帖(跟帖关闭，已失效，改为来必力)隐藏网页底部powered By Hexo / 强力驱动修改网页底部的桃心文章加密访问添加jiathis分享博文置顶修改字体大小修改打赏字体不闪动自定义鼠标样式为博客加上萌萌的宠物DaoVoice 在线联系点击爆炸效果]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(更新)hexo+github博客搭建进阶指南]]></title>
    <url>%2F2018%2F02%2F13%2Fgithub-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[[TOC] 在右上角或者左上角实现fork me on github点击 这里 或者 这里选择自己喜欢的样式，并复制相应的代码。然后复制代码到themes/next/layout/_layout.swig文件中，放置在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面，并把href改为你的GitHub地址。 添加RSS 切换到你博客文件夹的根目录下，然后在git bash里面输入以下代码，安装模块 npm install --save hexo-generator-feed 然后打开站点配置文件，在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！) #3、添加动态背景实现点击出现桃心效果 修改文章内链接文本样式修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记修改作者头像并旋转博文压缩修改“代码块自定义样式侧边栏社交小图标设置主页文章添加阴影效果在网站底部加上访问量添加热度网站底部字数统计添加 README.md 文件设置网站的图标Favicon实现统计功能添加顶部加载条在文章底部增加版权信息添加网易云跟帖(跟帖关闭，已失效，改为来必力)隐藏网页底部powered By Hexo / 强力驱动修改网页底部的桃心文章加密访问添加jiathis分享博文置顶修改字体大小修改打赏字体不闪动自定义鼠标样式为博客加上萌萌的宠物DaoVoice 在线联系点击爆炸效果]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>github</tag>
        <tag>hxo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM浅谈]]></title>
    <url>%2F2018%2F02%2F02%2FDOM%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[先附上一个DOM的教程：http://www.w3school.com.cn/htmldom/dom_methods.asp DOM的结构实际上和数据结构里面的树非常相似 方法 描述getElementById() 返回带有指定 ID 的元素。getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。appendChild() 把新的子节点添加到指定节点。removeChild() 删除子节点。replaceChild() 替换子节点。insertBefore() 在指定的子节点前面插入新的子节点。createAttribute() 创建属性节点。createElement() 创建元素节点。createTextNode() 创建文本节点。getAttribute() 返回指定的属性值。setAttribute() 把指定属性设置或修改为指定的值。 ·其他细节修改Copyright：isabllezhou mail:isabellezhou@163.com]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
</search>
