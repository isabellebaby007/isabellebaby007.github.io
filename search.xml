<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F05%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[title: 运算符与流程控制date: 2018-03-05 18:01:09tags: 前端 js 运算符 流程控制categories: 前端 js 取余效果：鼠标划过，隔行改变颜色，鼠标离开，恢复原来的灰色。 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var aLi = document.getElementsByTagName(&apos;li&apos;); var arr = [&apos;red&apos;, &apos;yellow&apos;, &apos;blue&apos;]; for (var i = 0; i &lt; aLi.length; i++) { aLi[i].index = i; aLi[i].style.background = arr[i % arr.length]; aLi[i].onmouseover = function() { this.style.background = &apos;gray&apos;; }; aLi[i].onmouseout = function() { this.style.background = arr[this.index % arr.length]; }; } }; &lt;/script&gt; &lt;style&gt; li { height: 24px; margin-bottom: 3px; list-style: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[js作用域]]></title>
    <url>%2F2018%2F03%2F04%2Fjs%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[预解析机制 作用域域：空间、范围、区域……作用：读、写script 全局变量、全局函数,自上而下函数 由里到外浏览器：“JS解析器”1）“找一些东西” ：var function 参数a = …所有的变量，在正式运行代码之前，都提前赋了一个值：未定义fn1 = function fn1(){ alert(2); }所有的函数，在正式运行代码之前，都是整个函数块JS 的预解析遇到重名的：只留一个变量和函数重名了，就只留下函数 2）逐行解读代码：表达式：= + - * / % ++ – ! 参数……表达式可以修改预解析的值！ 小例子 alert(a); // 输出 function a (){ alert(4); } //因为预解析之后，变量和函数重名了就只留下函数，所以a是整个函数块 function a(){alert(4)}; var a = 1; alert(a); // 输出 1 //表达式var a=1;修改了预解析的值 function a (){ alert(2); } alert(a); // 输出 1 // 函数不修改值 var a = 3; alert(a); // 输出 3 //表达式var a=3;修改了预解析的值 function a (){ alert(4); } alert(a); // 输出 3 //函数不修改值 alert( typeof a ); //number // a(); // 报错 js单线程运行&lt;script&gt; alert(a); //报错 &lt;/script&gt; &lt;script&gt; var a=1; //1 alert(a); &lt;/script&gt; 前一个script区域运行完之后，值会保存。 &lt;script&gt; var a=1; //1 alert(a); &lt;/script&gt; &lt;script&gt; alert(a); //1 &lt;/script&gt; 函数也是一个局部的域函数调用：预解析+逐行解读代码1)预解析： var function 参数….a=…fn1=function(){ alert(a); var a=2；}2）逐行解读代码：表达式函数调用2.1）预解析： a=… 这里的a是局部变量2.2)逐行解读代码： a=2; var a = 1; function fn1(){ alert(a); // undefined var a = 2; //a=2 } fn1(); alert(a); // 1 下面看看 不加var的影响1)预解析： var function 参数….a=…fn1=function(){ alert(a); a=2；}2）逐行解读代码：表达式函数调用2.1）局部预解析：因为函数里面没有var 所有没有找到，2.2)局部逐行解读代码： a=2; var a = 1; function fn1(){ alert(a); // 1 所以返回父级去找。由里到外（作用域链）找到外面那个a a = 2; //这里修改的是外面的那个a } fn1(); alert(a); // 2 小结：先找东西，后执行。执行过程中遇到表达式就会去修改原来库里面的东西，如果遇到函数调用就开了一个新的作用域，一旦新的作用域开始了，又会重复以上步骤，新的作用域中如果没找到里面有东西，又会返回父级里面去找。 带参数的函数1)预解析： var function 参数….a=…fn1=function(a){ alert(a); a=2；}2）逐行解读代码：表达式函数调用2.1）局部预解析：因为函数里面没有var ,也没有找到函数，所有没有找到。参数本质上就是一个局部变量。找到了参数，但是这个例子里函数调用并没有传进来。参数 a=…未定义2.2)局部逐行解读代码： 局部变量a就是undefined var a = 1; //全局变量a=1 function fn1(a){ alert(a); // undefined a = 2; //这句把a改成2 } fn1(); alert(a); // 这里读取父级的a=1 函数调用带参数1)预解析： var function 参数….a=…fn1=function(a){ alert(a); a=2；}2）逐行解读代码：表达式函数调用fn1(a)2.1）局部预解析：参数本质上就是一个局部变量，因为这个例子里面传递了参数进来，所以a=undefined。参数 a=…未定义2.2)局部逐行解读代码：因为传递进来的a=1,所以局部变量a=1,再下一步就是局部变量a=2。 全局变量a仍然是1 var a = 1; function fn1(a){ alert(a); // 1 a = 2; } fn1(a); alert(a); // 1 任何函数都可以改全局变量因为函数内部没有这个变量的话，会从里往外找。 var num = 0; function fn1(){ num++; } function fn2(){ num--; } fn2(); fn1(); fn2(); alert(num); 获取函数内的值巧妙利用全局变量来去获取函数内的内容 var str = &apos;&apos;; function fn1(){ var a = &apos;大鸡腿~&apos;; str = a; } fn1(); alert( str ); //大鸡腿 另一种方法： function fn2(){ var a = &apos;9999999克拉钻石23456789&apos;; fn3(a); } fn2(); function fn3(a){ alert(a); } 注意事项if(){}和for(){}、do{}while不是作用域，函数是作用域。firefox不能对下面的函数进行预解析,除了火狐以外，其他的浏览器都可以。 alert( fn1 ); // FF 不能对下面的函数进行预解析 if( true ){ var a = 1; function fn1(){ alert(123); } } 解决这个兼容性问题的方法是：以后尽量不要在if语句里面定义函数，全局变量。改成下面这种写法： for里面包了一个函数，在函数里面不要直接使用i下例会出现undefined的原因是：点击事件函数是一个作用域，只要有作用域，就会有域解析，点击事件函数里面域解析的时候会找到var i=undefined,所以这里alert(i)是undefined。但是如果把for循环里面的var去掉的话，那么点击事件函数里面就没有变量，所以i就会到父级里面去找，父级i是3,所以此时alert(i)会弹出3。 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var aBtn = document.getElementsByTagName(&apos;input&apos;); for (var i = 0; i &lt; aBtn.length; i++) { aBtn[i].onclick = function() { alert( i ); for (var i = 0; i &lt; aBtn.length; i++) { aBtn[i].style.background = &apos;yellow&apos;; } }; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;按钮1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;按钮2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;按钮3&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 但是如果把js代码改成以下就会出错 &lt;script&gt; window.onload = function() { var aBtn = document.getElementsByTagName(&apos;input&apos;); for (var i = 0; i &lt; aBtn.length; i++) { aBtn[i].onclick = function() { alert( i ); // 3 aBtn[i].style.background = &apos;yellow&apos;; }; } }; &lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>作用域</tag>
        <tag>预解析</tag>
        <tag>易错点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数传参项目]]></title>
    <url>%2F2018%2F03%2F04%2F%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[搜狐视频纪录片列表展示 修改文本框的值 选择卡里套选择卡]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>函数传参</tag>
        <tag>前端练习小项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绝对定位与相对定位]]></title>
    <url>%2F2018%2F03%2F04%2F%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E4%B8%8E%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[通常情况下，元素的position属性的值默认为static，也就是没有定位，元素出现再正常的文档流中，这个时候如果给元素设置left、right、bottom、top这些偏移属性，都不会生效，z-index也不会生效。 相对定位relative注意：使用相对定位时，就算元素被偏移了，但是它仍然会占据着没偏移之前的空间。 上图，第二个块针对本身的位置发生了一个偏移，但是它原来所占据的那个位置空间仍然还在，即使它完全离开原来的位置，但是它原来位于文档流中的位置仍然会存在，不会被第三个浮动过来填补掉；同时它的偏移也不会把别的块从文档流中原来的位置挤开，如果有重叠的地方它会重叠再其他文档流元素之上，可以通关过设置z-index属性来调整他的堆叠顺序。 绝对定位absolute被设置了绝对定位的元素，在文档流中是不占据空间的，如果某元素设置了绝对定位，那么它在文档流中的位置会被删除，其实这个元素是浮了起来，它与relative的不同点在于：相对定位不会删除它本身在文档流中占据的那块空间，而绝对定位则会删除该元素在文档流中的位置，完全从文档流中抽出来。 绝对定位是如何定位的？ 一、如果它的父级元素设置了除static之外的定位，比如position：relative 或者position：absolute或者position：fixed,那么它就会相对于它的父级元素来定位，位置通过left、top、right、bottom（刚好一个顺时针）属性来规定。 二、如果它的父级元素没有设置定位，那么就得看它父元素得父元素有没有设置定位，如果还是没有，就继续向更高层得祖先元素类推。 小结：总之它的定位就是相对于设置了除static定位之外得定位得第一个祖先元素，如果以上情况都不存在，那么他就会相对于文档body来定位（并非窗口，相对于窗口来定位得是fixed）绝对定位得元素相对于谁来定位，我们就把这个“谁”叫做参照物。 下面是使用了绝对定位得效果： 注意：在设置偏移量得时候，可以设置负值。]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>相对定位绝对定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数传参]]></title>
    <url>%2F2018%2F03%2F04%2F%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[函数传参 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; /* 函数传递参数 参数=JS的数据类型： 数字、字符串、布尔、函数、对象、未定义 */ fn1(100, &apos;px&apos;); function fn1(a, b) { // alert( a+b ); } fn2(&apos;miaov&apos;); fn2(&apos;妙味课堂&apos;); function fn2(a) { // alert(a.charAt(2)); } //传递一个有名字的函数，不用带括号 function fn4() { alert(4); } fn3(fn4); fn3(function(a) { alert(a); }); function fn3(fn) { fn(100); fn(); } //传递对象 fn5(window, document); function fn5(w, d) { w.onload = function() { d.body.innerHTML = 123; }; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 代码重用1、尽量保证 HTML 代码结构一致，可以通过父级选取子元素2、把核心主程序实现，用函数包起来3、把每组里不同的值找出来，通过传参实现 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; ul { padding: 0; margin: 0; } li { list-style: none; } body { background: #333; } .box { width: 400px; height: 500px; position: relative; background: url(img/loader_ico.gif) no-repeat center #fff; float: left; margin-right: 60px; } .box img { width: 400px; height: 500px; } .box ul { width: 40px; position: absolute; top: 0; right: -50px; } .box li { width: 40px; height: 40px; margin-bottom: 4px; background: #666; } .box .active { background: #FC3; } .box span { top: 0; } .box p { bottom: 0; margin: 0; } .box p, .box span { position: absolute; left: 0; width: 400px; height: 30px; line-height: 30px; text-align: center; color: #fff; background: #000; } &lt;/style&gt; &lt;script&gt; window.onload = function() { fnTab(&apos;pic1&apos;, [&apos;img/1.png&apos;, &apos;img/2.png&apos;, &apos;img/3.png&apos;, &apos;img/4.png&apos;], [&apos;小宠物&apos;, &apos;图片二&apos;, &apos;图片三&apos;, &apos;面具&apos;], &apos;onclick&apos;); fnTab(&apos;pic2&apos;, [&apos;img/2.png&apos;, &apos;img/3.png&apos;, &apos;img/4.png&apos;], [&apos;图片二&apos;, &apos;图片三&apos;, &apos;面具&apos;], &apos;onmouseover&apos;); }; function fnTab(id, arrUrl, arrText, evt) { var oDiv = document.getElementById(id); var oImg = oDiv.getElementsByTagName(&apos;img&apos;)[0]; var oSpan = oDiv.getElementsByTagName(&apos;span&apos;)[0]; var oP = oDiv.getElementsByTagName(&apos;p&apos;)[0]; var oUl = oDiv.getElementsByTagName(&apos;ul&apos;)[0]; var aLi = oUl.getElementsByTagName(&apos;li&apos;); var num = 0; for (var i = 0; i &lt; arrUrl.length; i++) { oUl.innerHTML += &apos;&lt;li&gt;&lt;/li&gt;&apos;; } // 初始化 function fnTab() { oImg.src = arrUrl[num]; oSpan.innerHTML = 1 + num + &apos; / &apos; + arrUrl.length; oP.innerHTML = arrText[num]; for (var i = 0; i &lt; aLi.length; i++) { aLi[i].className = &apos;&apos;; } aLi[num].className = &apos;active&apos;; } fnTab(); for (var i = 0; i &lt; aLi.length; i++) { aLi[i].index = i; // 索引值 aLi[i][evt] = function() { num = this.index; fnTab(); }; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;pic1&quot; class=&quot;box&quot;&gt; &lt;img src=&quot;&quot; /&gt; &lt;span&gt;数量正在加载中……&lt;/span&gt; &lt;p&gt;文字说明正在加载中……&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div id=&quot;pic2&quot; class=&quot;box&quot;&gt; &lt;img src=&quot;&quot; /&gt; &lt;span&gt;数量正在加载中……&lt;/span&gt; &lt;p&gt;文字说明正在加载中……&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 应用：仿淘宝购物车计算&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var oUl = document.getElementById(&apos;list&apos;); var aLi = oUl.getElementsByTagName(&apos;li&apos;); for (var i = 0; i &lt; aLi.length; i++) { fn1(aLi[i]); } function fn1(oLi) { var aBtn = oLi.getElementsByTagName(&apos;input&apos;); var oStrong = oLi.getElementsByTagName(&apos;strong&apos;)[0]; var oEm = oLi.getElementsByTagName(&apos;em&apos;)[0]; var oSpan = oLi.getElementsByTagName(&apos;span&apos;)[0]; var n1 = Number(oStrong.innerHTML); //动态获取 &apos;0&apos; =&gt; 0 var n2 = parseFloat(oEm.innerHTML); //动态获取 &apos;12.5元&apos; =&gt; 12.5 aBtn[0].onclick = function() { n1--; if (n1 &lt; 0) { n1 = 0; } oStrong.innerHTML = n1; oSpan.innerHTML = n1 * n2 + &apos;元&apos;; }; aBtn[1].onclick = function() { n1++; oStrong.innerHTML = n1; oSpan.innerHTML = n1 * n2 + &apos;元&apos;; }; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt; &lt;input type=&quot;button&quot; value=&quot;-&quot; /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type=&quot;button&quot; value=&quot;+&quot; /&gt; 单价： &lt;em&gt;12.5元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;button&quot; value=&quot;-&quot; /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type=&quot;button&quot; value=&quot;+&quot; /&gt; 单价： &lt;em&gt;10.5元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;button&quot; value=&quot;-&quot; /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type=&quot;button&quot; value=&quot;+&quot; /&gt; 单价： &lt;em&gt;8.5元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;button&quot; value=&quot;-&quot; /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type=&quot;button&quot; value=&quot;+&quot; /&gt; 单价： &lt;em&gt;8元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;button&quot; value=&quot;-&quot; /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type=&quot;button&quot; value=&quot;+&quot; /&gt; 单价： &lt;em&gt;14.5元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt; 商品合计共：0件，共花费了：0元 &lt;br /&gt; 其中最贵的商品单价是：0元 &lt;/p&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>函数传参</tag>
        <tag>前端练习小项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型转换练习]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[找到合适的值 &lt;!--more--&gt; &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; body { font-size: 20px; } &lt;/style&gt; &lt;script&gt; window.onload = function() { var arr = [&apos;100px&apos;, &apos;abc&apos; - 6, [], -98765, 34, -2, 0, &apos;300&apos;, , function() { alert(1); }, null, document, [], true, &apos;200px&apos; - 30, &apos;23.45元&apos;, 5, Number(&apos;abc&apos;), function() { alert(3); }, &apos;xyz&apos; - 90]; var ob = document.getElementsByTagName(&apos;body&apos;)[0]; var a1 = []; var a2 = []; var a3 = []; var a4 = []; var max = 0; /* 1、找到arr里所有的数字：-98765, 34, -2, 0, 5 2、找到可以转成数字的：&apos;100px&apos;, -98765, 34, -2, 0, &apos;300&apos;, &apos;23.45元&apos;, 5 3、把转成数字以后，最大值判断出来：300 4、把 NaN 所在的位置找出来：1 14 17 19 */ //题目一：用函数把数字选择出来，由于NaN在数字类型，所以用ISNaN把NAN去除掉 ob.innerHTML += &apos;&lt;br/&gt;&apos; + &apos;1、找到arr里所有的数字: &apos; for (var i = 0; i &lt; arr.length; i++) { if (typeof arr[i] == &apos;number&apos; &amp;&amp; !isNaN(arr[i])) { a1.push(arr[i]); } } for (var i = 0; i &lt; a1.length; i++) { ob.innerHTML += a1[i] + &apos; ,&apos;; } //题目二：用函数把可以数字转换的找出来，再单独找0,要把中括号去除呢 ob.innerHTML += &apos;&lt;br/&gt;&apos; + &apos;2、找到可以转成数字的: &apos; for (var i = 0; i &lt; arr.length; i++) { if (parseFloat(arr[i]) || (arr[i] == 0 &amp;&amp; typeof arr[i] == &apos;number&apos;)) { a2.push(arr[i]); } } for (var i = 0; i &lt; a2.length; i++) { ob.innerHTML += a2[i] + &apos; ,&apos;; } //题目三：用函数把可以数字转换出来，再单独找0输入 for (var i = 0; i &lt; a2.length; i++) { if (parseFloat(a2[i]) || a2[i] == 0) { a3.push(parseFloat(a2[i])); } } ob.innerHTML += &apos;&lt;br/&gt;&apos; + &apos;3、把转换数字后的数组为: &apos; for (var i = 0; i &lt; a3.length; i++) { if (max &lt; a3[i]) { max = a3[i]; } ob.innerHTML += a3[i] + &apos; ,&apos;; } ob.innerHTML += &apos; 排序后最大值：&apos; + max; //题目四：把 NaN 所在的位置找出来：1 14 17 19 ob.innerHTML += &apos;&lt;br/&gt;&apos; + &apos;4、把 NaN 所在的位置找出来: &apos; for (var i = 0; i &lt; arr.length; i++) { if (isNaN(arr[i]) &amp;&amp; typeof arr[i] == &apos;number&apos;) { a4.push(i); } } for (var i = 0; i &lt; a4.length; i++) { ob.innerHTML += a4[i] + &apos; ,&apos;; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; QQ号码&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;/head&gt; &lt;script&gt; window.onload = function() { var oText = document.getElementById(&apos;t&apos;) var oBtn = document.getElementById(&apos;b&apos;) var count = 0; oBtn.onclick = function() { if (oText.value == &apos;&apos;) { alert(&apos;没有输入&apos;) count++; } if (isNaN(oText.value)) { alert(&apos;非数字&apos;) count++; } if (oText.value.charAt(0) == 0) { alert(&apos;不能有0在前面&apos;) count++; } if (parseFloat(oText.value) != parseInt(oText.value)) { alert(&apos;不能是小数&apos;) count++; } if (oText.value.length &lt; 5 || oText.value.length &gt; 10) { alert(&apos;输入的数字必须在5位以上、10位以内&apos;) count++; } if (count == 0) { alert(&apos;输入的号码正确呢&apos;) } } } &lt;/script&gt; &lt;body&gt; 请输入QQ号码： &lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;t&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;判断&quot; id=&quot;b&quot; /&gt; &lt;br /&gt; 1、有没有输入 &lt;br /&gt; 2、输入的是不是数字 &lt;br /&gt; 3、不能有0在前面 &lt;br /&gt; 4、不能是小数 &lt;br /&gt; 5、输入的数字必须在5位以上、10位以内 &lt;br /&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>前端练习小项目</tag>
        <tag>数据类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链简介]]></title>
    <url>%2F2018%2F03%2F02%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js数据类型、类型转换]]></title>
    <url>%2F2018%2F03%2F02%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[js数据类型以及相关操作 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; /* ECMAScript：标准、核心 HTML 标签类型：block、inline、inline-block、table…… JS中的数据类型：数字、字符串、布尔、函数、对象(obj、[]、{}、null)、未定义 typeof 判断数据类型 */ var i = 100; // alert( typeof i ); // number var s = &apos; miaov &apos;; // alert( typeof s ); // string // alert( s.length ); // 7 // alert( s.charAt(3) ); // &apos;a&apos; var b = true; // 布尔值：true false // alert( typeof b ); // boolean if ( true ) {} for ( ; false ; ) { } var fn = function (){ alert(1); }; // fn(); function fn1(){ alert(2); } // alert( fn1 ); // fn1(); var obj = document; // alert( typeof obj ); // object 物体、东西、对象 obj.abc = 123; obj.onOff = true; obj.fn1 = function (){ alert(1); }; // alert( document.onOff ); // 123 // obj.fn1(); var arr = [ 1,2,3,4 ]; // alert( arr.length ); // arr[2] = 345; // alert( arr ); // arr.push( 5,6,7 ); // alert( arr ); // alert( typeof arr ); // object arr.abc = 999; arr.fn1 = function (){ alert(&apos;ok&apos;); }; // alert( arr.abc ); // arr.fn1(); var json = { name:&apos;miaov&apos;, age:5 }; // alert( json.name + &apos;今年&apos; + json.age + &apos;岁了&apos; ); // alert( typeof json );//object var n = null; // alert( typeof n );//空的东西不能添加属性 var u; // alert( typeof u ); // undefined 未定义 // 表示你写的程序出问题了~~ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 数据类型转换(显式类型转换)字符串变成数字&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var a = &apos;+100&apos;; // alert( a+100 ); // &apos;100100&apos; // alert( Number(a) ); // 100 var a1 = &apos; &apos;; // alert( Number(a1) ); // 0 var a2 = true; // alert( Number(a2) ); // true-1 false-0 var a3=[]; alert(Number(a3)); //0 var a3=[&apos;&apos;]; alert(Number(a3)); //0 var a3 = [ 1 ]; // alert( Number(a3) ); // 1 var a4 = null; // alert( Number(a4) ); // 0 var a3=function(){alert(1);}; alert(Number(a3)); //NaN //////////////////////////////////////////////////////////////////////////// var json = {}; // alert( Number(json) ); //NaN var u; // alert( Number(u) ); //NaN var a3 = function (){ alert(1); }; // alert( Number(a3) ); // NaN &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; parseInt与parseFloat的区别与小技巧 var b = &apos; 200px&apos;; alert( parseInt(b) ); //200 默认十进制 var b = &apos; 200px&apos;; alert( parseInt(b，16进制) ); //200 十六进制 var b = &apos; 200px1234567&apos;; alert( parseInt(b) ); //200 var c = &apos;12.34元&apos;; // alert( parseInt(c) ); //12 var c = &apos;12.34元&apos;; // alert( parseFloat(c) ); //12.34 var c = &apos;12.3.4元&apos;; // alert( parseFloat(c) ); //12.3 验证是整数还是小数 var num = &apos;200.45&apos;; if( parseInt(num) == parseFloat(num) ){ alert( num + &apos;是整数&apos; ); }else{ alert( num + &apos;是小数&apos; ); } js中稀奇古怪的隐式类型转换&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; /* 显式类型转换（强制类型转换）： Number() parseInt() parseFloat() 隐式类型转换： + 200 + &apos;3&apos; 变成字符串 - * / % &apos;200&apos; - 3 变成数字 ++ -- 变成数字 &gt; &lt; 数字的比较 、字符串的比较 ! 取反 把右边的数据类型转成布尔值 == */ // alert( Number(&apos;……&apos;) ); NaN // alert( &apos;……&apos;-9 ); NaN // alert( &apos;2&apos; == 2 ); //字符串的比较 // alert( &apos;10000000&apos; &gt; &apos;9&apos; );//false 一位一位地比较 // 数字的比较与字符串的比较 // &apos;1000000&apos; &apos;9&apos; // alert( &apos;2&apos; == 2 ); //true 判断值，所以两个等号可以转换 alert(&apos;2&apos;===2); //三个等号更严谨，先去判断类型，再去判断值 alert(!&apos;ok&apos;); //false &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; NaN&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; // JS中的数据类型：数字（NaN）、字符串、布尔、函数、对象(obj、[]、{}、null)、未定义 var a = Number(&apos;abc&apos;); // alert( a ); // NaN // NaN：not a number 不是个 数字 的 数字类型 // alert( typeof (a) ); // number // 一旦写程序中出现：NaN 肯定进行了非法的运算操作 // alert( &apos;200px&apos; - 100 ); // NaN 是 false if (a) { alert( &apos;真&apos; ); } else { alert( &apos;假&apos; ); } var abc = []; // alert( abc === abc ); true // NaN 与自己都不相等！！除了NaN以外，其他的数据类型都是自己和自己相等的 alert(a === a); // false isNaN();//判断某些值是不是数字类型 不是数字true 是数字 false //在内部是根据Number来进行转换，转换之后进行判断 alert(isNaN(&apos;250&apos;));//&apos;250&apos;--250--false alert(isNaN(true));//true--1--false alert(isNaN([]));//[]--0--false &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; isNaN()小应用&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var aInp = document.getElementsByTagName(&apos;input&apos;); var str = &apos;&apos;; aInp[1].onclick = function() { str = aInp[0].value; // HTML 中拿到的内容，类型都是字符串 // alert( typeof str ); if (isNaN(str)) { alert(str + &apos;不是数字&apos;); } else { alert(str + &apos;是数字&apos;); } }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;判断输入值是不是数字&quot; /&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单实现QQ好友列表]]></title>
    <url>%2F2018%2F03%2F02%2F%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0QQ%E5%A5%BD%E5%8F%8B%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[简单实现QQ好友列表需求：实现折叠与展开，实现点击高亮显示 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; ul, h2 { /*样式重置*/ padding: 0; margin: 0; } li {/* 去掉列表前面的点*/ list-style: none; } #list { width: 240px; border: 1px solid #333; margin: 0 auto; } #list .lis {} #list h2 { height: 30px; line-height: 30px; text-indent: 20px; background: url(img/ico1.gif) no-repeat 5px center #6FF; color: #000; } #list .active { background: url(img/ico2.gif) no-repeat 5px center #FF9; color: #000; } #list ul { display: none; } #list ul li { line-height: 24px; border-bottom: 1px solid #333; text-indent: 24px; } #list ul .hover { background: #6FF; } &lt;/style&gt; &lt;script&gt; window.onload = function() { var oUl = document.getElementById(&apos;list&apos;); var aH2 = oUl.getElementsByTagName(&apos;h2&apos;); var aUl = oUl.getElementsByTagName(&apos;ul&apos;); var aLi = null; var arrLi = []; for (var i = 0; i &lt; aH2.length; i++) { aH2[i].index = i; aH2[i].onclick = function() { for (var i = 0; i &lt; aH2.length; i++) { if (i != this.index) { aUl[i].style.display = &apos;none&apos;; aH2[i].className = &apos;&apos;; } } if (this.className == &apos;&apos;) { /*这里两个等号或者三个等号都可以*/ aUl[this.index].style.display = &apos;block&apos;; this.className = &apos;active&apos;; } else { aUl[this.index].style.display = &apos;none&apos;; this.className = &apos;&apos;; } }; } for (var i = 0; i &lt; aUl.length; i++) { aLi = aUl[i].getElementsByTagName(&apos;li&apos;); for (var j = 0; j &lt; aLi.length; j++) { arrLi.push(aLi[j]); } } for (var i = 0; i &lt; arrLi.length; i++) { arrLi[i].onclick = function() { for (var i = 0; i &lt; arrLi.length; i++) { if (arrLi[i] != this) { arrLi[i].className = &apos;&apos;; } } if (this.className == &apos;&apos;) { this.className = &apos;hover&apos;; } else { this.className = &apos;&apos;; } }; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li class=&quot;lis&quot;&gt; &lt;h2&gt;我的好友&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li&gt;张三&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;lis&quot;&gt; &lt;h2&gt;企业好友&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;lis&quot;&gt; &lt;h2&gt;黑名单&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;张小三&lt;/li&gt; &lt;li&gt;李小四&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>for</tag>
        <tag>前端练习小项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义属性]]></title>
    <url>%2F2018%2F03%2F02%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[什么是自定义属性通俗地讲，就是js往html上添加东西。js可以为任何html元素添加任意个自定义属性。例如下面程序的abc、xyz就是自定义属性 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var aBtn = document.getElementsByTagName(&apos;input&apos;); for (var i = 0; i &lt; aBtn.length; i++) { aBtn[i].abc = 123; aBtn[i].xyz = true; } alert(aBtn[0].abc); }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;按钮1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;按钮2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;按钮3&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 应用1:自定义一组开关应用注意不能当作判断条件的有1、背景不能判断 2、color不能判断 3、相对路径不能当作判断条件 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; li { list-style: none; width: 114px; height: 140px; background: url(img/normal.png); float: left; margin-right: 20px; } &lt;/style&gt; &lt;script&gt; window.onload = function() { var aLi = document.getElementsByTagName(&apos;li&apos;); // var onOff = true; // 只能控制一组！ for (var i = 0; i &lt; aLi.length; i++) { aLi[i].onOff = true;//给每个要控制的元素都添加一个开关 aLi[i].onclick = function() { // alert( this.style.background ); if (this.onOff) { this.style.background = &apos;url(img/active.png)&apos;; this.onOff = false; } else { this.style.background = &apos;url(img/normal.png)&apos;; this.onOff = true; } }; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 应用2：获取自身递增数字及匹配数组内容相当于一个按钮就可以 控制一组东西的变化 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var aBtn = document.getElementsByTagName(&apos;input&apos;); var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;]; for (var i = 0; i &lt; aBtn.length; i++) { aBtn[i].num = 0; aBtn[i].onclick = function() { // alert( arr[ this.num ] ); this.value = arr[this.num]; this.num++; if (this.num === arr.length) { this.num = 0; } }; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;0&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;0&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;0&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 应用3：添加索引值、匹配数组&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var aBtn = document.getElementsByTagName(&apos;input&apos;); for (var i = 0; i &lt; aBtn.length; i++) { aBtn[i].index = i; // 自定义属性（索引值） aBtn[i].onclick = function() { // alert( i ); alert(this.index); //添加索引值，自定义索引值 }; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;btn3&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 索引的引用想建立“匹配”“对应”关系，就用索引值 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var aBtn = document.getElementsByTagName(&apos;input&apos;); var arr = [&apos;莫涛&apos;, &apos;张森&apos;, &apos;杜鹏&apos;]; for (var i = 0; i &lt; aBtn.length; i++) { aBtn[i].index = i; // 自定义属性（索引值） aBtn[i].onclick = function() { // alert( arr[ this.index ] ); this.value = arr[this.index]; }; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;btn3&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 通过索引将按钮和P匹配&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var aBtn = document.getElementsByTagName(&apos;input&apos;); var aP = document.getElementsByTagName(&apos;p&apos;); var arr = [&apos;马云&apos;, &apos;马化腾&apos;, &apos;李彦宏&apos;]; for (var i = 0; i &lt; aBtn.length; i++) { aBtn[i].index = i; // 自定义属性（索引值） aBtn[i].onclick = function() { // alert( arr[ this.index ] ); this.value = arr[this.index]; aP[this.index].innerHTML = arr[this.index]; }; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;btn1&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;btn2&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;btn3&quot; /&gt; &lt;p&gt;a&lt;/p&gt; &lt;p&gt;b&lt;/p&gt; &lt;p&gt;c&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; hexo &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; ul { padding: 0; margin: 0; }/*样式的重置*/ li { list-style: none; } body { background: #333; } #pic { width: 400px; height: 500px; position: relative; margin: 0 auto; background: url(img/loader_ico.gif) no-repeat center #fff; } #pic img { width: 400px; height: 500px; } #pic ul { width: 40px; position: absolute; top: 0; right: -50px; } #pic li { width: 40px; height: 40px; margin-bottom: 4px; background: #666; } #pic .active { background: #FC3; } #pic span { top: 0; } #pic p { bottom: 0; margin: 0; } #pic p, #pic span { position: absolute; left: 0; width: 400px; height: 30px; line-height: 30px; text-align: center; color: #fff; background: #000; } &lt;/style&gt; &lt;script&gt; window.onload = function() { var oDiv = document.getElementById(&apos;pic&apos;); var oImg = oDiv.getElementsByTagName(&apos;img&apos;)[0]; var oSpan = oDiv.getElementsByTagName(&apos;span&apos;)[0]; var oP = oDiv.getElementsByTagName(&apos;p&apos;)[0]; var oUl = oDiv.getElementsByTagName(&apos;ul&apos;)[0]; var aLi = oUl.getElementsByTagName(&apos;li&apos;); var arrUrl = [&apos;img/1.png&apos;, &apos;img/2.png&apos;, &apos;img/3.png&apos;, &apos;img/4.png&apos;]; var arrText = [&apos;小宠物&apos;, &apos;图片二&apos;, &apos;图片三&apos;, &apos;面具&apos;]; var num = 0; var oldLi = null; for (var i = 0; i &lt; arrUrl.length; i++) { oUl.innerHTML += &apos;&lt;li&gt;&lt;/li&gt;&apos;; } oldLi = aLi[num]; // 初始化 oImg.src = arrUrl[num]; oSpan.innerHTML = 1 + num + &apos; / &apos; + arrUrl.length; oP.innerHTML = arrText[num]; aLi[num].className = &apos;active&apos;; for (var i = 0; i &lt; aLi.length; i++) { aLi[i].index = i; // 索引值 aLi[i].onclick = function() { oImg.src = arrUrl[this.index]; oP.innerHTML = arrText[this.index]; oSpan.innerHTML = 1 + this.index + &apos; / &apos; + arrText.length; /* &lt;li class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; */ // 思路一：全部清空，当前添加 for (var i = 0; i &lt; aLi.length; i++) { aLi[i].className = &apos;&apos;; } this.className = &apos;active&apos;; /* // 思路二：清空上个，当前添加 oldLi.className = &apos;&apos;; oldLi = this; this.className = &apos;active&apos;; */ }; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;pic&quot;&gt; &lt;img src=&quot;&quot; /&gt; &lt;span&gt;数量正在加载中……&lt;/span&gt; &lt;p&gt;文字说明正在加载中……&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>自定义属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑客入门电子书整理]]></title>
    <url>%2F2018%2F03%2F01%2F%E9%BB%91%E5%AE%A2%E5%85%A5%E9%97%A8%E7%94%B5%E5%AD%90%E4%B9%A6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[黑客攻防电子书整理 链接: https://pan.baidu.com/s/1sm2fjZ3 密码: dvt3]]></content>
      <categories>
        <category>books</category>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>hacker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this指向及this应用]]></title>
    <url>%2F2018%2F02%2F28%2Fthis%E6%8C%87%E5%90%91%E5%8F%8Athis%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[thisthis可以理解为调用当前方法或者函数的那个对象，通俗地说就是谁调用了函数指的就是谁。例如下面程序的this指的是一个按钮。 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; // this : 这个 // this： 指的是调用 当前 方法（函数）的那个对象 function fn1() { // this } // fn1(); this =&gt; window // oDiv.onclick = fn1; this =&gt; oDiv /* oDiv.onclick = function (){ fn1(); fn1() 里的this =&gt; window }; &lt;div onclick=&quot; this fn1(); &quot;&gt;&lt;/div&gt; fn1(); 里的 this 指的是 window */ // alert( this ); // object window // window 是 JS “老大” // window.alert( this ); function fn1() { alert(this); // window } // fn1(); // window.fn1(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;按钮&quot; /&gt; &lt;input id=&quot;btn2&quot; type=&quot;button&quot; onclick=&quot; fn1(); &quot; value=&quot;按钮2&quot; /&gt; &lt;script&gt; var oBtn = document.getElementById(&apos;btn1&apos;); // oBtn.onclick = fn1; oBtn.onclick = function() { // this fn1(); }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for循环遍历二维数组、嵌套元素]]></title>
    <url>%2F2018%2F02%2F28%2Ffor%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E3%80%81%E5%B5%8C%E5%A5%97%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[二维数组即数组里面的数组，例如常见的好友列表就是这种结构。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var arr = [ [1, 2, 3, 4, '4+'], [4, 5, 6], [7, 8, 9] ]; // arr[1][2] for (var i = 0; i &lt; arr.length; i++) &#123; // arr[i][0] // arr[i][1] // arr[i][2] for (var j = 0; j &lt; arr[i].length; j++) &#123; // alert( arr[i][j] ); &#125; &#125; // for( var i=0; )&#123;&#125; // for( var i=0; )&#123;&#125; window.onload = function() &#123; var oUl = document.getElementById('list'); var aUl = oUl.getElementsByTagName('ul'); var len = aUl.length; var aLi = null; // 空 for (var i = 0; i &lt; len; i++) &#123; aLi = aUl[i].getElementsByTagName('li'); for (var j = 0; j &lt; aLi.length; j++) &#123; aLi[j].style.border = '1px solid red'; &#125; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="list"&gt; &lt;li&gt; &lt;h2&gt;我的好友&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;莫涛&lt;/li&gt; &lt;li&gt;张森&lt;/li&gt; &lt;li&gt;杜鹏&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;ol&gt; &lt;li&gt;no&lt;/li&gt; &lt;li&gt;no&lt;/li&gt; &lt;li&gt;no&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;我的白名单&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;莫小涛&lt;/li&gt; &lt;li&gt;张小森&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;ol&gt; &lt;li&gt;no&lt;/li&gt; &lt;li&gt;no&lt;/li&gt; &lt;li&gt;no&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;我的黑名单&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;莫张&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; cssText在下例中，cssText只是针对div的行间样式做修改，并没有动style里面的样式。后面的cssText会替换掉前面的cssText。 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; div { width: 100px; height: 100px; border: 1px solid #333; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt;123&lt;/div&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;按钮&quot; /&gt; &lt;script&gt; var oDiv = document.getElementById(&apos;div1&apos;); var oBtn = document.getElementById(&apos;btn1&apos;); oDiv.onclick = function() { // oDiv.style.width = &apos;200px&apos;; oDiv.style.cssText = &apos; width:200px;height:200px;&apos;; }; oBtn.onclick = function() { // oDiv.style.width = &apos;100px&apos;; oDiv.style.cssText = &apos;&apos;; //这里的cssText会替换掉上面的cssText，类似于innerHTML }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 例子：自动上生成一组新闻&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn1&apos;); var oUl = document.getElementById(&apos;list&apos;); var arr = [ &apos;山西省委附近多次爆炸 官方称尚不确定是恐怖袭击&apos;, &apos;甘肃张掖明令禁止转基因 书记:无力辨别只能禁止&apos;, &apos;多地制定雾霾预案限行限排被批治标不治本&apos;, &apos;韩媒抱怨中国雾霾侵袭韩国 称其为&quot;黑色灾难&quot; &apos;, &apos;伊朗革命卫队高官在叙利亚当&quot;志愿者&quot;被杀(图)&apos; ]; var onOff = true; oBtn.onclick = function() { // oBtn.disabled = true; // oBtn.style.display = &apos;none&apos;; //思路1、按钮找麻烦 // oUl.innerHTML = &apos;&apos;; //思路2、先清空，再生成，不过影响性能 // onOff = false; no!!!! if (onOff) { //思路3、另设一个变量，做判断 // onOff = false; ok for (var i = 0; i &lt; arr.length; i++) { oUl.innerHTML += &apos;&lt;li&gt;&apos; + arr[i] + &apos;&lt;/li&gt;&apos;; } // onOff = false; ok } onOff = false; }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;自动生成5条新闻&quot; /&gt; &lt;ul id=&quot;list&quot; style=&quot;border:1px solid red;&quot;&gt;&lt;/ul&gt; &lt;script&gt; alert(document.getElementById(&apos;list&apos;).style.border); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for应用（逢十、V字）]]></title>
    <url>%2F2018%2F02%2F28%2Ffor%E5%BA%94%E7%94%A8%EF%BC%88%E9%80%A2%E5%8D%81%E3%80%81V%E5%AD%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[逢十往下一行用js生成100个div，每行十个。 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; div { width: 50px; height: 50px; background: red; position: absolute; top: 0; left: 0; font-size: 30px; text-align: center; line-height: 50px; color: #fff; } &lt;/style&gt; &lt;script&gt; window.onload = function() { var aDiv = document.getElementsByTagName('div'); for (var i = 0; i &lt; 100; i++) { document.body.innerHTML += '&lt;div&gt;' + i + '&lt;/div&gt;'; } for (var i = 0; i &lt; aDiv.length; i++) { var m = i % 10; var n = parseInt(i / 10); aDiv[i].style.left = m * 50 + 'px'; aDiv[i].style.top = 10 + n * 50 + 'px'; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 小拓展：可以用这种方法来写一个元素周期表的效果小结：求余数 document.write(1%4); //结果为1 求商 console.info(1/4);//结果为0.25 求商，取整 console.info(parseInt(1/4));//结果为0 天花板取整 console.info(Math.ceil(1/4));//结果为1 地板取整 console.info(Math.floor(1/4));//结果为0 V字形js生成20个div,用js写一个v字形图案 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; div { width: 50px; height: 50px; background: red; position: absolute; top: 0; left: 0; font-size: 30px; text-align: center; line-height: 50px; color: #fff; } &lt;/style&gt; &lt;script&gt; window.onload = function() { var aDiv = document.getElementsByTagName(&apos;div&apos;); for (var i = 0; i &lt; 20; i++) { document.body.innerHTML += &apos;&lt;div&gt;&apos; + i + &apos;&lt;/div&gt;&apos;; } for (var i = 0; i &lt; aDiv.length / 2; i++) { aDiv[i].style.left = i * 50 + &apos;px&apos;; aDiv[i].style.top = i * 50 + &apos;px&apos;; } for (var i = aDiv.length / 2; i &lt; aDiv.length; i++) { aDiv[i].style.left = i * 50 + &apos;px&apos;; aDiv[i].style.top = 50*aDiv.length - (i+1) * 50 + &apos;px&apos;; } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的for循环]]></title>
    <url>%2F2018%2F02%2F26%2Fjs%E7%9A%84for%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[for应用：选取、生成、性能方法1：document.body.innerHTML添加使用这种方法添加多个元素的时候，性能不好。因为每一次添加元素的时候都要访问一次body 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload = function ()&#123; // 性能有问题！！！ for( var i=0; i&lt;6000; i++ )&#123; document.body.innerHTML += '&lt;input type="button" value="按钮" /&gt;'; &#125; &#125;;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 方法2：只访问一次body这个方法比上个方法，性能好很多，即使添加多个元素速度也很快 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function (){ var str = &apos;&apos;; for( var i=0; i&lt;6000; i++ ){ str += &apos;&lt;input type=&quot;button&quot; value=&quot;按钮&quot; /&gt;&apos;; } document.body.innerHTML = str; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 小tips：可以利用循环来生成视频网站每个播放页面的每个第几集的按钮。 for循环生成坐标&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; div { width: 50px; height: 50px; background: red; position: absolute; top: 0; left: 0; font-size: 30px; text-align: center; line-height: 50px; color: #fff; } &lt;/style&gt; &lt;script&gt; window.onload = function() { var aDiv = document.getElementsByTagName(&apos;div&apos;); for (var i = 0; i &lt; 11; i++) { document.body.innerHTML += &apos;&lt;div&gt;&apos; + i + &apos;&lt;/div&gt;&apos;; } for (var i = 0; i &lt; aDiv.length; i++) { aDiv[i].style.left = 10 + i * 50 + &apos;px&apos;; aDiv[i].style.top = 10 + i * 50 + &apos;px&apos;; } // 逢10 往下一行（小练习） // 来一个小V字形（小练习） }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; for循环遍历二维数组，嵌套元素]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>for循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片切换及函数合并]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%9B%BE%E7%89%87%E5%88%87%E6%8D%A2%E5%8F%8A%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[图片切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; p &#123; margin: 0; &#125; body &#123; text-align: center; &#125; #box &#123; width: 400px; height: 400px; border: 10px solid #ccc; margin: 50px auto 0; position: relative; &#125; a &#123; width: 40px; height: 40px; background: #fff; filter: alpha(opacity:80); opacity: 0.8; position: absolute; top: 160px; font-size: 18px; color: #000; text-align: center; line-height: 40px; text-decoration: none; &#125; a:hover &#123; filter: alpha(opacity:30); opacity: 0.3; &#125; #prev &#123; left: 10px; &#125; #next &#123; right: 10px; &#125; #p1 &#123; width: 400px; height: 30px; line-height: 30px; text-align: center; background: #000; color: #fff; font-size: 14px; filter: alpha(opacity:80); opacity: 0.8; position: absolute; bottom: 0; left: 0; &#125; strong &#123; width: 400px; height: 30px; line-height: 30px; text-align: center; background: #000; color: #fff; font-size: 14px; filter: alpha(opacity:80); opacity: 0.8; position: absolute; top: 0; left: 0; &#125; #img1 &#123; width: 400px; height: 400px; &#125; span &#123; position: absolute; width: 400px; height: 30px; line-height: 30px; text-align: center; top: -50px; left: 0; font-family: '微软雅黑'; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oPrev = document.getElementById('prev'); var oNext = document.getElementById('next'); var oP = document.getElementById('p1'); var oStrong = document.getElementById('strong1'); var oImg = document.getElementById('img1'); var aBtn = document.getElementsByTagName('input'); var arrUrl = ['img/1.jpg', 'img/2.jpg', 'img/3.jpg', 'img/4.jpg']; var arrText = ['文字一', '文字二', '文字三', '识文断字']; var num = 0; var onOff = true; aBtn[0].onclick = function() &#123; onOff = true; document.getElementsByTagName('span')[0].innerHTML = '图片可从最后一张跳转到第一张循环切换'; &#125;; aBtn[1].onclick = function() &#123; onOff = false; document.getElementsByTagName('span')[0].innerHTML = '图片只能到最后一张\或只能到第一张切换'; &#125;; // 初始化 function fnTab() &#123; oP.innerHTML = arrText[num]; oStrong.innerHTML = num + 1 + ' / ' + arrText.length; oImg.src = arrUrl[num]; &#125; fnTab(); oPrev.onclick = function() &#123; num--; if (num == -1) &#123; if (onOff) &#123; num = arrText.length - 1; &#125; else &#123; alert('这已经是第一张了，不能再往前了~~'); num = 0; &#125; //num = arrText.length-1; &#125; fnTab(); &#125;; oNext.onclick = function() &#123; num++; if (num == arrText.length) &#123; if (onOff) &#123; num = 0; &#125; else &#123; alert('已经到最后一张啦~'); num = arrText.length - 1; &#125; &#125; fnTab(); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="循环切换" /&gt; &lt;input type="button" value="顺序切换" /&gt; &lt;div id="box"&gt;&lt;span&gt;图片可从最后一张跳转到第一张循环切换&lt;/span&gt; &lt;a id="prev" href="javascript:;"&gt; &lt;&lt;/a&gt; &lt;a id="next" href="javascript:;"&gt;&gt;&lt;/a&gt; &lt;p id="p1"&gt;图片文字加载中……&lt;/p&gt; &lt;strong id="strong1"&gt;图片数量计算中……&lt;/strong&gt; &lt;img id="img1" /&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>图片切换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态方法ByTagName]]></title>
    <url>%2F2018%2F02%2F25%2F%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95ByTagName%2F</url>
    <content type="text"><![CDATA[ById与ByTagName区别1：ById前面就只能跟document，不能跟别的元素；ByTagName前面可以跟别的元素。var oUI=document.getElementById(&apos;list&apos;); document.getElementByTagName(&apos;li&apos;); var aLi=oUI.getElementsByTagName(&apos;li&apos;); 区别2：ById的方法找到的是一个元素，而ByTagName方法实际上找到的是多个东西，是元素的集合，在使用TagName的时候，必须要加上中括号[],即使页面上只有一个该标签元素，其实找到的也是一个集合。也就是说以后只要见到ByTagName方法，后面必须要跟一个中括号。html部分： &lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; js部分： window.onload = function() { // var oUl = document.getElementById(&apos;list&apos;); var oUl = document.getElementsByTagName(&apos;ul&apos;)[0]; var aLi = oUl.getElementsByTagName(&apos;li&apos;); 如在下例中，document.getElementByTagName找到的li，既包含了ul里面的li，又包含了ol里面的li。html部分： &lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/body&gt; js部分： window.onload = function() { document.getElementsByTagName(&apos;li&apos;); } 区别3：ById是静态方法，ByTagName是动态方法 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function (){ // document.title = 123; // document.body.innerHTML = &apos;abc&apos;; var aBtn = document.getElementsByTagName(&apos;input&apos;); // alert(aBtn.length); document.body.innerHTML = &apos;&lt;input type=&quot;button&quot; value=&quot;按钮&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;按钮&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;按钮&quot; /&gt;&apos;; // alert(aBtn.length); aBtn[0].onclick = function (){ alert(1); }; aBtn[1].onclick = function (){ alert(1); }; aBtn[2].onclick = function (){ alert(1); }; // 重复执行某些代码 // 每次执行的时候，有个数字在变化 }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>ByTagName</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟手机短信发送]]></title>
    <url>%2F2018%2F02%2F25%2F%E6%A8%A1%E6%8B%9F%E6%89%8B%E6%9C%BA%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端练习小项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js条件判断]]></title>
    <url>%2F2018%2F02%2F25%2Fjs%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>条件判断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度文库下载破解]]></title>
    <url>%2F2018%2F02%2F24%2F%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E4%B8%8B%E8%BD%BD%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js属性操作]]></title>
    <url>%2F2018%2F02%2F24%2Fjs%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[HTML的属性操作：读、写属性：属性名+属性值。 属性的读操作读操作：获取、找到。元素.属性名 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oText = document.getElementById('text1'); var oSelect = document.getElementById('select1'); oBtn.onclick = function() &#123; alert(oText.value + '在' + oSelect.value); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="text" id="text1" /&gt; &lt;select id="select1"&gt; &lt;option value="北京"&gt;北京&lt;/option&gt; &lt;option value="上海"&gt;上海&lt;/option&gt; &lt;option value="杭州"&gt;杭州&lt;/option&gt; &lt;/select&gt; &lt;input type="button" id="btn1" value="按钮" /&gt; &lt;/body&gt; &lt;/html&gt; 属性的写操作(添加)替换、修改。元素.属性名=新的值。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oText = document.getElementById('text1'); var oSelect = document.getElementById('select1'); oBtn.onclick = function() &#123; //oBtn.value='button'; //oText.value='按钮'; oText.value=oSelect.value; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="text1" /&gt; &lt;select id="select1"&gt; &lt;option value="北京"&gt;北京&lt;/option&gt; &lt;option value="上海"&gt;上海&lt;/option&gt; &lt;option value="杭州"&gt;杭州&lt;/option&gt; &lt;/select&gt; &lt;input type="button" id="btn1" value="按钮" /&gt;&lt;/body&gt;&lt;/html&gt; 读写操作结合的例子在文本框中输入图片地址，点击按钮切换图片。 123456789101112131415161718192021222324252627&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oText = document.getElementById('text1'); var oImg = document.getElementById('img1'); oBtn.onclick = function() &#123; oImg.src = oText.value; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="text1" type="text" /&gt; &lt;input id="btn1" type="button" value="按钮" /&gt; &lt;p id="p1"&gt;这是一些文字&lt;/p&gt; &lt;img id="img1" src="img/1.jpg" width="200" /&gt;&lt;/body&gt;&lt;/html&gt; innerHTML元素.innerHTML:可以读取元素内的所有HTML代码。元素.innerHTML=新的值：修改或者替换元素内的所有HTML内容。12345678910111213141516171819202122232425262728&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oText = document.getElementById('text1'); var oP = document.getElementById('p1'); oBtn.onclick = function() &#123; // oImg.src = oText.value; // alert( oP.innerHTML ); oP.innerHTML = oText.value; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="text1" type="text" /&gt; &lt;input id="btn1" type="button" value="按钮" /&gt; &lt;p id="p1"&gt;这是一些文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子:属性读写操作配合innerHTML1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt;#div1 &#123; width:240px; height:200px; border:1px solid #333; background:#f1f1f1; padding:10px; &#125;&lt;/style&gt;&lt;script&gt;window.onload = function ()&#123; var oDiv = document.getElementById('div1'); var oStrong = document.getElementById('strong1'); var oText = document.getElementById('text1'); var oBtn = document.getElementById('btn1'); oBtn.onclick = function ()&#123; // 原来的内容，你得给我留着，然后再加上新内容 // a = a + b // a += b // 添加：+= // oDiv.innerHTML = oDiv.innerHTML + oText.value + '&lt;br /&gt;'; oDiv.innerHTML += oStrong.innerHTML + oText.value + '&lt;br /&gt;'; oText.value = ''; &#125;;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;strong id="strong1"&gt;张三：&lt;/strong&gt;&lt;input id="text1" type="text" /&gt;&lt;input id="btn1" type="button" value="提交" /&gt;&lt;/body&gt;&lt;/html&gt; 属性操作注意事项JS中不允许出现“-”，都是去掉“-”，后面的单词的首字母大写。如：font-size fontSizepadding-top paddingTopmargin-left marginLeft1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn1 = document.getElementById('btn1'); var oBtn2 = document.getElementById('btn2'); var oP = document.getElementById('p1'); var num = 14; oBtn1.onclick = function() &#123; num -= 2; oP.style.fontSize = num + 'px'; &#125;; oBtn2.onclick = function() &#123; num += 2; oP.style.fontSize = num + 'px'; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btn1" type="button" value="-" /&gt; &lt;input id="btn2" type="button" value="+" /&gt; &lt;p id="p1" style="font-size:16px;"&gt;10月28日晚，中央纪委监察部官网发布消息，贵州省委常委、遵义市委书记廖少华因涉嫌严重违纪违法接受组织调查。3天后中组部宣布对其免职。廖成为十八大后中纪委一连串"打虎"行动中第十一位落马的副省部级以上高官。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; js中的class作为保留字，不能用，样式名用className1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn1 = document.getElementById('btn1'); var oBtn2 = document.getElementById('btn2'); var oBtn3 = document.getElementById('btn3'); var oBtn4 = document.getElementById('btn4'); var oP = document.getElementById('p1'); var num = 14; oBtn1.onclick = function() &#123; num -= 2; oP.style.fontSize = num + 'px'; &#125;; oBtn2.onclick = function() &#123; num += 2; oP.style.fontSize = num + 'px'; &#125;; oBtn3.onclick = function() &#123; oP.className = 'red'; &#125;; oBtn4.onclick = function() &#123; oP.className = 'yellow'; &#125;; &#125;; &lt;/script&gt; &lt;style&gt; .red &#123; width: 400px; border: 10px solid #333; background: red; padding: 20px; color: yellow; &#125; .yellow &#123; width: 500px; border: 5px solid #333; background: yellow; padding: 10px; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btn1" type="button" value="-" /&gt; &lt;input id="btn2" type="button" value="+" /&gt; &lt;input id="btn3" type="button" value="红" /&gt; &lt;input id="btn4" type="button" value="黄" /&gt; &lt;p id="p1" style="font-size:16px;"&gt;10月28日晚，中央纪委监察部官网发布消息，贵州省委常委、遵义市委书记廖少华因涉嫌严重违纪违法接受组织调查。3天后中组部宣布对其免职。廖成为十八大后中纪委一连串"打虎"行动中第十一位落马的副省部级以上高官。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 不能作为判断条件的有:1、所有的相对路径地址:img src href2、颜色值：color：red #f00 rgb(100,0,0)3、innerHTML不能拿来做判断 js修改input的type(ie6/7/8无效)点击按钮变成复选框的例子： 1234567&lt;input id="inp1" type="button"/&gt;&lt;script&gt;var olp=document.getElementById('inp1');olnp.onclick=function()&#123; olnp.type='checkbox'; //注意：这里在ie6/7/8会报错！！！&#125;&lt;/script&gt; 如果要做上面那个效果，还要兼容ie6/7/8，可以这样巧妙地回避：点击按钮，让按钮隐藏起来，checkbox本来是隐藏的，点击按钮之后让他显示出来。 浮动想要一个元素浮动，在IE下用styleFloat,非IE下用cssFloat,简而言之就是下面这样：同时写两句 123456789101112131415161718192021222324252627282930313233343536373839404142434445 oDiv.style.styleFloat='left'; //兼容IE浏览器 oDiv.style.cssFloat='left'; //兼容非IE浏览器下 ``` 还可以采用下面的方法：通过改class，来修改浮动。 ``` javascript .left&#123;float:left;&#125; .right&#123;float:right;&#125; ``` #### 点后面的值无法修改 ```html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oAttr = document.getElementById('attr'); var oVal = document.getElementById('val'); var oBtn = document.getElementById('btn1'); var oDiv = document.getElementById('div1'); oBtn.onclick = function() &#123; oDiv.style[oAttr.value] = oVal.value; //中括号里面的值可以随便改 //js中允许把点换成[] &#125; &#125; &lt;/script&gt; 请输入属性名称： &lt;input type="text" id="attr" /&gt; &lt;br/&gt; 请输入属性值： &lt;input type="text" id="val" /&gt; &lt;input type="button" value="确定" id="btn1" /&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>属性操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端利器——6款开源web性能优化辅助工具]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%89%8D%E7%AB%AF%E5%88%A9%E5%99%A8%E2%80%94%E2%80%946%E6%AC%BE%E5%BC%80%E6%BA%90web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Web 性能优化是一个老生常谈的话题，也是前端页面开发十分重要的部分。当页面加载速度越慢，用户流失的概率就越大，性能和交互直接影响用户体验。下面推荐几款 Web 性能优化辅助工具推荐，希望能对大家有所帮助 LighthouseLighthouse 是 Google 开源的一个自动化工具，用于改进网络应用的质量。你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 当为 Lighthouse 提供一个要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。可以参考失败的测试，看看可以采取哪些措施来改进应用。 Chrom 扩展则会把报告以非常人性化的图形界面展示给你。 传送门：www.oschina.net/p/lighthouse Speed RacerSpeedRacer 是一款性能测试工具，它在 Chrome 中运行脚本，并生成详细的性能报告。 SpeedRacer 是直接借助浏览器来实际测试性能的工具，在实际工作中，可以与其它模拟用户访问流量来评估性能的工具配合使用。 传送门：https://github.com/speedracer/speedracer Yellow Lab ToolsYellow Lab Tools 是一款 Web 性能及前端质量测试工具。与其他工具不同的是，它有一些在其他工具上无法看到的独特功能，例如页面加载时 JavaScript 与 DOM 互动和其他程序代码验证问题。 Yellow Lab Tools 偏向于一个发现不良实践的工具，会综合页面权重、请求数、DOM、错误的 Javascript、错误的 CSS 等方面取得一个评分。并显示出在加载页面的过程中，DOM 是如何相互影响。 传送门：https://yellowlab.tools/ Web Tracing FrameworkWeb Tracing Framework 也是 Google 推出的一组用于跟踪和调查复杂 Web 应用的库、工具和可视化工具合集。它可以帮助发现性能问题，跟踪回归，并构建流畅的 60fps Web 应用。能让你花更少时间来测试代码即可。 传送门：www.oschina.net/p/tracing-framework grunt-perfbudgetgrunt-perfbudget 是一款用于评估性能的 Grunt task，它使用 WebPagetest 的公有或私有实例在特定的 URL 进行测试，并将测试结果和你预期的性能期望做比较。 如果小于预期，那么这个 task 就顺利完成了，如果超过了预期的性能期望，那么就会报告失败，并帮助你分析超出预期的原因。 传送门：https://github.com/tkadlec/grunt-perfbudget Sitespeed.ioSitespeed.io 是一组基于最佳实践以及一些加载时序等量化标准的开源工具，用以帮助开发者分析网页的加载速度和渲染性能。 Sitespeed.io 从开发者的站点收集多个页面的数据，并根据最佳实践等规则来分析这些网页，然后将结果以 HTML 的形式输出，或者以数值的形式发送到 Graphite 。 传送门：https://www-origin.sitespeed.io/]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>web性能</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客添加feed]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed%2F</url>
    <content type="text"><![CDATA[安装hexo-generator-feed $ npm install hexo-generator-feed --save 配置到站点配置文件_config.yml # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 最后，在你next主题下的_config.yml下，添加RSS订阅链接即可： rss: /atom.xml]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>feed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客添加站点地图]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[安装hexo-generator-seo-friendly-sitemap $ npm install hexo-generator-seo-friendly-sitemap --save 在站点配置文件_config.yml中添加 sitemap: path: sitemap.xml]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>站点地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加站内搜索]]></title>
    <url>%2F2018%2F02%2F23%2Fhexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 安装步骤安装hexo-generator-search在站点的根目录下执行： $ npm install hexo-generator-search --save 安装hexo-generator-searchdb在站点的根目录下执行： $ npm install hexo-generator-searchdb --save 启用搜索编辑站点配置文件，加入以下代码： search: path: search.xml field: post format: html limit: 10000]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素各种位置宽高]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%85%83%E7%B4%A0%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%AE%BD%E9%AB%98%2F</url>
    <content type="text"><![CDATA[offsetLeftoffsetLeft[Top]:只读，属性，当前元素到定位父级的距离（偏移值），就是到当前元素的offsetParent的距离。 当前元素没有定位，但是有定位父级css部分： &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green;position: relative;} #div3 {background: orange; } &lt;/style&gt; js部分： window.onload = function() { var oDiv3 = document.getElementById(&apos;div3&apos;); alert( oDiv3.offsetLeft ); } html部分: &lt;body id=&quot;body1&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt; &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 上述代码在ie11和Ie7的效果如下两图所示，可以得出结论： 在ie7下，如果自己没有定位，那么offsetLeft[Top]是到body的距离。 所以会显示100px 当前元素有定位的情况，且定位父级css部分: &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green;position: relative;} #div3 {background: orange;position: relative; } &lt;/style&gt; 其余部分代码同上个例子。ie11的效果同上个例子，但是Ie7的效果发生了变化，当前元素有定位的情况下，是到定位父级的距离。 当前元素有定位，但是没有定位父级当前元素如果没有定位父级，offsetLeft默认的情况下是到body的，但是在Ie7下是指向到html的(在ie7以下body的默认margin-left值是10px)。css部分: &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green;} #div3 {background: orange;position: relative; } &lt;/style&gt; 其余部分代码同例子一。 offsetTopcss部分： &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green;} #div3 {background: orange;position: relative; } &lt;/style&gt; js部分: window.onload = function() { var oDiv3 = document.getElementById(&apos;div3&apos;); alert( oDiv3.offsetLeft ); } 效果如下,得出结论：ie7下的html默认margin-top是15px 小结如果有定位父级：ie7以下：如果自己没有定位，那么offsetLeft[Top]是到body的距离；如果自己有定位，那么就是到定位父级的距离。其他浏览器：到定位父级的距离。 元素宽高html部分： &lt;body&gt; &lt;div id=&quot;div1&quot; style=&quot;width: 100px; height: 100px; border: 1px solid red; padding: 10px; margin: 10px;&quot;&gt;&lt;/div&gt; &lt;/body&gt; js部分: &lt;script&gt; window.onload = function() { var oDiv = document.getElementById(&apos;div1&apos;); alert( oDiv.style.width ); //样式宽100 alert( oDiv.clientWidth ); //样式宽 + padding=可视区宽 120 alert( oDiv.offsetWidth ); //样式宽 + padding + border 可视区宽 + 边框 122 } &lt;script&gt; 得到三个宽度分别为:]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>DOM</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[父节点]]></title>
    <url>%2F2018%2F02%2F22%2F%E7%88%B6%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[元素.parentNode元素.parentNode:只读，属性，当前节点的父级节点，一个元素的父节点只有一个。在标准下和非标准下都可以，没有什么兼容问题。js部分： window.onload = function() { var oDiv3 = document.getElementById(&apos;div3&apos;); alert( oDiv3.parentNode.id ); } html部分： body id=&quot;body1&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt; &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 在标准ie和非标准ie下，div3的父级都是div2，没有什么兼容性问题。 元素.offsetParent元素.offsetParent:只读，属性，有定位的父节点。如果多个父节点有定位，就是离它最近的有定位的父节点。如果没有定位父级，默认是body。 没有定位父级的例子css部分: &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green; zoom: 1;} #div3 {background: orange;} &lt;/style&gt; js部分： &lt;script&gt; window.onload = function() { var oDiv3 = document.getElementById(&apos;div3&apos;); alert( oDiv3.offsetParent ); } html部分： &lt;body id=&quot;body1&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt; &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 加了定位属性的例子css部分: &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green; zoom: 1;position: relative;} #div3 {background: orange;} &lt;/style&gt; js部分： window.onload = function() { var oDiv3 = document.getElementById(&apos;div3&apos;); alert( oDiv3.offsetParent.id ); } 展示效果如下，可以看出，div2加了定位属性之后，div3的offsetParent就变成了div2,而不是body了。 ie7以下，当前元素有定位例子ie7以下，如果当前元素没有定位默认是body，如果有定位则是html.css部分： &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green; zoom: 1;} #div3 {background: orange;position: relative;} &lt;/style&gt; js部分： window.onload = function() { var oDiv3 = document.getElementById(&apos;div3&apos;); alert( oDiv3.offsetParent.tagName ); } 在ie11的效果如下图： 在ie7及以下的效果如下图: ie7以下，当前元素某个父级触发layoutie7以下，如果当前元素的某个父级触发了layout，那么offsetParent就会指向到触发了layout特性的父节点上。css部分： &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green; zoom: 1;} #div3 {background: orange;} &lt;/style&gt; js部分： window.onload = function() { alert( oDiv3.offsetParent.id); } 效果如下所示，因为div2有zoom属性，zoom触发了layout,所以div3的offsetParent是触发了layout特性的父节点div2]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>父节点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子节点和兄弟节点的操作]]></title>
    <url>%2F2018%2F02%2F21%2F%E5%AD%90%E8%8A%82%E7%82%B9%E5%92%8C%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[元素.firstChild元素.firstChild:只读，属性，第一个子节点 &lt;body&gt; &lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; 添加下列代码来显示第一个子节点 下图说明在标准ie浏览器下:firstChild会包含文本类型的节点；在非标准的ie下：只包含元素节点 alert( oUl.firstChild ); 元素.firstElementChild元素.firstElementChild:只读，属性，标准下获取第一个元素类型的子节点（所以在非标准的ie下是不支持这个属性的),所以非标准下会输出下图所示undefined 可以用以下代码，这样的话在标准下和非标准下都可以正常。 if ( oUl.firstElementChild ) { oUl.firstElementChild.style.background = &apos;red&apos;; //在标准浏览器下 } else { oUl.firstChild.style.background = &apos;red&apos;; //在非标准ie下 } 简化这段代码： var oFirst=oUl.firstElementChild || oUl.firstChild; if(oFirst){ oFirst.style.background=&apos;red&apos;; }else{ alert(&apos;没有子节点可以设置&apos;); } 元素.lastChild || 元素.lastElementChild元素.lastChild || 元素.lastElementChild:最后一个子节点 var oLast=oUl.lastElementChild || oUl.lastChild; if(oLast){ oLast.style.background=&apos;yellow&apos;; }else{ alert(&apos;没有子节点可以设置&apos;); } 元素.nextSibling || 元素.nextElementSibling元素.nextSibling || 元素.nextElementSibling:下一个兄弟节点 var oNext=oFirst.nextElementSibling || oFirst.nextSibling; oNext.style.background=&apos;blue&apos;; 元素.previousSibling || 元素.previousElementSibling元素.previousSibling || 元素.previousElementSibling：上一个兄弟节点 var oPrev=oLast.previousElementSibling || oLast.previousSibling; oPrev.style.background=&apos;orange&apos;;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>DOM</tag>
        <tag>js</tag>
        <tag>子节点和兄弟节点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM之childNodes]]></title>
    <url>%2F2018%2F02%2F21%2FDOM%E4%B9%8BchildNodes%2F</url>
    <content type="text"><![CDATA[写在前面的话：工作当中不太推荐使用childNodes，兼容性问题比较多。推荐使用childrenDOM是javascript操作网页的接口，全称为文档对象模型（Document Object Model）。它的作用是将网页转为一个JavaScript对象，从而可以使用JavaScript对网页进行各种操作（比如增删内容）。浏览器会根据DOM模型，将HTML文档解析成一系列的节点，再由这些节点组成一个树状结构。DOM的最小组成单位叫做节点（node），文档的树形结构由12种类型的节点组成。 小结：一般地，节点至少拥有nodeType、nodeName和nodeValue这三个基本属性。节点类型不同，三个属性的值也不相同。 childNodes 子节点元素.childNodes为子节点列表集合（只读），注意childNodes只包含一级子节点，不包含后辈孙级以下的节点。 nodeType 节点类型nodeType属性返回节点类型的常数值(无符号短整型)。不同的类型对应不同的常数值，12种类型分别对应12种不同的常数值 节点类型 名称 对应的常数值 元素节点 Node.ELEMENT_NODE 1 属性节点 Node.ATTRIBUTE_NODE 2 文本节点 Node.TEXT_NODE 3 CDATA节点 Node.CDATA_SECTION_NODE 4 实体引用名称节点 Node.ENTRY_REFERENCE_NODE 5 实体名称节点 Node.ENTITY_NODE 6 处理指令节点 Node.PROCESSING_INSTRUCTION_NODE 7 注释节点 Node.COMMENT_NODE 8 文档节点 Node.DOCUMENT_NODE 9 文档类型节点 Node.DOCUMENT_TYPE_NODE 10 文档片段节点 Node.DOCUMENT_FRAGMENT_NODE 11 DTD声明节点 Node.NOTATION_NODE 12 元素节点和文本节点下面这段代码在标准的ie下面显示是9个节点，在非标准的ie下显示4个节点。1234567891011121314151617181920212223&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;&lt;/title&gt;&lt;script&gt;window.onload = function() &#123; var oUl = document.getElementById('ul1'); alert( oUl.childNodes.length ); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 这是因为在标准ie下包含了文本和元素类型的节点，也会包含非法嵌套的节点。而在非标准的浏览器下，只包含元素类型的节点，ie7以下不会包含非法嵌套的节点。所以在这个例子中，在标准浏览器下，会把标签元素之间的回车换行符当作文本类型的节点（有5个）+4个元素节点，合起来就是9个；在非标准下只有4个元素节点。如果删掉其中的一个回车换行符，则会在标准浏览器下减少一个节点。区分了这一点，再看下面这个例子： for (var i=0; i&lt;oUl.childNodes.length; i++) { oUl.childNodes[i].style.background = &apos;red&apos;; } 如果要循环当前oUl下的所有的子节点列表，给所有子节点加上一个背景色。则在非标准的ie下可以很正常地显示：而在标准ie下，会显示出错。这是因为回车换行符被当作文本节点，所以第0个子节点其实是一个文本，文本是没有style也没有background的属性的。 这里我们可以添加以下代码来验证第0个元素的节点类型: alert(oUl.childNodes[0].nodeType); 在标准ie下，显示3，说明第0个元素是文本节点。而在非标准ie下显示1，说明第0个节点是元素节点： 属性节点元素.attributes用来获取当前的属性（只读，属性列表集合) alert( oUl.attributes.length );获取并显示元素属性个数 alert(oUl.attributes[1].value);显示属性值 children工作中推荐使用children，只读属性，子节点列表集合。和child差不多，有一点区别就是： &lt;body&gt; &lt;ul id=&quot;ul1&quot; &gt; &lt;li&gt;11111 &lt;span&gt;span&lt;/span&gt;&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;p&gt;pppppppp&lt;/p&gt; &lt;/ul&gt; &lt;/body&gt; 上述这段代码，在标准ie下，显示的children.length为5，可以看出使用children的时候不会再把文本节点算进去了，但是把非法嵌套的P也包括进去了 而在非标准ie下，显示的children.length为4，这是因为p没有算进去，不认这种非法嵌套。]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XHTML+CSS2笔记1]]></title>
    <url>%2F2018%2F02%2F20%2FXHTML-CSS2%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[H5标签兼容性解决方案]]></title>
    <url>%2F2018%2F02%2F20%2FH5%E6%A0%87%E7%AD%BE%E5%85%BC%E5%AE%B9%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[H5的语义化标签以及属性，可以让开发者非常方便地实现清晰的web页面布局，加上css3的效果渲染，快速建立web页面就容易多了。H5的新增标签有：http://www.w3school.com.cn/html5/html5_reference.asp使用这些标签可以使代码语义化更加直观，而且更方便seo优化，但是H5新标签在ie6/7/8上并不能识别，这里使用JavaScript来解决兼容性问题。一、原理说明 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; header &#123; width: 200px; height: 200px; background-color: red; &#125; section &#123; width: 150px; height: 150px; background-color: yellow; &#125; footer &#123; width: 100px; height: 100px; background-color: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;header&lt;/header&gt; &lt;section&gt;section&lt;/section&gt; &lt;footer&gt;footer&lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; 例如上面这段代使用了header、section、footer标签，这几个H5的标签在ie7浏览器下打开是这个样子的: 这是因为这几个H5的标签在ie以下的浏览器并不兼容，所以显示不出来样式。解决方法：用js来自定义这三个H5标签，但是因为自定义标签默认为内联样式（不支持宽高的设置，靠内容充满),所以看到的如下所示:12345&lt;script type="text/javascript"&gt;document.createElement("header"); document.createElement("section");document.createElement("footer");&lt;/script&gt; 如果要以块级元素显示，显示宽高，则在每个样式里面添加代码display：block; 二、解决方案1:引用js成熟的库–html5shiv.js在之间直接添加以下代码: &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt; 或者直接添加: &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt; 三、解决方案2：自己coding js &lt;script&gt; (function() { if (! /*@cc_on!@*/ 0) return; var e = “abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video”.split(‘, ‘); var i= e.length; while (i–){ document.createElement(e[i]) } })() &lt;/script&gt; 不管你用上面哪种方式，请记得在CSS中进行如下定义，目的是让这些标签成为块状元素，just like div。 /*html5*/ article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>H5标签</tag>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你github+hexo搭建博客（基础篇）]]></title>
    <url>%2F2018%2F02%2F14%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[(更新)hexo+github博客搭建进阶指南]]></title>
    <url>%2F2018%2F02%2F13%2Fgithub-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[[TOC] 在右上角或者左上角实现fork me on github点击 这里 或者 这里选择自己喜欢的样式，并复制相应的代码。然后复制代码到themes/next/layout/_layout.swig文件中，放置在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面，并把href改为你的GitHub地址。 添加RSS 切换到你博客文件夹的根目录下，然后在git bash里面输入以下代码，安装模块 npm install --save hexo-generator-feed 然后打开站点配置文件，在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！) #3、添加动态背景实现点击出现桃心效果 修改文章内链接文本样式修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记修改作者头像并旋转博文压缩修改“代码块自定义样式侧边栏社交小图标设置主页文章添加阴影效果在网站底部加上访问量添加热度网站底部字数统计添加 README.md 文件设置网站的图标Favicon实现统计功能添加顶部加载条在文章底部增加版权信息添加网易云跟帖(跟帖关闭，已失效，改为来必力)隐藏网页底部powered By Hexo / 强力驱动修改网页底部的桃心文章加密访问添加jiathis分享博文置顶修改字体大小修改打赏字体不闪动自定义鼠标样式为博客加上萌萌的宠物DaoVoice 在线联系点击爆炸效果]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>github</tag>
        <tag>hxo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青蛙旅行破解版]]></title>
    <url>%2F2018%2F02%2F13%2Fqingwa%2F</url>
    <content type="text"><![CDATA[链接 密码 gggg hhhhhhhhhhhhh aaaaaaaaaaaaaa aadddddddddddddd rrrrrrrrrrrrrrrrrr ggggggggggggggggg]]></content>
      <categories>
        <category>android</category>
        <category>逆向</category>
        <category>破解</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>破解</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九大排序算法总结]]></title>
    <url>%2F2018%2F02%2F13%2Fercha%2F</url>
    <content type="text"><![CDATA[主要有以下32种： 在右上角或者左上角实现fork me on github添加RSS添加动态背景实现点击出现桃心效果修改文章内链接文本样式修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记修改作者头像并旋转博文压缩修改“代码块自定义样式侧边栏社交小图标设置主页文章添加阴影效果在网站底部加上访问量添加热度网站底部字数统计添加 README.md 文件设置网站的图标Favicon实现统计功能添加顶部加载条在文章底部增加版权信息添加网易云跟帖(跟帖关闭，已失效，改为来必力)隐藏网页底部powered By Hexo / 强力驱动修改网页底部的桃心文章加密访问添加jiathis分享博文置顶修改字体大小修改打赏字体不闪动自定义鼠标样式为博客加上萌萌的宠物DaoVoice 在线联系点击爆炸效果]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM浅谈]]></title>
    <url>%2F2018%2F02%2F02%2FDOM%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[先附上一个DOM的教程：http://www.w3school.com.cn/htmldom/dom_methods.asp DOM的结构实际上和数据结构里面的树非常相似 方法 描述getElementById() 返回带有指定 ID 的元素。getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。appendChild() 把新的子节点添加到指定节点。removeChild() 删除子节点。replaceChild() 替换子节点。insertBefore() 在指定的子节点前面插入新的子节点。createAttribute() 创建属性节点。createElement() 创建元素节点。createTextNode() 创建文本节点。getAttribute() 返回指定的属性值。setAttribute() 把指定属性设置或修改为指定的值。 ·其他细节修改Copyright：isabllezhou mail:isabellezhou@163.com]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
</search>
