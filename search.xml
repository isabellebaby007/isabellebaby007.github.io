<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>js属性操作</title>
      <link href="/2018/02/24/js%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C/"/>
      <content type="html"><![CDATA[<h3 id="HTML的属性操作：读、写"><a href="#HTML的属性操作：读、写" class="headerlink" title="HTML的属性操作：读、写"></a>HTML的属性操作：读、写</h3><p>属性：属性名+属性值。  </p><h4 id="属性的读操作"><a href="#属性的读操作" class="headerlink" title="属性的读操作"></a>属性的读操作</h4><p>读操作：获取、找到。元素.属性名 <a id="more"></a> </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;    window.onload = function() {        var oBtn = document.getElementById(&apos;btn1&apos;);        var oText = document.getElementById(&apos;text1&apos;);        var oSelect = document.getElementById(&apos;select1&apos;);        oBtn.onclick = function() {            alert(oText.value + &apos;在&apos; + oSelect.value);        }    }    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type=&quot;text&quot; id=&quot;text1&quot; /&gt;    &lt;select id=&quot;select1&quot;&gt;        &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt;        &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;        &lt;option value=&quot;杭州&quot;&gt;杭州&lt;/option&gt;    &lt;/select&gt;    &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;按钮&quot; /&gt;&lt;/body&gt;&lt;/html&gt;  </code></pre><p><img src="/2018/02/24/js属性操作/ducaozuo.png" alt="">  </p><h4 id="属性的写操作"><a href="#属性的写操作" class="headerlink" title="属性的写操作"></a>属性的写操作</h4><p>(添加)替换、修改。元素.属性名=新的值。  </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;    window.onload = function() {        var oBtn = document.getElementById(&apos;btn1&apos;);        var oText = document.getElementById(&apos;text1&apos;);        var oSelect = document.getElementById(&apos;select1&apos;);        oBtn.onclick = function() {            //oBtn.value=&apos;button&apos;;            //oText.value=&apos;按钮&apos;;            oText.value=oSelect.value;        }    }    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type=&quot;text&quot; id=&quot;text1&quot; /&gt;    &lt;select id=&quot;select1&quot;&gt;        &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt;        &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;        &lt;option value=&quot;杭州&quot;&gt;杭州&lt;/option&gt;    &lt;/select&gt;    &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;按钮&quot; /&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="读写操作结合的例子"><a href="#读写操作结合的例子" class="headerlink" title="读写操作结合的例子"></a>读写操作结合的例子</h4><p>在文本框中输入图片地址，点击按钮切换图片。  </p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;    &lt;title&gt;无标题文档&lt;/title&gt;    &lt;script&gt;    window.onload = function() {        var oBtn = document.getElementById(&apos;btn1&apos;);        var oText = document.getElementById(&apos;text1&apos;);        var oImg = document.getElementById(&apos;img1&apos;);        oBtn.onclick = function() {            oImg.src = oText.value;        };    };    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;input id=&quot;text1&quot; type=&quot;text&quot; /&gt;    &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;按钮&quot; /&gt;    &lt;p id=&quot;p1&quot;&gt;这是一些文字&lt;/p&gt;    &lt;img id=&quot;img1&quot; src=&quot;img/1.jpg&quot; width=&quot;200&quot; /&gt;&lt;/body&gt;&lt;/html&gt;  </code></pre><p><img src="/2018/02/24/js属性操作/duxie.png" alt="">  </p><h4 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h4><p>元素.innerHTML:可以读取元素内的所有HTML代码。元素.innerHTML=新的值：修改或者替换元素内的所有HTML内容。  </p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;    &lt;title&gt;无标题文档&lt;/title&gt;    &lt;script&gt;    window.onload = function() {        var oBtn = document.getElementById(&apos;btn1&apos;);        var oText = document.getElementById(&apos;text1&apos;);        var oP = document.getElementById(&apos;p1&apos;);        oBtn.onclick = function() {            // oImg.src = oText.value;            // alert( oP.innerHTML );            oP.innerHTML = oText.value;        };    };    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;input id=&quot;text1&quot; type=&quot;text&quot; /&gt;    &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;按钮&quot; /&gt;    &lt;p id=&quot;p1&quot;&gt;这是一些文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;  </code></pre><p><img src="/2018/02/24/js属性操作/inner1.png" alt="">  </p><p><img src="/2018/02/24/js属性操作/inner2.png" alt=""> </p><h4 id="例子-属性读写操作配合innerHTML"><a href="#例子-属性读写操作配合innerHTML" class="headerlink" title="例子:属性读写操作配合innerHTML"></a>例子:属性读写操作配合innerHTML</h4><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt;#div1 { width:240px; height:200px; border:1px solid #333; background:#f1f1f1; padding:10px; }&lt;/style&gt;&lt;script&gt;window.onload = function (){    var oDiv = document.getElementById(&apos;div1&apos;);    var oStrong = document.getElementById(&apos;strong1&apos;);    var oText = document.getElementById(&apos;text1&apos;);    var oBtn = document.getElementById(&apos;btn1&apos;);    oBtn.onclick = function (){        // 原来的内容，你得给我留着，然后再加上新内容        // a = a + b        // a += b        // 添加：+=        // oDiv.innerHTML = oDiv.innerHTML + oText.value + &apos;&lt;br /&gt;&apos;;        oDiv.innerHTML += oStrong.innerHTML + oText.value + &apos;&lt;br /&gt;&apos;;        oText.value = &apos;&apos;;    };};&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;strong id=&quot;strong1&quot;&gt;张三：&lt;/strong&gt;&lt;input id=&quot;text1&quot; type=&quot;text&quot; /&gt;&lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;提交&quot; /&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="属性操作注意事项"><a href="#属性操作注意事项" class="headerlink" title="属性操作注意事项"></a>属性操作注意事项</h3>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
            <tag> 属性操作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端利器——6款开源web性能优化辅助工具</title>
      <link href="/2018/02/23/%E5%89%8D%E7%AB%AF%E5%88%A9%E5%99%A8%E2%80%94%E2%80%946%E6%AC%BE%E5%BC%80%E6%BA%90web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
      <content type="html"><![CDATA[<p>Web 性能优化是一个老生常谈的话题，也是前端页面开发十分重要的部分。当页面加载速度越慢，用户流失的概率就越大，性能和交互直接影响用户体验。<br>下面推荐几款 Web 性能优化辅助工具推荐，希望能对大家有所帮助  </p><h4 id="Lighthouse"><a href="#Lighthouse" class="headerlink" title="Lighthouse"></a>Lighthouse</h4><p>Lighthouse 是 Google 开源的一个自动化工具，用于改进网络应用的质量。你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。<a id="more"></a></p><p>当为 Lighthouse 提供一个要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。可以参考失败的测试，看看可以采取哪些措施来改进应用。  </p><p>Chrom 扩展则会把报告以非常人性化的图形界面展示给你。  </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibxYFwdzvMX2PbAak3hgHs2obIJxZ8fTqE62hRcCdHgxY1BlKl4OWIVg29ZoGKcxrprlRKa2ZYuTw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">  </p><p>传送门：www.oschina.net/p/lighthouse  </p><h4 id="Speed-Racer"><a href="#Speed-Racer" class="headerlink" title="Speed Racer"></a>Speed Racer</h4><p>SpeedRacer 是一款性能测试工具，它在 Chrome 中运行脚本，并生成详细的性能报告。  </p><p>SpeedRacer 是直接借助浏览器来实际测试性能的工具，在实际工作中，可以与其它模拟用户访问流量来评估性能的工具配合使用。  </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibxYFwdzvMX2PbAak3hgHs2eMnibRGSmDBZzwtrTNFU1Z27c4rDA418r3wHc9maibAQk4tc0DIbn2Tw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">  </p><p>传送门：<a href="https://github.com/speedracer/speedracer" target="_blank" rel="noopener">https://github.com/speedracer/speedracer</a>  </p><h4 id="Yellow-Lab-Tools"><a href="#Yellow-Lab-Tools" class="headerlink" title="Yellow Lab Tools"></a>Yellow Lab Tools</h4><p>Yellow Lab Tools 是一款 Web 性能及前端质量测试工具。与其他工具不同的是，它有一些在其他工具上无法看到的独特功能，例如页面加载时 JavaScript 与 DOM 互动和其他程序代码验证问题。  </p><p>Yellow Lab Tools 偏向于一个发现不良实践的工具，会综合页面权重、请求数、DOM、错误的 Javascript、错误的 CSS 等方面取得一个评分。并显示出在加载页面的过程中，DOM 是如何相互影响。  </p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/dkwuWwLoRKibxYFwdzvMX2PbAak3hgHs2wdjqX4Cr8gd0UL3aWnibQ9udHSaRPKqmfBU5GWCbajXgsficudj9r8fw/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">  </p><p>传送门：<a href="https://yellowlab.tools/" target="_blank" rel="noopener">https://yellowlab.tools/</a>  </p><h4 id="Web-Tracing-Framework"><a href="#Web-Tracing-Framework" class="headerlink" title="Web Tracing Framework"></a>Web Tracing Framework</h4><p>Web Tracing Framework 也是 Google 推出的一组用于跟踪和调查复杂 Web 应用的库、工具和可视化工具合集。它可以帮助发现性能问题，跟踪回归，并构建流畅的 60fps Web 应用。能让你花更少时间来测试代码即可。  </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibxYFwdzvMX2PbAak3hgHs2icIN99tX5dFXPcs2NmJQ4ROCULaPdjgMTYDHweH8gVNiaX1d1vKwtGJA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">  </p><p>传送门：www.oschina.net/p/tracing-framework  </p><h4 id="grunt-perfbudget"><a href="#grunt-perfbudget" class="headerlink" title="grunt-perfbudget"></a>grunt-perfbudget</h4><p>grunt-perfbudget 是一款用于评估性能的 Grunt task，它使用 WebPagetest 的公有或私有实例在特定的 URL 进行测试，并将测试结果和你预期的性能期望做比较。  </p><p>如果小于预期，那么这个 task 就顺利完成了，如果超过了预期的性能期望，那么就会报告失败，并帮助你分析超出预期的原因。  </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibxYFwdzvMX2PbAak3hgHs2DLSNAsryvtbApayL9uM19YD0vVxZqY5mQC8ibEoZIUicHQUmGuZ1QEBQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">  </p><p>传送门：<a href="https://github.com/tkadlec/grunt-perfbudget" target="_blank" rel="noopener">https://github.com/tkadlec/grunt-perfbudget</a>  </p><h4 id="Sitespeed-io"><a href="#Sitespeed-io" class="headerlink" title="Sitespeed.io"></a>Sitespeed.io</h4><p>Sitespeed.io 是一组基于最佳实践以及一些加载时序等量化标准的开源工具，用以帮助开发者分析网页的加载速度和渲染性能。  </p><p>Sitespeed.io 从开发者的站点收集多个页面的数据，并根据最佳实践等规则来分析这些网页，然后将结果以 HTML 的形式输出，或者以数值的形式发送到 Graphite 。  </p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRKibxYFwdzvMX2PbAak3hgHs2mPUS1BvN0PF6ZVDVdicvM6HoQ6bjquP4NFcc9ytYLtzZNO3yCOBg7kg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="">  </p><p>传送门：<a href="https://www-origin.sitespeed.io/" target="_blank" rel="noopener">https://www-origin.sitespeed.io/</a></p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> web性能 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>给博客添加feed</title>
      <link href="/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed/"/>
      <content type="html"><![CDATA[<p>安装hexo-generator-feed  </p><pre><code>$ npm install hexo-generator-feed --save  </code></pre><p>配置到站点配置文件_config.yml  <a id="more"></a></p><pre><code># Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20  </code></pre><p>最后，在你next主题下的_config.yml下，添加RSS订阅链接即可：  </p><pre><code>rss: /atom.xml</code></pre>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> feed </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>给博客添加站点地图</title>
      <link href="/2018/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE/"/>
      <content type="html"><![CDATA[<p>安装hexo-generator-seo-friendly-sitemap  </p><pre><code>$ npm install hexo-generator-seo-friendly-sitemap --save  </code></pre><p>在站点配置文件_config.yml中添加  </p><pre><code>sitemap:    path: sitemap.xml</code></pre>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> 站点地图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo添加站内搜索</title>
      <link href="/2018/02/23/hexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"/>
      <content type="html"><![CDATA[<p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。<a id="more"></a> </p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="安装hexo-generator-search"><a href="#安装hexo-generator-search" class="headerlink" title="安装hexo-generator-search"></a>安装hexo-generator-search</h4><p>在站点的根目录下执行：  </p><pre><code>$ npm install hexo-generator-search --save  </code></pre><h4 id="安装hexo-generator-searchdb"><a href="#安装hexo-generator-searchdb" class="headerlink" title="安装hexo-generator-searchdb"></a>安装hexo-generator-searchdb</h4><p>在站点的根目录下执行：  </p><pre><code>$ npm install hexo-generator-searchdb --save  </code></pre><h4 id="启用搜索"><a href="#启用搜索" class="headerlink" title="启用搜索"></a>启用搜索</h4><p>编辑站点配置文件，加入以下代码： </p><pre><code>search:  path: search.xml  field: post  format: html  limit: 10000</code></pre>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>元素各种位置宽高</title>
      <link href="/2018/02/23/%E5%85%83%E7%B4%A0%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%AE%BD%E9%AB%98/"/>
      <content type="html"><![CDATA[<h3 id="offsetLeft"><a href="#offsetLeft" class="headerlink" title="offsetLeft"></a>offsetLeft</h3><p>offsetLeft[Top]:只读，属性，当前元素到定位父级的距离（偏移值），就是到当前元素的offsetParent的距离。  </p><h4 id="当前元素没有定位，但是有定位父级"><a href="#当前元素没有定位，但是有定位父级" class="headerlink" title="当前元素没有定位，但是有定位父级"></a>当前元素没有定位，但是有定位父级</h4><p>css部分：  <a id="more"></a></p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;position: relative;}#div3 {background: orange; }&lt;/style&gt;  </code></pre><p>js部分：  </p><pre><code>window.onload = function() {    var oDiv3 = document.getElementById(&apos;div3&apos;);  alert( oDiv3.offsetLeft );    }  </code></pre><p>html部分:  </p><pre><code>&lt;body id=&quot;body1&quot;&gt;    &lt;div id=&quot;div1&quot;&gt;        &lt;div id=&quot;div2&quot;&gt;            &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;  </code></pre><p>上述代码在ie11和Ie7的效果如下两图所示，可以得出结论： 在ie7下，如果自己没有定位，那么offsetLeft[Top]是到body的距离。 所以会显示100px</p><p><img src="/2018/02/23/元素各种位置宽高/ie11标准.png" alt="">  </p><p><img src="/2018/02/23/元素各种位置宽高/ie7非标准.png" alt="">  </p><h4 id="当前元素有定位的情况，且定位父级"><a href="#当前元素有定位的情况，且定位父级" class="headerlink" title="当前元素有定位的情况，且定位父级"></a>当前元素有定位的情况，且定位父级</h4><p>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;position: relative;}#div3 {background: orange;position: relative; }&lt;/style&gt;  </code></pre><p>其余部分代码同上个例子。ie11的效果同上个例子，但是Ie7的效果发生了变化，当前元素有定位的情况下，是到定位父级的距离。</p><p><img src="/2018/02/23/元素各种位置宽高/有定位.png" alt="">  </p><h4 id="当前元素有定位，但是没有定位父级"><a href="#当前元素有定位，但是没有定位父级" class="headerlink" title="当前元素有定位，但是没有定位父级"></a>当前元素有定位，但是没有定位父级</h4><p>当前元素如果没有定位父级，offsetLeft默认的情况下是到body的，但是在Ie7下是指向到html的(在ie7以下body的默认margin-left值是10px)。<br>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;}#div3 {background: orange;position: relative; }&lt;/style&gt;  </code></pre><p>其余部分代码同例子一。  </p><p><img src="/2018/02/23/元素各种位置宽高/108.png" alt="">  </p><p><img src="/2018/02/23/元素各种位置宽高/110.png" alt="">  </p><h3 id="offsetTop"><a href="#offsetTop" class="headerlink" title="offsetTop"></a>offsetTop</h3><p>css部分：  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green;}#div3 {background: orange;position: relative; }&lt;/style&gt;  </code></pre><p>js部分:  </p><pre><code>window.onload = function() {    var oDiv3 = document.getElementById(&apos;div3&apos;);  alert( oDiv3.offsetLeft );    }  </code></pre><p>效果如下,得出结论：ie7下的html默认margin-top是15px</p><p><img src="/2018/02/23/元素各种位置宽高/88.png" alt=""> </p><p><img src="/2018/02/23/元素各种位置宽高/95.png" alt=""> </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果有定位父级：<br>ie7以下：如果自己没有定位，那么offsetLeft[Top]是到body的距离；<br>如果自己有定位，那么就是到定位父级的距离。<br>其他浏览器：到定位父级的距离。  </p><h3 id="元素宽高"><a href="#元素宽高" class="headerlink" title="元素宽高"></a>元素宽高</h3><p>html部分：  </p><pre><code>&lt;body&gt;    &lt;div id=&quot;div1&quot; style=&quot;width: 100px; height: 100px; border: 1px solid red; padding: 10px; margin: 10px;&quot;&gt;&lt;/div&gt;&lt;/body&gt;  </code></pre><p>js部分:  </p><pre><code>&lt;script&gt;window.onload = function() {    var oDiv = document.getElementById(&apos;div1&apos;);alert( oDiv.style.width );    //样式宽100alert( oDiv.clientWidth );    //样式宽 + padding=可视区宽    120alert( oDiv.offsetWidth );    //样式宽 + padding + border  可视区宽 + 边框    122    }  &lt;script&gt;  </code></pre><p>得到三个宽度分别为:  </p><p><img src="/2018/02/23/元素各种位置宽高/宽高1.png" alt="">  </p><p><img src="/2018/02/23/元素各种位置宽高/宽高2.png" alt="">  </p><p><img src="/2018/02/23/元素各种位置宽高/宽高3.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
          <category> DOM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> DOM </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>父节点</title>
      <link href="/2018/02/22/%E7%88%B6%E8%8A%82%E7%82%B9/"/>
      <content type="html"><![CDATA[<h3 id="元素-parentNode"><a href="#元素-parentNode" class="headerlink" title="元素.parentNode"></a>元素.parentNode</h3><p>元素.parentNode:只读，属性，当前节点的父级节点，一个元素的父节点只有一个。在标准下和非标准下都可以，没有什么兼容问题。<br>js部分： </p><pre><code>window.onload = function() {var oDiv3 = document.getElementById(&apos;div3&apos;);alert( oDiv3.parentNode.id );}  </code></pre><p><a id="more"></a>html部分：  </p><pre><code>body id=&quot;body1&quot;&gt;    &lt;div id=&quot;div1&quot;&gt;        &lt;div id=&quot;div2&quot;&gt;            &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><p>在标准ie和非标准ie下，div3的父级都是div2，没有什么兼容性问题。<br><img src="/2018/02/22/父节点/标准.jpg" alt=""><br><img src="/2018/02/22/父节点/非标准.jpg" alt=""></p><h3 id="元素-offsetParent"><a href="#元素-offsetParent" class="headerlink" title="元素.offsetParent"></a>元素.offsetParent</h3><p>元素.offsetParent:只读，属性，有定位的父节点。如果多个父节点有定位，就是离它最近的有定位的父节点。如果没有定位父级，默认是body。   </p><h4 id="没有定位父级的例子"><a href="#没有定位父级的例子" class="headerlink" title="没有定位父级的例子"></a>没有定位父级的例子</h4><p>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green; zoom: 1;}#div3 {background: orange;}&lt;/style&gt;  </code></pre><p>js部分：  </p><pre><code>&lt;script&gt;window.onload = function() {        var oDiv3 = document.getElementById(&apos;div3&apos;);    alert( oDiv3.offsetParent );    }  </code></pre><p>html部分：  </p><pre><code>&lt;body id=&quot;body1&quot;&gt;    &lt;div id=&quot;div1&quot;&gt;        &lt;div id=&quot;div2&quot;&gt;            &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><p><img src="/2018/02/22/父节点/offset.jpg" alt=""></p><h4 id="加了定位属性的例子"><a href="#加了定位属性的例子" class="headerlink" title="加了定位属性的例子"></a>加了定位属性的例子</h4><p>css部分:  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green; zoom: 1;position: relative;}#div3 {background: orange;}&lt;/style&gt;  </code></pre><p>js部分： </p><pre><code>window.onload = function() {        var oDiv3 = document.getElementById(&apos;div3&apos;);    alert( oDiv3.offsetParent.id );    }  </code></pre><p>展示效果如下，可以看出，div2加了定位属性之后，div3的offsetParent就变成了div2,而不是body了。  </p><p><img src="/2018/02/22/父节点/定位.jpg" alt="">  </p><h4 id="ie7以下，当前元素有定位例子"><a href="#ie7以下，当前元素有定位例子" class="headerlink" title="ie7以下，当前元素有定位例子"></a>ie7以下，当前元素有定位例子</h4><p>ie7以下，如果当前元素没有定位默认是body，如果有定位则是html.<br>css部分：</p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green; zoom: 1;}#div3 {background: orange;position: relative;}&lt;/style&gt;  </code></pre><p>js部分：  </p><pre><code>window.onload = function() {            var oDiv3 = document.getElementById(&apos;div3&apos;);        alert( oDiv3.offsetParent.tagName );        }    </code></pre><p>在ie11的效果如下图：  </p><p><img src="/2018/02/22/父节点/body.png" alt="">  </p><p>在ie7及以下的效果如下图:  </p><p><img src="/2018/02/22/父节点/html.png" alt="">  </p><h4 id="ie7以下，当前元素某个父级触发layout"><a href="#ie7以下，当前元素某个父级触发layout" class="headerlink" title="ie7以下，当前元素某个父级触发layout"></a>ie7以下，当前元素某个父级触发layout</h4><p>ie7以下，如果当前元素的某个父级触发了layout，那么offsetParent就会指向到触发了layout特性的父节点上。<br>css部分：  </p><pre><code>&lt;style&gt;div {padding: 40px 50px;}#div1 {background: red;}#div2 {background: green; zoom: 1;}#div3 {background: orange;}&lt;/style&gt;</code></pre><p>js部分：  </p><pre><code>window.onload = function() {                            alert( oDiv3.offsetParent.id);        }  </code></pre><p>效果如下所示，因为div2有zoom属性，zoom触发了layout,所以div3的offsetParent是触发了layout特性的父节点div2  </p><p><img src="/2018/02/22/父节点/layout.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
            <tag> 父节点 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>子节点和兄弟节点的操作</title>
      <link href="/2018/02/21/%E5%AD%90%E8%8A%82%E7%82%B9%E5%92%8C%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <content type="html"><![CDATA[<h3 id="元素-firstChild"><a href="#元素-firstChild" class="headerlink" title="元素.firstChild"></a>元素.firstChild</h3><p>元素.firstChild:只读，属性，第一个子节点  </p><pre><code>&lt;body&gt;    &lt;ul id=&quot;ul1&quot;&gt;        &lt;li&gt;11111&lt;/li&gt;        &lt;li&gt;22222&lt;/li&gt;        &lt;li&gt;33333&lt;/li&gt;        &lt;li&gt;44444&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;  </code></pre><p>添加下列代码来显示第一个子节点  <a id="more"></a> 下图说明在标准ie浏览器下:firstChild会包含文本类型的节点；在非标准的ie下：只包含元素节点</p><pre><code>alert( oUl.firstChild );  </code></pre><p><img src="/2018/02/21/子节点和兄弟节点的操作/firstChild.png" alt="">  </p><p><img src="/2018/02/21/子节点和兄弟节点的操作/firstChild非标准.png" alt="">  </p><h3 id="元素-firstElementChild"><a href="#元素-firstElementChild" class="headerlink" title="元素.firstElementChild"></a>元素.firstElementChild</h3><p>元素.firstElementChild:只读，属性，标准下获取第一个元素类型的子节点（所以在非标准的ie下是不支持这个属性的),所以非标准下会输出下图所示undefined </p><p><img src="/2018/02/21/子节点和兄弟节点的操作/非标准firstele.png" alt=""><br>可以用以下代码，这样的话在标准下和非标准下都可以正常。</p><pre><code>if ( oUl.firstElementChild ) {     oUl.firstElementChild.style.background = &apos;red&apos;; //在标准浏览器下 } else {     oUl.firstChild.style.background = &apos;red&apos;;   //在非标准ie下 }  </code></pre><p>简化这段代码：  </p><pre><code>var oFirst=oUl.firstElementChild || oUl.firstChild;if(oFirst){    oFirst.style.background=&apos;red&apos;;}else{    alert(&apos;没有子节点可以设置&apos;);    }  </code></pre><h3 id="元素-lastChild-元素-lastElementChild"><a href="#元素-lastChild-元素-lastElementChild" class="headerlink" title="元素.lastChild || 元素.lastElementChild"></a>元素.lastChild || 元素.lastElementChild</h3><p>元素.lastChild || 元素.lastElementChild:最后一个子节点  </p><pre><code>var oLast=oUl.lastElementChild || oUl.lastChild;if(oLast){    oLast.style.background=&apos;yellow&apos;;}else{    alert(&apos;没有子节点可以设置&apos;);    }  </code></pre><h3 id="元素-nextSibling-元素-nextElementSibling"><a href="#元素-nextSibling-元素-nextElementSibling" class="headerlink" title="元素.nextSibling || 元素.nextElementSibling"></a>元素.nextSibling || 元素.nextElementSibling</h3><p>元素.nextSibling || 元素.nextElementSibling:下一个兄弟节点  </p><pre><code>var oNext=oFirst.nextElementSibling || oFirst.nextSibling;  oNext.style.background=&apos;blue&apos;;  </code></pre><h3 id="元素-previousSibling-元素-previousElementSibling"><a href="#元素-previousSibling-元素-previousElementSibling" class="headerlink" title="元素.previousSibling || 元素.previousElementSibling"></a>元素.previousSibling || 元素.previousElementSibling</h3><p>元素.previousSibling || 元素.previousElementSibling：上一个兄弟节点  </p><pre><code>var oPrev=oLast.previousElementSibling || oLast.previousSibling;  oPrev.style.background=&apos;orange&apos;;</code></pre>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> DOM </tag>
            
            <tag> 前端 </tag>
            
            <tag> 子节点和兄弟节点 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DOM之childNodes</title>
      <link href="/2018/02/21/DOM%E4%B9%8BchildNodes/"/>
      <content type="html"><![CDATA[<p>写在前面的话：工作当中不太推荐使用childNodes，兼容性问题比较多。推荐使用children<br>DOM是javascript操作网页的接口，全称为文档对象模型（Document Object Model）。它的作用是将网页转为一个JavaScript对象，从而可以使用JavaScript对网页进行各种操作（比如增删内容）。浏览器会根据DOM模型，将HTML文档解析成一系列的节点，再由这些节点组成一个树状结构。DOM的最小组成单位叫做节点（node），文档的树形结构由12种类型的节点组成。 <a id="more"></a><br>小结：一般地，节点至少拥有nodeType、nodeName和nodeValue这三个基本属性。节点类型不同，三个属性的值也不相同。  </p><h3 id="childNodes-子节点"><a href="#childNodes-子节点" class="headerlink" title="childNodes 子节点"></a>childNodes 子节点</h3><p>元素.childNodes为子节点列表集合（只读），注意childNodes只包含一级子节点，不包含后辈孙级以下的节点。</p><h3 id="nodeType-节点类型"><a href="#nodeType-节点类型" class="headerlink" title="nodeType 节点类型"></a>nodeType 节点类型</h3><p>nodeType属性返回节点类型的常数值(无符号短整型)。不同的类型对应不同的常数值，12种类型分别对应12种不同的常数值  </p><table><thead><tr><th style="text-align:left">节点类型</th><th>名称</th><th style="text-align:center">对应的常数值</th></tr></thead><tbody><tr><td style="text-align:left">元素节点</td><td>Node.ELEMENT_NODE</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">属性节点</td><td>Node.ATTRIBUTE_NODE</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">文本节点</td><td>Node.TEXT_NODE</td><td style="text-align:center">3</td></tr><tr><td style="text-align:left">CDATA节点</td><td>Node.CDATA_SECTION_NODE</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">实体引用名称节点</td><td>Node.ENTRY_REFERENCE_NODE</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">实体名称节点</td><td>Node.ENTITY_NODE</td><td style="text-align:center">6</td></tr><tr><td style="text-align:left">处理指令节点</td><td>Node.PROCESSING_INSTRUCTION_NODE</td><td style="text-align:center">7</td></tr><tr><td style="text-align:left">注释节点</td><td>Node.COMMENT_NODE</td><td style="text-align:center">8</td></tr><tr><td style="text-align:left">文档节点</td><td>Node.DOCUMENT_NODE</td><td style="text-align:center">9</td></tr><tr><td style="text-align:left">文档类型节点</td><td>Node.DOCUMENT_TYPE_NODE</td><td style="text-align:center">10</td></tr><tr><td style="text-align:left">文档片段节点</td><td>Node.DOCUMENT_FRAGMENT_NODE</td><td style="text-align:center">11</td></tr><tr><td style="text-align:left">DTD声明节点</td><td>Node.NOTATION_NODE</td><td style="text-align:center">12  </td></tr></tbody></table><h3 id="元素节点和文本节点"><a href="#元素节点和文本节点" class="headerlink" title="元素节点和文本节点"></a>元素节点和文本节点</h3><p>下面这段代码在标准的ie下面显示是9个节点，在非标准的ie下显示4个节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.onload = function() &#123;</span><br><span class="line"></span><br><span class="line">var oUl = document.getElementById(&apos;ul1&apos;);</span><br><span class="line">alert( oUl.childNodes.length );</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul id=&quot;ul1&quot;&gt;</span><br><span class="line">        &lt;li&gt;11111&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;22222&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;33333&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;44444&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>这是因为在标准ie下包含了文本和元素类型的节点，也会包含非法嵌套的节点。而在非标准的浏览器下，只包含元素类型的节点，ie7以下不会包含非法嵌套的节点。所以在这个例子中，在标准浏览器下，会把标签元素之间的回车换行符当作文本类型的节点（有5个）+4个元素节点，合起来就是9个；在非标准下只有4个元素节点。如果删掉其中的一个回车换行符，则会在标准浏览器下减少一个节点。<br>区分了这一点，再看下面这个例子：  </p><pre><code>for (var i=0; i&lt;oUl.childNodes.length; i++) {            oUl.childNodes[i].style.background = &apos;red&apos;;        }</code></pre><p>如果要循环当前oUl下的所有的子节点列表，给所有子节点加上一个背景色。则在非标准的ie下可以很正常地显示：<br><img src="/2018/02/21/DOM之childNodes/非标准浏览器.jpg" alt="正常显示"><br>而在标准ie下，会显示出错。这是因为回车换行符被当作文本节点，所以第0个子节点其实是一个文本，文本是没有style也没有background的属性的。<br><img src="/2018/02/21/DOM之childNodes/标准ie.jpg" alt="正常显示"><br><img src="/2018/02/21/DOM之childNodes/出错.jpg" alt="正常显示"><br> 这里我们可以添加以下代码来验证第0个元素的节点类型: </p><pre><code>alert(oUl.childNodes[0].nodeType);</code></pre><p>在标准ie下，显示3，说明第0个元素是文本节点。而在非标准ie下显示1，说明第0个节点是元素节点：  </p><p><img src="/2018/02/21/DOM之childNodes/文本类型.jpg" alt=""></p><p><img src="/2018/02/21/DOM之childNodes/元素节点.jpg" alt="">  </p><h3 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h3><p>元素.attributes用来获取当前的属性（只读，属性列表集合)    </p><pre><code>alert( oUl.attributes.length );获取并显示元素属性个数alert(oUl.attributes[1].value);显示属性值</code></pre><h3 id="children"><a href="#children" class="headerlink" title="children"></a>children</h3><p>工作中推荐使用children，只读属性，子节点列表集合。和child差不多，有一点区别就是：  </p><pre><code>&lt;body&gt;    &lt;ul id=&quot;ul1&quot; &gt;        &lt;li&gt;11111 &lt;span&gt;span&lt;/span&gt;&lt;/li&gt;        &lt;li&gt;22222&lt;/li&gt;        &lt;li&gt;33333&lt;/li&gt;        &lt;li&gt;44444&lt;/li&gt;        &lt;p&gt;pppppppp&lt;/p&gt;    &lt;/ul&gt;&lt;/body&gt;</code></pre><p>上述这段代码，在标准ie下，显示的children.length为5，可以看出使用children的时候不会再把文本节点算进去了，但是把非法嵌套的P也包括进去了  </p><p><img src="/2018/02/21/DOM之childNodes/children.png" alt="">  </p><p><img src="/2018/02/21/DOM之childNodes/children标准结构.png" alt=""><br>而在非标准ie下，显示的children.length为4，这是因为p没有算进去，不认这种非法嵌套。<br><img src="/2018/02/21/DOM之childNodes/children1.png" alt="">  </p><p><img src="/2018/02/21/DOM之childNodes/children非标准结构.png" alt=""> </p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>XHTML+CSS2笔记1</title>
      <link href="/2018/02/20/XHTML-CSS2%E7%AC%94%E8%AE%B01/"/>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>H5标签兼容性解决方案</title>
      <link href="/2018/02/20/H5%E6%A0%87%E7%AD%BE%E5%85%BC%E5%AE%B9%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <content type="html"><![CDATA[<p>H5的语义化标签以及属性，可以让开发者非常方便地实现清晰的web页面布局，加上css3的效果渲染，快速建立web页面就容易多了。<br>H5的新增标签有：<a href="http://www.w3school.com.cn/html5/html5_reference.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/html5/html5_reference.asp</a><br>使用这些标签可以使代码语义化更加直观，而且更方便seo优化，但是H5新标签在ie6/7/8上并不能识别，这里使用JavaScript来解决兼容性问题。<br>一、原理说明  <a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;   </span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    header &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    section &#123;</span><br><span class="line">        width: 150px;</span><br><span class="line">        height: 150px;</span><br><span class="line">        background-color: yellow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    footer &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;header&gt;header&lt;/header&gt;</span><br><span class="line">    &lt;section&gt;section&lt;/section&gt;</span><br><span class="line">    &lt;footer&gt;footer&lt;/footer&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>例如上面这段代使用了header、section、footer标签，这几个H5的标签在ie7浏览器下打开是这个样子的:  </p><p><img src="/2018/02/20/H5标签兼容性解决方案/ie7.jpg" alt="不兼容"><br>这是因为这几个H5的标签在ie以下的浏览器并不兼容，所以显示不出来样式。解决方法：用js来自定义这三个H5标签，但是因为自定义标签默认为内联样式（不支持宽高的设置，靠内容充满),所以看到的如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">document.createElement(&quot;header&quot;); </span><br><span class="line">document.createElement(&quot;section&quot;);</span><br><span class="line">document.createElement(&quot;footer&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p> <img src="/2018/02/20/H5标签兼容性解决方案/js.jpg" alt="加js解决"><br> 如果要以块级元素显示，显示宽高，则在每个样式里面添加代码display：block;  </p><p>二、解决方案1:引用js成熟的库–html5shiv.js<br>在<head></head>之间直接添加以下代码:    </p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt; </code></pre><p>或者直接添加:  </p><pre><code>&lt;!--[if lt IE 9]&gt;&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;&lt;![endif]--&gt;  </code></pre><p>三、解决方案2：自己coding js  </p><pre><code>&lt;script&gt;    (function() {     if (!      /*@cc_on!@*/     0) return;     var e = “abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video”.split(‘, ‘);     var i= e.length;     while (i–){         document.createElement(e[i])     } })() &lt;/script&gt;</code></pre><p>不管你用上面哪种方式，请记得在CSS中进行如下定义，目的是让这些标签成为块状元素，just like div。  </p><pre><code>/*html5*/article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}  </code></pre>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> H5标签 </tag>
            
            <tag> 兼容 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你github+hexo搭建博客（基础篇）</title>
      <link href="/2018/02/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
      <content type="html"><![CDATA[<p><img src="/2018/02/14/手把手教你github-hexo搭建博客（基础篇）/github.jpg" alt="git"></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>(更新)hexo+github博客搭建进阶指南</title>
      <link href="/2018/02/13/github-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"/>
      <content type="html"><![CDATA[<p>[TOC]</p><h1 id="在右上角或者左上角实现fork-me-on-github"><a href="#在右上角或者左上角实现fork-me-on-github" class="headerlink" title="在右上角或者左上角实现fork me on github"></a>在右上角或者左上角实现fork me on github</h1><p>点击  <a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">这里</a>  或者 <a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">这里</a>选择自己喜欢的样式，并复制相应的代码。<br>然后复制代码到themes/next/layout/_layout.swig文件中，放置在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面，并把href改为你的GitHub地址。<br><img src="/2018/02/13/github-hexo博客搭建进阶指南/github+hexo博客搭建进阶指南/github.jpg" alt=""><br><a id="more"></a>    </p><h1 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h1><p><img src="/2018/02/13/github-hexo博客搭建进阶指南/github+hexo博客搭建进阶指南/rss.jpg" alt=""></p><p>切换到你博客文件夹的根目录下，然后在git bash里面输入以下代码，安装模块</p><p><code>npm install --save hexo-generator-feed</code></p><p>然后打开站点配置文件，在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！)</p><p>#3、添加动态背景<br>实现点击出现桃心效果</p><p>修改文章内链接文本样式<br>修改文章底部的那个带#号的标签<br>在每篇文章末尾统一添加“本文结束”标记<br>修改作者头像并旋转<br>博文压缩<br>修改“代码块自定义样式<br>侧边栏社交小图标设置<br>主页文章添加阴影效果<br>在网站底部加上访问量<br>添加热度<br>网站底部字数统计<br>添加 README.md 文件<br>设置网站的图标Favicon<br>实现统计功能<br>添加顶部加载条<br>在文章底部增加版权信息<br>添加网易云跟帖(跟帖关闭，已失效，改为来必力)<br>隐藏网页底部powered By Hexo / 强力驱动<br>修改网页底部的桃心<br>文章加密访问<br>添加jiathis分享<br>博文置顶<br>修改字体大小<br>修改打赏字体不闪动<br>自定义鼠标样式<br>为博客加上萌萌的宠物<br>DaoVoice 在线联系<br>点击爆炸效果</p>]]></content>
      
      <categories>
          
          <category> hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> github </tag>
            
            <tag> hxo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>九大排序算法总结</title>
      <link href="/2018/02/13/ercha/"/>
      <content type="html"><![CDATA[<pre><code>主要有以下32种：</code></pre><p>在右上角或者左上角实现fork me on github<br>添加RSS<br>添加动态背景<br>实现点击出现桃心效果<br><a id="more"></a><br>修改文章内链接文本样式<br>修改文章底部的那个带#号的标签<br>在每篇文章末尾统一添加“本文结束”标记<br>修改作者头像并旋转<br>博文压缩<br>修改“代码块自定义样式<br>侧边栏社交小图标设置<br>主页文章添加阴影效果<br>在网站底部加上访问量<br>添加热度<br>网站底部字数统计<br>添加 README.md 文件<br>设置网站的图标Favicon<br>实现统计功能<br>添加顶部加载条<br>在文章底部增加版权信息<br>添加网易云跟帖(跟帖关闭，已失效，改为来必力)<br>隐藏网页底部powered By Hexo / 强力驱动<br>修改网页底部的桃心<br>文章加密访问<br>添加jiathis分享<br>博文置顶<br>修改字体大小<br>修改打赏字体不闪动<br>自定义鼠标样式<br>为博客加上萌萌的宠物<br>DaoVoice 在线联系<br>点击爆炸效果</p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>青蛙旅行破解版</title>
      <link href="/2018/02/13/qingwa/"/>
      <content type="html"><![CDATA[<pre><code>链接    密码gggghhhhhhhhhhhhhaaaaaaaaaaaaaaaaddddddddddddddrrrrrrrrrrrrrrrrrrggggggggggggggggg</code></pre>]]></content>
      
      <categories>
          
          <category> android </category>
          
          <category> 逆向 </category>
          
          <category> 破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 破解 </tag>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DOM浅谈</title>
      <link href="/2018/02/02/DOM%E6%B5%85%E8%B0%88/"/>
      <content type="html"><![CDATA[<p>先附上一个DOM的教程：<a href="http://www.w3school.com.cn/htmldom/dom_methods.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/htmldom/dom_methods.asp</a></p><p>   DOM的结构实际上和数据结构里面的树非常相似</p><p>方法    描述<br>getElementById()    返回带有指定 ID 的元素。<br>getElementsByTagName()    返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。<br>getElementsByClassName()    返回包含带有指定类名的所有元素的节点列表。<br><a id="more"></a><br>appendChild()    把新的子节点添加到指定节点。<br>removeChild()    删除子节点。<br>replaceChild()    替换子节点。<br>insertBefore()    在指定的子节点前面插入新的子节点。<br>createAttribute()    创建属性节点。<br>createElement()    创建元素节点。<br>createTextNode()    创建文本节点。<br>getAttribute()    返回指定的属性值。<br>setAttribute()    把指定属性设置或修改为指定的值。</p><p>·其他细节修改<br>Copyright：isabllezhou mail:isabellezhou@163.com</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
