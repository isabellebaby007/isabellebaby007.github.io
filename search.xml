<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bootstrap]]></title>
    <url>%2F2018%2F03%2F13%2Fbootstrap%2F</url>
    <content type="text"><![CDATA[栅格系统概念：分12列 row col 分辨率阈值：768 992 1200 &lt;768 手机 768&lt; &lt;992 pad 992&lt; &lt;1200 中等屏幕 &gt;1200 大屏幕 容器 container-fluid 流体 container 固定 1170 970 750 auto 针对不同的分辨率有不同的尺寸 1234567891011121314151617181920212223242526&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;link rel="stylesheet" href="css/bootstrap.css"&gt;&lt;style&gt;.container&#123; width:1000px !important; border:1px #000 solid;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--&lt;div class="container-fluid"&gt; aaaaaaaaa&lt;/div&gt;--&gt;&lt;div class="container"&gt; aaaaaaaaa&lt;/div&gt;&lt;/body&gt;&lt;script src="js/jquery-1.11.1.js"&gt;&lt;/script&gt;&lt;script src="js/bootstrap.js"&gt;&lt;/script&gt;&lt;/html&gt; 语法 col-lg-* col-md-* col-sm-* col-xs-*]]></content>
      <categories>
        <category>前端</category>
        <category>框架</category>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>框架</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面向对象之组件开发]]></title>
    <url>%2F2018%2F03%2F13%2Fjs%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>js面向对象及组件开发</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象基础]]></title>
    <url>%2F2018%2F03%2F12%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[什么是面向对象用对象的思想去写程序，就是面向对象编程 -过程式写法 -面向对象写法 例如：数组Array时间Date 1234567891011var arr=new Array(); //系统自带的对象，叫做系统对象var date=new Date();arr.lengtharr.push();arr.sort();date.getDate();var t1=new Tab();t1.over();t1.autoPlay(); 面向对象编程（OOP）的特点 抽象 抓住核心问题 封装 只能通过对象来访问方法 继承 从已有对象上继承出新的对象 多态 多对象的不同形态 面向对象的基本写法何组成对象的组成方法（行为、操作）–函数：过程、动态的 属性-变量：状态、静态的 创建第一个面向对象程序对象下面的变量：叫做对象的属性 对象下面的函数：叫做对象的方法 为对象添加属性和方法 object对象 this指向 创建两个对象：重复代码过多 12345678910var arr=[];arr.number=10;arr.test=function()&#123; alert(123);&#125;;arr.test();arr.push();arr.sort(); 12345var obj=new object();//创建了一个空的对象obj.name='小明';obj.showName=function()&#123; alert(obj.name);&#125;; 工厂方式与构造函数1234567891011121314151617function createPerson(name)&#123; //原料 var obj =new Object(); //加工 obj.name=name; obj.showName=function()&#123; alert(this.name); &#125;; //出场 return obj;&#125;var p1=createPerson('小明');p1.showName();var p2=createPerson('小明');p2.showName(); 当new去调用一个函数：这个时候函数中的this就是创建出来的对象，而且函数的返回值直接就是this （隐式返回） 12345678910111213function CreatePerson(name)&#123; this.name=name; this.shortName=function()&#123; alert(this.name); &#125;; &#125;var p1=new CreatePerson('小明');p1.showName();var p2=CreatePerson('小明');p2.showName(); 对象引用是什么和它的问题1234567891011function CreatePerson(name)&#123; this.name=name; this.shortName=function()&#123; alert(this.name); &#125;;&#125;var p1=new CreatePerson('小强');var p2=new CreatePerson('小明');alert(p1.showName==p2.showName); //false 这里为什么会出现false? 原因：因为基本类型的比较，只要值相同就可以了；而对象类型的比较，值和引用都要相同才可以。p1.showName和p2.showName分别在不同的地址创建了对象，所以这里返回的是false。但是会造成很大的内存浪费 1234567891011121314151617181920212223242526var a = 5;var b = a;b += 3;alert(b); //8alert(a); //5 基本类型 : 赋值的时候只是值的复制var a = [1,2,3];var b = a;b.push(4);alert(b); //[1,2,3,4]alert(a); //[1,2,3,4] 对象类型 : 赋值不仅是值的复制，而且也是引用的传递//var a = [1,2,3];//var b = a;//b = [1,2,3,4];////alert(b); //[1,2,3,4]//alert(a); //[1,2,3]var a = 5;var b = 5;alert(a == b); // true 基本类型 : 值相同就可以var a = [1,2,3];var b = [1,2,3];alert( a == b ); //false //对象类型 : 值和引用都相同才行 面向对象之原型学习原型：去改写对象下面公用的方法或者属性，让同样的公用的东西在内存当中只存在一份（目的是为了提高性能） 类比：原型就像css中的class一样 ，而普通方法就像CSS中的style一样 注意：原型prototype : 要写在构造函数的下面 普通方法的例子123456789101112131415161718192021222324var arr = [1,2,3,4,5]; var arr2 = [2,2,2,2,2]; arr.sum = function()&#123; var result = 0; for(var i=0;i&lt;this.length;i++)&#123; result += this[i]; &#125; return result; &#125;; arr2.sum = function()&#123; var result = 0; for(var i=0;i&lt;this.length;i++)&#123; result += this[i]; &#125; return result; &#125;; //alert( arr.sum() ); //15 //alert( arr2.sum() ); //10*/ 原型的例子12345678910111213var arr = [1, 2, 3, 4, 5]; var arr2 = [2, 2, 2, 2, 2]; Array.prototype.sum = function() &#123; var result = 0; for (var i = 0; i &lt; this.length; i++) &#123; result += this[i]; &#125; return result; &#125;; alert(arr.sum()); //15 alert(arr2.sum()); //10 类比css中style的优先级大于class,所以这里的优先级也是 12345var arr = [];arr.number = 10;Array.prototype.number = 20;alert(arr.number); //10 1234var arr = [];Array.prototype.number = 20;alert(arr.number); //20 工厂方式之原型1234567891011121314151617181920212223242526 function CreatePerson(name) &#123; this.name = name; &#125; CreatePerson.prototype.showName = function() &#123; alert(this.name); &#125;; var p1 = new CreatePerson('小明'); //p1.showName(); var p2 = new CreatePerson('小强'); //p2.showName(); alert(p1.showName == p2.showName); //true 不仅值相同，而且地址相同，在内存中只存在一份 var arr = new Array(); var date = new Date(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 小结：面向对象的写法1234567891011function 构造函数()&#123; this.属性&#125;构造函数.原型.方法 = function()&#123;&#125;;var 对象1 = new 构造函数();对象1.方法(); 传统的过程式编写选项卡12]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>js面向对象及组件开发</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5的历史管理]]></title>
    <url>%2F2018%2F03%2F11%2Fhtml5%E7%9A%84%E5%8E%86%E5%8F%B2%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[历史管理onhashchange :改变hash值来管理 history pushState 三个参数：数据 标题 (都没实现) 地址（可选） popstate事件 读取数据 event.state 注意:网址是虚假的，需要在服务器指定对应 页面，不然刷新找不到页面]]></content>
  </entry>
  <entry>
    <title><![CDATA[Firebug]]></title>
    <url>%2F2018%2F03%2F11%2FFirebug%2F</url>
    <content type="text"><![CDATA[命令 console.dir(cat); //输出所有信息 console.dirxml（）；//显示当前元素的代码结构 console.assert(a); //断言，如果a是真，返回断言成功 a是假，返回断言失败 console.trace();//显示当前函数的执行过程 1234567891011function a()&#123; return b();&#125;function b()&#123; return c();&#125;function c()&#123; console.trace(); return 1;&#125;a(); 12345console.time('计时器');for(var i=0;i&lt;1000000;i++)&#123; &#125;console.timend('计时器'); 查看性能 1234567891011121314151617function a()&#123; for(var i=0;i&lt;10;i++)&#123; b(); &#125; for(var i=0;i&lt;5;i++)&#123; c(); &#125; function b()&#123; var b=10; &#125; function c()&#123; var c=20; &#125;&#125;console.profile();a();console.profileEnd(); 在其他浏览器下使用firebug1&lt;script type="text/javascript" src="https://getfirebug.com/firebug-lite.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>工具</tag>
        <tag>firebug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2018%2F03%2F11%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[什么是闭包函数嵌套函数，内部函数可以引用外部函数的参数和变量，参数和变量不会被垃圾回收机制所收回 123456789function aaa()&#123; var a=5; function bbb()&#123; alert(a); &#125; return bbb;&#125;var c=aaa();c(); 闭包有什么好处1、希望一个变量长期驻扎在内存当中 2、避免全局变量的污染 123456789var a=1;function aaa()&#123; a++; alert(a);&#125;aaa(); //2aaa(); //3alert(a); 既让a是局部变量，又让a可以累加 123456789101112function aaa()&#123; var a=1; return function()&#123; a++; alert(a); &#125;&#125;var b=aaa();b();b();alert(a); 函数声明转变为函数表达式12345678function aaa()&#123; alert(1);&#125;aaa();(function aaa()&#123; alert(1);&#125;)();]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>闭包</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式布局]]></title>
    <url>%2F2018%2F03%2F11%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[css3分栏布局 column-width 栏目宽度 column-count 栏目列数 column-gap 栏目距离 column-rule 栏目间隔线 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .wrap &#123; width: 900px; border: 1px solid #000; font: 14px/28px "宋体"; color: #000; text-indent: 2em; -webkit-column-count: 4; -webkit-column-gap: 30px; -webkit-column-rule: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 响应式12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="indexa.css" media="screen and (min-width:800px)"&gt; &lt;link rel="stylesheet" type="text/css" href="indexb.css" media="screen and (min-width:400px) and (max-width:800px)"&gt; &lt;link rel="stylesheet" type="text/css" href="indexc.css" media="screen and (min-width:400px)"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 横屏竖屏自适应引入样式表的方法 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" media="all and (arientation:portrait)" href="indexb.css"&gt; &lt;link rel="stylesheet" type="text/css" media="all and (arientation:landscape)" href="indexa.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;p&gt; “百度”二字,来自于八百年前南宋词人辛弃疾的一句词：众里寻他千百度。这句话描述了词人对理想的执着追求。 百度拥有数万名研发工程师，这是中国乃至全球最为优秀的技术团队。这支队伍掌握着世界上最为先进的搜索引擎技术，使百度成为中国掌握世界尖端科学核心技术的中国高科技企业，也使中国成为美国、俄罗斯、和韩国之外，全球仅有的4个拥有搜索引擎核心技术的国家之一。 &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; style里面直接处理的方法 12345678&lt;style&gt; @media screen and (min-width:600px)&#123; 样式 &#125; @media screen and (min-width:400px) and(max-width:800px)&#123; 样式 &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>盒模型设计和响应式布局</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>响应式布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3盒模型新增属性]]></title>
    <url>%2F2018%2F03%2F10%2Fcss3%E7%9B%92%E6%A8%A1%E5%9E%8B%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[盒模型阴影box-shadowbox-shadow:[inset] x y blur [spread] color 参数： inset 投影方式 inset:内投影 不给 ：外投影 x、y 阴影偏移 blur 模糊半径 spread 扩展阴影半径 先扩展原有形状再2开始画阴影 color 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 100px; height: 100px; margin: 100px; background: red; box-shadow: 0 0 30px 30px #000, inset 0 0 10px #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; box-reflect倒影 box-reflect direction above \ below \ left \ right 距离 渐变（可选） 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; body&#123; background: #000; &#125; img &#123; display: block; margin: 200px auto; -webkit-box-reflect:right 10px -webkit-linear-gradient(right rgba(0,0,0,1) 0,rgba(0,0,0,0) 70%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="minguo.jpg" /&gt;&lt;/body&gt;&lt;/html&gt; resize自由缩放 both 水平垂直都可以缩放 horizontal 只有水平方向可以缩放 vertical 只有垂直方向可以缩放 要配合overflow：auto来使用，只有水平方向可以缩放 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 100px; height: 100px; background: url(minguo.jpg); border: 5px solid #000; resize: both; overflow: auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; box-sizing盒模型的解析模式 content-box 标准盒模型 width\ height=border+padding+content border-box 怪异盒模型 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 200px; height: 200px; padding: 50px; border: 10px solid #000; box-sizing: border-box; &#125; .div &#123; height: 50px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="div"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>盒模型设计和响应式布局</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3弹性盒模型]]></title>
    <url>%2F2018%2F03%2F10%2Fcss3%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[弹性盒模型注意在使用弹性盒模型的时候，父元素必须要加display:box 或 inline-box box-orient 定义盒模型的布局方向 horizontal 水平方向 vertical 垂直显示 box-direction 元素排列顺序 normal 正序 reverse 反序 box-ordinal-group 设置元素的具体位置 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; height: 100px; border: 10px solid #000; padding: 10px; display: -webkit-box; -webkit-box-orient: vertical; &#125; .box div &#123; width: 100px; height: 100px; background: red; border: 1px solid #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 混序排列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; height: 100px; border: 10px solid #000; padding: 10px; display: -webkit-box; &#125; .box div &#123; width: 100px; height: 100px; background: red; border: 1px solid #fff; &#125; .box div:nth-of-type(1) &#123; -webkit-box-ordinal-group: 2; &#125; .box div:nth-of-type(2) &#123; -webkit-box-ordinal-group: 4; &#125; .box div:nth-of-type(3) &#123; -webkit-box-ordinal-group: 1; &#125; .box div:nth-of-type(4) &#123; -webkit-box-ordinal-group: 5; &#125; .box div:nth-of-type(5) &#123; -webkit-box-ordinal-group: 3; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; box-flex定义盒子的弹性空间 子元素的尺寸=盒子的尺寸*子元素的box-flex属性值/所有子元素的box-flex属性值之和 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; height: 100px; border: 10px solid #000; padding: 10px; display: -webkit-box; &#125; .box div &#123; width: 100px; height: 100px; background: red; border: 1px solid #fff; box-orient:horizontal; &#125; .box div:nth-of-type(1) &#123; -webkit-box-flex:1; &#125; .box div:nth-of-type(2) &#123; -webkit-box-flex:1; &#125; .box div:nth-of-type(3) &#123; width: 300px; &#125; .box div:nth-of-type(4) &#123; -webkit-box-flex:1; &#125; .box div:nth-of-type(5) &#123; -webkit-box-flex:1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; box-pack对盒子富裕的空间进行管理 start 所有子元素在盒子左侧显示，富裕空间在右侧 end 所有子元素在盒子右侧显示，富裕空间在左侧 center 所有子元素居中 justify 富裕空间在子元素之间平均分布]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>盒模型设计和响应式布局</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>弹性盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3新增UI样式]]></title>
    <url>%2F2018%2F03%2F10%2Fcss3%E6%96%B0%E5%A2%9EUI%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[圆角border-radiusborder-radius:1-4个数字/1-4个数字 前面是水平，后面是垂直 不给”/“,则水平和垂直一样 border-radius:10px/5px 参数：各种长度单位都可以：px,%, %有时候很方便，但是宽高不一致时不太好 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; .box &#123; width: 400px; height: 400px; margin: 50px auto; transition: 5s linear; &#125; .box div &#123; width: 180px; height: 180px; margin: 10px; border: 1px solid #000; box-sizing: border-box; float: left; background: url(new_bg.png) no-repeat; &#125; .box div:nth-child(1), .box div:nth-child(4) &#123; border-radius: 0 70%; &#125; .box div:nth-child(2), .box div:nth-child(3) &#123; border-radius: 70% 0; &#125; .box:hover &#123; -webkit-transform: rotate(720deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>新增UI样式</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>UI样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3文本新增属性]]></title>
    <url>%2F2018%2F03%2F10%2Fcss3%E6%96%87%E6%9C%AC%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[新增颜色模式 rgba r red 红 0-255 g green 绿 0-255 b blue 蓝 0-255 a Alpha 透明 0-1 例子：背景透明，文字不透明text-shadow 文字透明属性text-shadow:第一个参数表示x轴的偏移量 第二个参数表示y轴的偏移量 第三个参数表示模糊程度 第四个参数表示阴影颜色 阴影效果可以多层叠加，中间用,隔开 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p&#123; font；100px/200px "微软雅黑"； text-align: center; text-shadow: -5px -10px 1px red,5px 10px 1px green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;北京邮电&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子：层叠12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p&#123; color: red; font-size: 100px; font-weight: bold; text-shadow: 2px 2px 0px white,4px 4px 0px red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;北京邮电&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子：光晕1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; color: white; font-size: 100px; text-shadow: 0px 0px 10px #fff, 0px 0px 20px #fff, 0 0 30px #fff, 0 0 40px #fff, 0 0 40px #ff00de, 0 0 70px #ff00de, 0 0 80px #ff00de, 0 0 100px #ff00de, 0 0 150px #ff00de; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;北京邮电&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子：火焰文字123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; color: white; font-size: 100px; text-shadow: 0px 0px 20px #fefcc9, 10px -10px 30px #feec85, -20px -20px 40px #ffae34, 20px -40px 50px #ec760c, -20px -60px 60px #cd4606, 0 -80px 70px #973716, 10px -90px 80px #451b0e; font-family: Verdana,Geneva,sans-serif; font-size: 100px; font-weight: bold; color: white; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;北京邮电&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子：模糊效果123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; h1&#123; font:100px/200px "微软雅黑"; text-align: center; color: #000; text-shadow: 0 0 0 rgba(0,0,0,1); border:1px solid #000; transition:1s; &#125; h1:hover&#123; color: rgba(0,0,0,0); text-shadow: 0 0 100px rgba(0,0,0,0.5); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;北京邮电&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 文字描边只有webkit内核的浏览器才支持。-webkit-text-stroke:宽度 颜色； 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; h1 &#123; font: 100px/200px "微软雅黑"; text-align: center; color: #000; -webkit-text-stroke: 3px red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;北京邮电&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 文字排版direction 定义文字排列方式 Rtl 从右到左排列 ltr 从左到右排列 注意要配合unicode-bili一块使用 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; width: 300px; border: 1px solid #000; font: 14px/30px "宋体"; direction: rtl; unicode-bidi: bidi-override; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;北京邮电&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 文本省略text-overflow定义省略文本的处理方式 clip 无省略号 ellipsis 省略号 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; width: 300px; border: 1px solid #000; font: 14px/30px "宋体"; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;简称北邮，是中华人民共和国教育部直属，工业和信息化部共建的一所以信息科技为特色，工学门类为主体，管理学、文学、理学等多个学科门类协调发展的全国重点大学&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 自定义文字工具：asia font studio4 格式： @font-face{ font-family:’isabelle’; src:url(‘111-webfont.eot’); src:url(‘111-webfont.eot?#iefix’)format(‘embedded-opentype’), url(‘111-webfont.woff’)format(‘woff’), url(‘111-webfont.ttf’)format(‘truetype’), url(‘111-webfont.svg#untitledregular’)format(‘svg’); font-weight:normal; font-style:normal; } 转换字体格式生成兼容代码： http://www.fontsquirrel.com/fontface/generator]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>css3基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>文本新增属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3伪类和伪元素]]></title>
    <url>%2F2018%2F03%2F10%2Fcss3%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[伪类 E:target 表示当前的URL片段的元素类型，这个元素必须是E E:disabled 表示不可点击的表单控件 E:enabled 表示可点击的表单控件 E:checked 表示已选中的checkbox或radio E:first-line 表示E元素中的第一行 E:first-letter 表示E元素中的第一个字母 E::selection 表示E元素在用户选中文字时 E::before 生成内容在E元素前 E::after 生成内容在E元素之后 E：not(s) 表示E元素不被匹配 E~F 表示E元素毗邻的F元素,是指在E后面的标签 content 内容属性 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; width: 300px; height: 200px; background: #000; font: 50px/200px "微软雅黑"; color: #fff; text-align: center; display: none; &#125; div:target &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="#div1"&gt;div1&lt;/a&gt; &lt;a href="#div2"&gt;div2&lt;/a&gt; &lt;a href="#div3"&gt;div3&lt;/a&gt; &lt;div id="div1"&gt;div1&lt;/div&gt; &lt;div id="div2"&gt;div2&lt;/div&gt; &lt;div id="div3"&gt;div3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; input &#123; width: 100px; height: 30px; color: #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" name="" value="请输入" /&gt;&lt;/body&gt;&lt;/html&gt; 例子：模拟单选框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; label &#123; float: left; margin: 0 5px; overflow: hidden; position: relative; &#125; label input &#123; position: absolute; left: -50px; top: -50px; &#125; span &#123; float: left; width: 50px; height: 50px; border: 3px solid #000; &#125; input:checked~span &#123; background: red; s &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;label&gt; &lt;input type="radio" name="tab"&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt; &lt;label&gt; &lt;input type="radio" name="tab"&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt; &lt;label&gt; &lt;input type="radio" name="tab"&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt; &lt;label&gt; &lt;input type="radio" name="tab"&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; width: 300px; border: 1px solid #000; font: 12px/30px "宋体"; padding: 10px; &#125; p:first-line &#123; background: red; &#125; p:first-letter &#123; font-size: 30px; &#125; p::selection &#123; background: #F60; color: #690; &#125; p::before &#123; content: "BUPT" &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 北京邮电大学（Beijing University of Posts and Telecommunications），简称北邮，是中华人民共和国教育部直属，工业和信息化部共建的一所以信息科技为特色，工学门类为主体，管理学、文学、理学等多个学科门类协调发展的全国重点大学，是北京高科大学联盟成员高校[1] 、国家首批“双一流”世界一流学科建设高校[2] 。系国家“211工程”、“985工程优势学科创新平台”项目重点建设，列入首批“卓越工程师教育培养计划”、“111计划”。被誉为“中国信息科技人才的摇篮”。[3] 前身是1955年成立的新中国第一所邮电高等学府——北京邮电学院。1960年被国务院确定为全国重点高校。 1993年更名为“北京邮电大学”。2000年，划入教育部直属高校行列。2012年，信息与通信工程一级学科全国排名第一。 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; h1:not(.h2)&#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;h1&lt;/h1&gt;&lt;h1 class="h2"&gt;h1&lt;/h1&gt;&lt;h1&gt;h1&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>css3基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>伪类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3结构选择器]]></title>
    <url>%2F2018%2F03%2F10%2Fcss3%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[结构性伪类nth-child() 找到父级下第几个子节点 表示 含义 E:first-child 表示E元素中的第一个子节点 E:last-child 表示E元素的最后一个子节点 E:first-of-type 表示E元素中的第一个子节点且节点类型是E E:last-of-type 表示E元素中的最后一个子节点且节点类型是E的 E:only-child 表示E元素中只有一个子节点。注意：子节点不包含文本节点 E:only-of-type 表示E的父元素中只有一个子节点，且这个唯一的子节点的类型必须是E.注意：子节点不包含文本节点 E：empty 表示E元素中没有子节点。注意：子节点包含文本节点 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; height: 30px; border: 1px solid #000; &#125; p:nth-child(odd) &#123; background: red; &#125; /*p:nth-child(2)找到父级下的第二个子元素，并且这个元素还得是p标签 body:*:nth-child(2)找到body下第二个子节点，不管是什么标签 p:nth-last-child(2) 从后往前数 p:nth-of-type(2) 找到父级下的第二个p类型的标签 p:nth-of-last-type(2) 从后往前找 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;p&gt;p4&lt;/p&gt; &lt;p&gt;p5&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子：新浪新闻导航头部1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .list &#123; margin: 0; padding: 0; list-style: none; &#125; .list li &#123; width: 150px; border: 1px solid #000; float: left; &#125; .list li:last-of-type &#123; border: none; &#125; .list a &#123; float: left; width: 40px; margin: 0 5px; font: 12px/30px "宋体"; text-align: center; &#125; .list li a:nth-of-type(3n+1) &#123; font-weight: bold; &#125; .list li:ntn-child(3) a:nth-child(2) &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class="list"&gt; &lt;li&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>css3基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>结构选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3属性选择器]]></title>
    <url>%2F2018%2F03%2F09%2Fcss3%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[transition向前兼容问题 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 100px; height: 100px; background: red; transition: 1s; &#125; .box:hover &#123; width: 200px; height: 200px; background: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 测试得到其他浏览器都没问题，但是ie9和9以下，transition属性就失效了，不兼容。 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box &#123; width: 100px; height: 100px; background: red; /*transition: 1s;*/ -webkit-transition:1s;/*兼容老版的chrome，safari*/ -moz-transition:1s; /*兼容老版的火狐*/ -o-transition:1s; /*兼容老版的opera*/ transition: 1s;/*标准的*/ &#125; .box:hover &#123; width: 200px; height: 200px; background: blue; &#125; /* js里面不支持横杠,所以前缀去掉横杠，改成大写 WebKitTransition OTransition MozTransition */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css3属性选择器12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; height: 30px; border: 1px solid #000; &#125; p[xichen] &#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p xichen="leo"&gt;leo&lt;/p&gt; &lt;p xichen="kris"&gt;kris&lt;/p&gt; &lt;p xichen="jasper"&gt;jasper&lt;/p&gt; &lt;p xichen="hades"&gt;hades&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 属性选择器 表示 含义 E[attr] 只使用属性名，但没有确定任何属性值 E[attr=”value”] 指定属性名，并制定了该属性的属性值 E[attr~=”value”] 指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表包含了一个value词，而且等号前面的”~”不能不写 E[attr^=”value”] 指定属性名，并且具有属性值，属性值是以value开头的 E[attr$=”value”] 指定属性名，并且具有属性值，属性值是以value结束的 E[attr*=”value”] 指定属性名，并且具有属性值，而且属性值中包含了value E[attr\ =”value”] 指定属性名，并且具有属性值，而且属性值是以value或者以”value-“开头的值（比如zh-cn） 小例子:仿百度文库分类图标 做出不同的文档类型前面加上不同的图标的效果 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; p &#123; height: 30px; line-height: 30px; font-size: 12px; border: 1px solid #000; &#125; p a &#123; background: url(img/w.gif) no-repeat 3px center; padding-left: 20px; display: block; &#125; p a[href*=text] &#123; background-image: url(img/text.gif); &#125; p a[href*=pdf] &#123; background-image: url(img/pdf.gif); &#125; p a[href*=excel] &#123; background-image: url(img/excel.gif); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;a href="http://www.baidu.com/doc/javascript.html"&gt;百度文库&lt;/a&gt; &lt;/p&gt; &lt;p&gt; &lt;a href="http://www.baidu.com/pdf/javascript.html"&gt;百度文库&lt;/a&gt; &lt;/p&gt; &lt;p&gt; &lt;a href="http://www.baidu.com/text/javascript.html"&gt;百度文库&lt;/a&gt; &lt;/p&gt; &lt;p&gt; &lt;a href="http://www.baidu.com/excel/javascript.html"&gt;百度文库&lt;/a&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css3</category>
        <category>css3基础</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>属性选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2018%2F03%2F09%2Fwebpack%2F</url>
    <content type="text"><![CDATA[webpack开发一个项目，业务逻辑非常多，开发会按照功能逻辑拆分成一个一个的模块，这个时候开发会更加地有条理，维护起来也会更加方便，但是这样会涉及到一个问题，模块之间会有着复杂的依赖关系，在处理这些依赖的时候，对于前端开发来说，会遇到一个很棘手的问题：因为代码都是从后端请求过来的，没办法像后端那样同步地引用代码，这个时候就需要模块打包器了。 模块打包器会先分析你的项目依赖，然后会按照一些复杂的规则打包，最后会得到一个新的js文件，这个时候你只需要加载这个js文件就可以了。webpack天生拥有这种模块打包的能力，他不仅拥有js打包的能力，还能帮你打包你所有的资源（css文件、字体、图片），在打包过程中，有各种各样的loader来帮助处理各种而样的内容。还有各种插件来辅助开发和项目构建，从而加快开发效率。频繁使用到CommonJS和ES6语法。]]></content>
      <categories>
        <category>前端</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax小项目-留言板瀑布流]]></title>
    <url>%2F2018%2F03%2F09%2Fajax%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E7%95%99%E8%A8%80%E6%9D%BF%E7%80%91%E5%B8%83%E6%B5%81%2F</url>
    <content type="text"><![CDATA[瀑布流瀑布流实现原理分析特点：每一列的宽度一样的，分批加载， 分类 特点 固定列 可视区域宽度变化，列数不变 非固定列 可视区域宽度变化，列数变化 固定列的瀑布流布局：在页面放一个ul,定好列数量，三个li，浮动布局，每一列的高度统一都为0，通过ajax异步请求数据，把数据动态地往页面添加，数据是分批请求过来的，每请求一批，把数据动态填充到li里面。为了让高度相差不会太大，把当前数据往三个总高度最短的一列去添加，就可以保证三个li之间的总高度不会相差太远 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload=function()&#123; var oUl=document.getElementById("ul1"); var aLi=oUl.getElementsByTagName('li'); var iLen=aLi.length; //初始化数据处理 ajax('get','getPics.php','cpage=1',function(data))&#123; var data= JSON.parse(data); for (var i = 0; i &lt; data.length; i++) &#123; //获取高度最短的li var _index=getShort(); var oDiv=document.createElement('div'); var oImg=document.createElement('img'); oImg.src=data[i].preview; //oImg.style.width =data[i].width+'px'; oImg.style.width =225px; oImg.style.height =data[i].height+'px'; oDiv.appendChild(oImg); var oP=document.createElement('p'); oDiv.appendChild(oP); oP.innerHTML=data[i]. aLi[_index].appendChild(oDiv); &#125; &#125;); function getShort()&#123; var index=0; var ih=aLi[index].offsetHeight; for(var i=1;i&lt;data.length;i++)&#123; if (aLi[index].offsetHeight) &#123; index=i; ih=aLi[i].offsetHeight; &#125; &#125; return index; &#125; &#125; &lt;/script&gt; &lt;style type="text/css"&gt; body&#123;margin: 0; &#125; #ul1 &#123; width: 1080px; margin: 100px auto 0; &#125; li &#123; width: 247px; list-style: none; float: left; margin-right: 10px; &#125; li div &#123; border: 1px solid #000 ; padding: 10px; margin-bottom: 10px; &#125; li div img &#123; width: 225px; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt; &lt;div&gt; &lt;img src="http://s3.mogucdn.com/mlcdn/c45406/171227_2da0h5dl13dgedj4j8k62la45h5kf_640x960.jpg_240x360.v1cAC.70.webp"&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt; &lt;img src="http://s3.mogucdn.com/mlcdn/c45406/171227_2da0h5dl13dgedj4j8k62la45h5kf_640x960.jpg_240x360.v1cAC.70.webp"&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt; &lt;img src="http://s3.mogucdn.com/mlcdn/c45406/171227_2da0h5dl13dgedj4j8k62la45h5kf_640x960.jpg_240x360.v1cAC.70.webp"&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt; &lt;img src="http://s3.mogucdn.com/mlcdn/c45406/171227_2da0h5dl13dgedj4j8k62la45h5kf_640x960.jpg_240x360.v1cAC.70.webp"&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 流的实现当我们往下拉的时候，动态地再添加一批数据过来，条件是当前最短的一列li，出现在可视区的时候，也就是只要下面有一列没数据了，就可以开始加载下一批数据了。 当li的top值加上自身的高小于滚动条滚动的高加上可视区自身的高的时候，说明当前最短的一列已经进入可视区了。 12 留言本项目]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ajax</tag>
        <tag>前端练习小项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的标准模式与怪异模式]]></title>
    <url>%2F2018%2F03%2F08%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%80%AA%E5%BC%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[标准模式与怪异模式的由来在HTML与CSS的标准化未完成之前，各个浏览器对于HTML和CSS的解析有各自不同的实现，而有很多旧的网页都是按照这些非标准的实现去设计的。在HTML与CSS标准确定之后，浏览器一方面要按照标准去实现对HTML与CSS的支持，另一方面又要保证对非标准的旧网页设计的后向兼容性。因此，现代的浏览器一般都有两种渲染模式：标准模式和怪异模式。在标准模式下，浏览器按照HTML与CSS标准对文档进行解析和渲染；而在怪异模式下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。这样的话，对于旧有的网页，浏览器启动怪异模式，就能够使得旧网页正常显示；对于新的网页，则可以启动标准模式，使得新网页能够使用HTML与CSS的标准特性。 浏览器如何确定使用哪种渲染模式知道了这两种渲染模式的来由，那剩下的问题就是浏览器如何能够确定应该使用哪种模式了。其实归根结底就是，浏览器如何能将旧网页与新网页区分开来。 平常编写网页的时候，一般都会见到HTML文档的头部会有文档类型声明：DOCTYPE。当浏览器遇到正确的文档声明时，浏览器就会启动标准模式，按照制定的文档类型标准解析和渲染文档。而对于旧有的网页，由于网页编写的当时标准还没有确定，所以一般是不会有文档类型声明的。所以，对于没有文档类型声明或者文档类型声明不正确的文档，浏览器就会认为它是一个旧的HTML文档，就会使用怪异模式解析和渲染该文档。关于DOCTYPE的更详细说明，请戳这里 DOCTYPE声明作用及用法详解。 标准模式与怪异模式的区别盒模型的处理差异标准CSS盒模型的宽度和高度等于内容区的高度和宽度，不包含内边距和边框，而IE6之前的浏览器实现的盒模型的宽高计算方式是包含内边距和边框的。因此，对于IE，怪异模式和标准模式下的盒模型宽高计算方式是不一样的； 行内元素的垂直对齐很多早期的浏览器对齐图片至包含它们的盒子的下边框，虽然CSS的规范要求它们被对齐至盒内文本的基线。标准模式下，基于Gecko的浏览器将会对齐至基线，而在quirks模式下它们会对齐至底部。最直接的例子就是图片的显示。在标准模式下，图片并不是与父元素的下边框对齐的，如果仔细观察，你会发现图片与父元素下边框之间存在一点小空隙。那是因为标准模式下，图片是基线对齐的。而怪异模式下，则不存在这个问题。具体请看这篇文章 CSS深入理解vertical-align和line-height的基友关系。 参考文章 CSS深入理解vertical-align和line-height的基友关系 DOCTYPE声明作用及用法详解 怪异模式 作者：tsyeyuanfeng链接：https://www.jianshu.com/p/dcab7cde8c04來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>html</tag>
        <tag>面试</tag>
        <tag>标准模式与怪异模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js之getpos()]]></title>
    <url>%2F2018%2F03%2F08%2Fjs%E4%B9%8Bgetpos%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
        <tag>前端</tag>
        <tag>getpos()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工具]]></title>
    <url>%2F2018%2F03%2F08%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[ie浏览器测试工具：IETESTERhttp://www.ietester.cn/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax原理]]></title>
    <url>%2F2018%2F03%2F07%2Fajax%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是ajaxAsynchronous JavaScript and XML(异步JavaScript和XML)。作用1、节省用户操作，时间，提高用户体验，减少数据请求。2、传输获取数据 使用Ajax：使用Ajax获取某一文本文件的内容 ,可以使页面在无刷新的情况下去获取数据。因为网页是单次请求的，如果不再去刷新，请求的话，页面是不会变化的。 Ajax过程详解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; //打开浏览器 /*1、创建一个ajax对象*/ //ie6以下 new ActiveXObject('Microsoft.XMLHTTP') var xhr=null; /* if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest(); &#125;else&#123; xhr= new ActiveXObject('Microsoft.XMLHTTP'); &#125;*/ try&#123; xhr = new XMLHttpRequest(); &#125;catch(e)&#123; xhr= new ActiveXObject('Microsoft.XMLHTTP'); &#125; //在地址栏输入地址 /* open方法 参数 1、打开方式 2、地址 3、是否异步 异步：非阻塞，前面的代码不会影响后面代码的执行 同步：阻塞，前面的代码会影响后面代码的执行 */ xhr.open('get', '1.txt', true);//true代表异步 false代表同步 //提交，发送请求 xhr.send(); //等待服务器返回内容 //readyState:ajax工作状态 //responseText:ajax请求返回的内容就被存放在这个属性下民 //on readystate change :当readyState改变的时候触发 //status:服务器状态，http状态码 xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if(xhr.status==200)&#123; alert(xhr.responseText);&#125; else&#123; alert("出错了"+"err:404"); &#125; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" name="按钮" id="btn" /&gt;&lt;/body&gt;&lt;/html&gt; 表单表单：数据的提交 action 数据提交的地址，默认是当前页面 method 数据提交的方式，分为get和post，默认是get enctype 提交的数据的格式,默认是application/x-www-form-urlencoded get方式：把数据名称和数据对应的数据值用=连接，如果有多个的话，那么他会把多个数据组合用&amp;进行连接，然后把数据放到url?的后面传到指定页面。url长度限制的原因，我们不要通过get方式传递过多的数据 post方式：理论上传递数据长度无限制 数据的获取onreadystatechange事件 readyState属性 请求状态 0 未初始化，还没有调用open()方法 1 载入，已调用send()方法，正在发送请求 2 载入完成，send()方法完成，已收到全部响应内容 3 解析，正在解析相应内容 4 完成，相应内容解析完成，可以在客户端调用了 status属性：服务器请求资源的状态 responeseText 返回以文本形式存放的内容 responseXML 返回XML形式的内容 ajax获取数据的处理和实例JSONchrome,ie7以上都支持，Ie7和Ie7以下不支持。可以去json.org官网下载对应的语言的包，来支持json互转。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="json.js"&gt;&lt;/script&gt; //这里的json.js文件是从json.org官网复制的json2.js库,这样就可以解决ie7及ie7以下不兼容的问题 &lt;script&gt; alert(JSON); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; stringify可以把一个对象转换成一个字符串。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="json.js"&gt;&lt;/script&gt; &lt;script&gt; //alert(JSON); var arr=[1,2,3]; var j=&#123;left:100&#125;; alert(JSON.stringify(arr));//把数组转成字符串 alert(JSON.stringify(j));//把JSON转成字符串 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; parse可以把字符串转换成对应的对象。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="JSON.js"&gt;&lt;/script&gt; &lt;script&gt; var s1='[100,200,300]'; var a1=JSON.parse(s1); //字符串转换成数组 alert(a1[0]); var s2='&#123;"left":100&#125;'; //JSON将作为key的值必须用双引号括起来 var a2=JSON.parse(s2); //字符串转换成JSON alert(a2.left); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 实例：获取并显示新闻数据php后端部分：getNews.php 123456789101112131415&lt;?phpheader('content-type:text/html;charset="utf-8"');error_reporting(0);$news =array( array（'title' =&gt;'很穷但很自豪！实拍朝鲜农村生活现状','data'=&gt;'2015-7-8' ）, array（'title' =&gt;'周冬雨登杂志封面 清新灵动别具一格','data'=&gt;'2015-9-10' ）, array（'title' =&gt;'听说桂林这个壕要过生日，这些大牌都来了','data'=&gt;'2015-9-10' ）, array（'title' =&gt;'妈妈把老公旧衣改成宝宝的新衣','data'=&gt;'2015-9-10' ）, array（'title' =&gt;'事实告诉你 中餐在美到底有多受欢迎!','data'=&gt;'2015-9-10' ）, array（'title' =&gt;'海外体检全知道：去日本体检该办哪种签证？','data'=&gt;'2015-9-10' ）,);echo json_encode($news); 前端部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="JSON.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn'); var xhr = null; oBtn.onclick = function() &#123; try &#123; xhr = new XMLHttpRequest(); &#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHttp'); &#125; xhr.open('get', 'getNews.php', true); xhr.send(); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; // alert(xhr.responseText); var data = JSON.parse(xhr.responseText); //把字符串转换成对应的对象 var oUl = document.getElementById('ul1'); var html = ''; for (var i = 0; i &lt; data.length; i++) &#123; html += '&lt;li&gt;&lt;a href=""&gt;' + data[i].title + '&lt;/a&gt;[&lt;span&gt;' + data[i].date + '&lt;/span&gt;]&lt;/li&gt;'; &#125; oUl.innerHTML = html; &#125; else &#123; alert('出错了，err:' + xhr.status); &#125; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" name="按钮" value="按钮" id="btn" /&gt; &lt;ul id="ul1"&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 应用中get和post的区别处理get方式：缓存问题解决方法：在url?后面连接一个随机数，时间戳。 get方式：中文乱码问题解决方法：编码encodeURI,中文进行编码再传输。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="JSON.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn'); var xhr = null; oBtn.onclick = function() &#123; try &#123; xhr = new XMLHttpRequest(); &#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHttp'); &#125; /*解决缓存问题：在url?后面连接一个随机数，时间戳 2、乱码：编码encodeURI,中文进行编码再传输 */ xhr.open('get', '2.get.php?username=' + encodeURI('李明') + '&amp;age=30&amp;' + new Date().getTime(), true); xhr.send(); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; alert(xhr.responseText); &#125; else &#123; alert('出错了，err:' + xhr.status); &#125; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" name="按钮" value="按钮" id="btn" /&gt; &lt;ul id="ul1"&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; post方式：数据放在send()方法里面作为参数传递，记得要申明发送的数据类型。 注意：post方式没有缓存问题，因为是往服务器提交数据，不产生缓存。post方式，中文也不会乱码，无需编码 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="JSON.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn'); var xhr = null; oBtn.onclick = function() &#123; try &#123; xhr = new XMLHttpRequest(); &#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHttp'); &#125; xhr.open('post', '2.get.php', true); xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded'); //申明发送的数据类型 xhr.send('username=leo&amp;age=30'); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; alert(xhr.responseText); &#125; else &#123; alert('出错了，err:' + xhr.status); &#125; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" name="按钮" value="按钮" id="btn" /&gt; &lt;ul id="ul1"&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 后端部分： 12345678&lt;?phpheader('content-type:text/html;charset="utf-8"');error_reporting(0);$username=$_POST['username'];$age=$_POST['age'];echo "你的名字：&#123;$username&#125;,年龄：&#123;$age&#125;";]]></content>
      <categories>
        <category>前端</category>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax:服务器环境搭建]]></title>
    <url>%2F2018%2F03%2F07%2Fajax-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js中的正则表达式]]></title>
    <url>%2F2018%2F03%2F06%2Fjs%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[字符串indexOf 查找substring 获取子字符串charAt 获取某个字符串split 分割字符串，获得数组 字符串比较字符串可以进行比较，所以可以用来判断字符串是不是数字类型1234567891011&lt;script&gt; //alert( 'a'&lt;'b' ); var str = '5'; if (str &lt;= '9' &amp;&amp; str &gt;= '0') &#123; alert('是数字类型的字符串'); &#125; else &#123; alert('不是数字类型的字符串'); &#125; &lt;/script&gt; 找出字符串中所有的数字123456789101112131415161718192021222324252627282930313233&lt;script&gt; var str = 'haj123sdk54hask33dkhalsd879'; function findNum(str) &#123; var arr = []; var tmp = ''; for (var i = 0; i &lt; str.length; i++) &#123; if (str.charAt(i) &lt;= '9' &amp;&amp; str.charAt(i) &gt;= '0') &#123; tmp += str.charAt(i); &#125; else &#123; if (tmp) &#123; arr.push(tmp); tmp = ''; &#125; &#125; &#125; if (tmp) &#123; arr.push(tmp); tmp = ''; &#125; return arr; &#125; alert(findNum(str)); &lt;/script&gt; 上述功能正则表达式的写法:12345function findNum(str) &#123; return str.match(/\d+/g); &#125; alert(findNum(str)); 什么是正则正则，也叫规则，让计算机能够读懂人类的规则。12var re= //; //大部分用这种 简写的 var re= new RegExp(); 正则中的test方法test:正则去匹配字符串，如果匹配成功就返回真，如果匹配失败就返回假 。test的写法：正则.test(字符串)。 写法 含义 \s 空格 \S 非空格 \d 数字 \D 非数字 \w 字符 \W 非字符 12345678910var str = '374829348791';var re = /\D/;if( re.test(str) )&#123; alert('不全是数字');&#125;else&#123; alert('全是数字');&#125; 正则中的search方法search : 正则去匹配字符串 , 如果匹配成功，就返回匹配成功的位置，如果匹配失败就返回 -1。 search的写法 : 字符串.search(正则)。正则中的默认 : 是区分大小写的 如果不区分大小写的话，在正则的最后加标识 i 。12345678910111213141516171819202122&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var str = 'abcdef'; var re = /B/i; //不区分大小写的简写写法 //var re = new RegExp('B','i'); //全称的写法 alert(str.search(re)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 正则中的match方法match : 正则去匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null。match的写法 : 字符串.match(正则)。正则默认：正则匹配成功就会结束，不会继续匹配;如果想全部查找，就要加标识 g(全局匹配)。量词 : 匹配不确定的位置 +: 至少出现一次,可以看成大于等于1 12345var str = 'haj123sdk54hask33dkhalsd879'; var re = /\d+/g; //如果这里去掉g的话，那么显示结果就是123.第一次匹配成功就会结束 alert(str.match(re)); 正则中的replacereplace : 正则去匹配字符串，匹配成功的字符去替换成新的字符串。replace的写法 : 字符串.replace(正则,新的字符串)。1234567891011121314151617181920&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var str = 'aaa'; var re = /a+/g; //如果把这里改成/a/g 则替换后显示为bbb; 改成/a/，则替换后显示为baa str = str.replace(re, 'b'); alert(str); //显示一个b &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; replace的应用：敏感词过滤1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; //菲称仁爱礁附近17艘中国船均在菲军监视之下 //| : 或的意思 //replace : 第二个参数：可以是字符串，也可以是一个回调函数 window.onload = function() &#123; var aT = document.getElementsByTagName('textarea'); var oInput = document.getElementById('input1'); var re = /菲称|中国船|监视之下/g; oInput.onclick = function() &#123; //aT[1].value = aT[0].value.replace(re,'*'); aT[1].value = aT[0].value.replace(re, function(str) &#123; //函数的第一个参数：就是匹配成功的字符 //alert( str ); var result = ''; for (var i = 0; i &lt; str.length; i++) &#123; result += '*'; &#125; return result; &#125;); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 替换前 &lt;br /&gt; &lt;textarea&gt; &lt;/textarea&gt; &lt;br /&gt; 替换后 &lt;br /&gt; &lt;textarea&gt; &lt;/textarea&gt; &lt;br /&gt; &lt;input type="button" value="确定" id="input1" /&gt;&lt;/body&gt;&lt;/html&gt; 匹配子项（用小括号）匹配子项 : 小括号 () (还有另外一个意思，分组操作)把正则的整体叫做（母亲）, 然后把左边第一个小括号里面的正则，叫做这个第一个子项(母亲的第一个孩子), 第二个小括号就是第二个孩子 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var str = '2015-6-7'; var re = /(\d+)(-)/g; str = str.replace(re, function($0, $1, $2) &#123; //第一个参数：$0（母亲）,第二个参数 : $1(第一个孩子) //,第二个参数 : $1(第二个孩子) //alert( $2 ); //return $1 + '.'; return $0.substring(0, $0.length - 1) + '.';//$0表示正则的整体，这里是截取匹配到的正则的整体减去一个长度的字符，后面再加上. 相当于直接替换掉了- &#125;); alert(str); //2013.6.7 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 也可以用match方法实现1234567&lt;script&gt; var str = 'abc'; var re = /(a)(b)(c)/; alert(str.match(re)); //[abc,a,b,c](当match不加g的时候才可以获取到子项的集合) &lt;/script&gt; 1234567&lt;script&gt; var str = 'abc'; var re = /(a)(b)(c)/g; alert(str.match(re)); &lt;/script&gt; 正则中的字符类字符类 : 一组相似的元素 [] 中括号的整体代表一个字符，[ ]里面代表“或”的关系。 123 var str = 'abdc'; var re = /a[bde]c/;alert( re.test(str) ); //显示false,因为[]中的代表一个整体，第三个字符c与字符串中的d不匹配 字符类中的排除排除：用符号^ 如果^写在[]里面的话，就代表排除的意思。 123var str = 'abc'; var re = /a[^bde]c/;alert( re.test(str) ); //显示false,因为[]中的代表一个整体，正则中第二个字符要排除掉bde,字符串中第二个字符是b，所以错了。如果把字符串中第二个字符b改成除了bde以外的字符，就返回true 字符类的范围用-来表示范围 123var str = 'abc';var re = /a[a-z0-9A-Z]c/;alert(re.test(str)); //显示true，说明匹配上了 字符类应用：过滤标签123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aT = document.getElementsByTagName('textarea'); var oInput = document.getElementById('input1'); //var re = /&lt;\w+&gt;/g; var re = /&lt;[^&gt;]+&gt;/g; oInput.onclick = function() &#123; aT[1].value = aT[0].value.replace(re, ''); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 替换前 &lt;br /&gt; &lt;textarea&gt; &lt;/textarea&gt; &lt;br /&gt; 替换后 &lt;br /&gt; &lt;textarea&gt; &lt;/textarea&gt; &lt;br /&gt; &lt;input type="button" value="确定" id="input1" /&gt;&lt;/body&gt;&lt;/html&gt; 正则中的转义字符 符号 含义 . 任意字符 .前面加一个反斜杠 真正的点 123var str = 'a.c';var re = /a.c/;alert(re.test(str)); //显示true 符号 含义 \b 独立的部分 \B 非独立的部分 123var str = 'onetwo';var re = /one\b/;alert(re.test(str)); //显示false 获取class的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;//alert('\'');window.onload = function() &#123; var aLi = getByClass(document, 'box1'); for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].style.background = 'red'; &#125; /*function getByClass(oParent,sClass)&#123; var arr = []; var aEle = oParent.getElementsByTagName('*'); for(var i=0;i&lt;aEle.length;i++)&#123; if( aEle[i].className == sClass )&#123; arr.push( aEle[i] ); &#125; &#125; return arr; &#125;*/ function getByClass(oParent, sClass) &#123; var arr = []; var aEle = oParent.getElementsByTagName('*'); //var re = /sClass/; //当正则需要传参的时候，一定要用全称的写法 var re = new RegExp('\\b' + sClass + '\\b'); for (var i = 0; i &lt; aEle.length; i++) &#123; if (re.test(aEle[i].className)) &#123; arr.push(aEle[i]); &#125; &#125; return arr; &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li class="box1"&gt;111&lt;/li&gt; &lt;li&gt;111&lt;/li&gt; &lt;li class="box1box2"&gt;111&lt;/li&gt; &lt;li&gt;111&lt;/li&gt; &lt;li class="box1 box2"&gt;111&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 正则中的重复的子项 字符 含义\1 \1 重复的第一个子项 \2 重复的第二个子项 12345var str = 'abca';var re = /(a)(b)(c)\2/;alert( re.test(str) ); //显示false 12var re=/\w\w/; //这两个字符虽然长的一样，但是不一定是同一个字符，匹配ab或者cd也是成功的var re=/(\w)\1/; //这种情况，匹配的两个字符必须一样才可以,因为\1要跟第一个子项完全一样 应用：找重复项最多的字符和个数123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var str = 'assssjdssskssalsssdkjsssdss'; var arr = str.split(''); //分割成数组 str = arr.sort().join(''); //排序，然后再转成字符串 //alert(str); var value = ''; var index = 0; var re = /(\w)\1+/g; str.replace(re, function($0, $1) &#123; //alert($0); if (index &lt; $0.length) &#123; index = $0.length; value = $1; &#125; &#125;); alert('最多的字符:' + value + ',重复的次数:' + index); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 正则中的量词和首尾匹配 表示 含义 {4，7} 最少出现4次，最多出现7次 {4，} 最少出现4次 {4} 正好出现4次 表示 含义 + {1，} 至少出现1次 ？ {0，1} 出现0次或者1次 * {0，} 至少出现0次 1234var str = 'ac';var re = /ab*/;alert(re.test(str)); //显示true 例子1：用正则判断是不是QQ号 表示 含义 ^ 正则的最开始位置，就代表起始的意思 $ 正则的最后位置 , 就代表结束的意思 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload = function()&#123; var aInput = document.getElementsByTagName('input'); var re = /^[1-9]\d&#123;4,11&#125;$/; //起始的位置必须为1-9的一个数字，后面为4到11位的数字，最后要加结束符$ aInput[1].onclick = function()&#123; if( re.test(aInput[0].value) )&#123; alert('是QQ号'); &#125; else&#123; alert('不是QQ号'); &#125; &#125;; &#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" /&gt;&lt;input type="button" value="确定" /&gt;&lt;/body&gt;&lt;/html&gt; 例子2：去掉前后空格123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;var str = ' hello ';alert( '('+trim(str)+')' );function trim(str)&#123; var re = /^\s+|\s+$/g; return str.replace(re,''); &#125;//now777@qq.com//^\w+@[a-z0-9]+(\.[a-z]+)&#123;1,3&#125;$/*var re = &#123; qq : /[1-9][0-9]&#123;4,9&#125;/, email : /^\w+@[a-z0-9]+(\.[a-z]+)&#123;1,3&#125;$/, number : /\d+/&#125;;re.email*/&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>正则</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>字符串</tag>
        <tag>正则</tag>
        <tag>敏感词过滤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数返回值]]></title>
    <url>%2F2018%2F03%2F06%2F%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[函数返回值]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度文库评分和百度音乐全选效果]]></title>
    <url>%2F2018%2F03%2F05%2F%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E8%AF%84%E5%88%86%E5%92%8C%E7%99%BE%E5%BA%A6%E9%9F%B3%E4%B9%90%E5%85%A8%E9%80%89%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[百度文库评分效果 百度音乐全选效果]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>前端练习小项目</tag>
        <tag>运算符</tag>
        <tag>流程控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符流程控制]]></title>
    <url>%2F2018%2F03%2F05%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[运算符 算术运算符：+ 、- 、 、 / 、 %（取模)赋值： = 、+= 、 -= 、 = 、 /= 、 %=关系： &lt; 、 &gt; 、 &lt;= 、 &gt;= 、 == 、 != 、 === 、 !==逻辑：&amp;&amp; 、 || 、 ！运算符优先级： 括号 取余效果：鼠标划过，隔行改变颜色，鼠标离开，恢复原来的灰色。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aLi = document.getElementsByTagName('li'); var arr = ['red', 'yellow', 'blue']; for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index = i; aLi[i].style.background = arr[i % arr.length]; aLi[i].onmouseover = function() &#123; this.style.background = 'gray'; &#125;; aLi[i].onmouseout = function() &#123; this.style.background = arr[this.index % arr.length]; &#125;; &#125; &#125;; &lt;/script&gt; &lt;style&gt; li &#123; height: 24px; margin-bottom: 3px; list-style: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 隔行变色扩展1234567&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 window.onload = function() &#123; var aLi = document.getElementsByTagName('li'); var arr = ['red', 'yellow']; var str = ''; for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index = i; aLi[i].style.background = arr[i % arr.length]; aLi[i].onmouseover = function() &#123; str = this.style.background; // 先存颜色 this.style.background = 'gray'; &#125;; aLi[i].onmouseout = function() &#123; // this.style.background = arr[this.index%arr.length]; this.style.background = str; &#125;; &#125; &#125;; &lt;/script&gt; &lt;style&gt; li &#123; height: 24px; margin-bottom: 3px; list-style: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 京东商城秒转时间1234&lt;script&gt; var s = 3605; // 秒alert(Math.floor(s / 60) + '分' + s % 60 + '秒');&lt;/script&gt; ==与===的区别== 只判断值,而===先判断类型，再判断值。 逻辑运算符注意：！还可以转换数据类型，如果！后面跟的是非零数，则结果为false。以下例子里，alert(120&lt;90 || 20),结果为20 ，因为左边为false,继续往下找，直接把20赋给它。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; // &amp;&amp; 与、|| 或、! 否 alert( 12&lt;90 &amp;&amp; 230&lt;80 ); // false var a = 120 &lt; 90 &amp;&amp; 20; alert( a ); // false alert( 120&lt;90 || 230&lt;80 ); //false var b = 120 &lt; 90 || 20; alert(b); // 20 var c = !!true; alert( c ); //true var d = !200; alert( d ); //false &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 反选小例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aInp = document.getElementsByTagName('input'); // aInp[1].checked = false; // aInp[2].checked = true; aInp[0].onclick = function() &#123; for (var i = 1; i &lt; aInp.length; i++) &#123; aInp[i].checked = !aInp[i].checked; /* if( aInp[i].checked ) &#123; aInp[i].checked = false; &#125; else &#123; aInp[i].checked = true; &#125; */ &#125; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="反选" /&gt; &lt;ul&gt; &lt;li&gt; &lt;input type="checkbox" checked /&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="checkbox" /&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="checkbox" checked /&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="checkbox" /&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="checkbox" /&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 流程控制判断：if 、 switch 、 三目运算？：循环： while、 for跳出：break、continue跳过什么是真：非零的数字、字符串、true、函数、object、[]、{}、元素（存在）什么是假：零、NaN、空字符串、false、null、未定义]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js作用域]]></title>
    <url>%2F2018%2F03%2F04%2Fjs%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[预解析机制 作用域域：空间、范围、区域……作用：读、写script 全局变量、全局函数,自上而下函数 由里到外浏览器：“JS解析器”1）“找一些东西” ：var function 参数a = …所有的变量，在正式运行代码之前，都提前赋了一个值：未定义fn1 = function fn1(){ alert(2); }所有的函数，在正式运行代码之前，都是整个函数块JS 的预解析遇到重名的：只留一个变量和函数重名了，就只留下函数​2）逐行解读代码：表达式：= + - * / % ++ – ! 参数……表达式可以修改预解析的值！ 小例子12345678910111213141516 alert(a); // 输出 function a ()&#123; alert(4); &#125;//因为预解析之后，变量和函数重名了就只留下函数，所以a是整个函数块 function a()&#123;alert(4)&#125;; var a = 1; alert(a); // 输出 1//表达式var a=1;修改了预解析的值 function a ()&#123; alert(2); &#125; alert(a); // 输出 1// 函数不修改值 var a = 3; alert(a); // 输出 3//表达式var a=3;修改了预解析的值 function a ()&#123; alert(4); &#125; alert(a); // 输出 3//函数不修改值 alert( typeof a ); //number // a(); // 报错 js单线程运行12345678&lt;script&gt;alert(a); //报错&lt;/script&gt;&lt;script&gt;var a=1; //1alert(a);&lt;/script&gt; 前一个script区域运行完之后，值会保存。 12345678&lt;script&gt;var a=1; //1alert(a);&lt;/script&gt; &lt;script&gt;alert(a); //1&lt;/script&gt; 函数也是一个局部的域函数调用：预解析+逐行解读代码1)预解析： var function 参数….a=…fn1=function(){ alert(a); var a=2；}2）逐行解读代码：表达式函数调用2.1）预解析： a=… 这里的a是局部变量2.2)逐行解读代码： a=2; 1234567var a = 1; function fn1()&#123; alert(a); // undefined var a = 2; //a=2 &#125; fn1(); alert(a); // 1 下面看看 不加var的影响1)预解析： var function 参数….a=…fn1=function(){ alert(a); a=2；}2）逐行解读代码：表达式函数调用2.1）局部预解析：因为函数里面没有var 所有没有找到，2.2)局部逐行解读代码： a=2; 1234567var a = 1; function fn1()&#123; alert(a); // 1 所以返回父级去找。由里到外（作用域链）找到外面那个a a = 2; //这里修改的是外面的那个a &#125; fn1(); alert(a); // 2 小结：先找东西，后执行。执行过程中遇到表达式就会去修改原来库里面的东西，如果遇到函数调用就开了一个新的作用域，一旦新的作用域开始了，又会重复以上步骤，新的作用域中如果没找到里面有东西，又会返回父级里面去找。 带参数的函数1)预解析： var function 参数….a=…fn1=function(a){ alert(a); a=2；}2）逐行解读代码：表达式函数调用2.1）局部预解析：因为函数里面没有var ,也没有找到函数，所有没有找到。参数本质上就是一个局部变量。找到了参数，但是这个例子里函数调用并没有传进来。参数 a=…未定义2.2)局部逐行解读代码： 局部变量a就是undefined 1234567var a = 1; //全局变量a=1function fn1(a)&#123; alert(a); // undefined a = 2; //这句把a改成2&#125;fn1();alert(a); // 这里读取父级的a=1 函数调用带参数1)预解析： var function 参数….a=…fn1=function(a){ alert(a); a=2；}2）逐行解读代码：表达式函数调用fn1(a)2.1）局部预解析：参数本质上就是一个局部变量，因为这个例子里面传递了参数进来，所以a=undefined。参数 a=…未定义2.2)局部逐行解读代码：因为传递进来的a=1,所以局部变量a=1,再下一步就是局部变量a=2。 全局变量a仍然是1 1234567var a = 1; function fn1(a)&#123; alert(a); // 1 a = 2; &#125; fn1(a); alert(a); // 1 任何函数都可以改全局变量因为函数内部没有这个变量的话，会从里往外找。 123456789101112var num = 0;function fn1()&#123; num++;&#125;function fn2()&#123; num--;&#125;fn2();fn1();fn2();alert(num); 获取函数内的值巧妙利用全局变量来去获取函数内的内容 1234567var str = '';function fn1()&#123; var a = '大鸡腿~'; str = a;&#125;fn1(); alert( str ); //大鸡腿 另一种方法： 123456789function fn2()&#123; var a = '9999999克拉钻石23456789'; fn3(a);&#125;fn2();function fn3(a)&#123; alert(a);&#125; 注意事项if(){}和for(){}、do{}while不是作用域，函数是作用域。firefox不能对下面的函数进行预解析,除了火狐以外，其他的浏览器都可以。 1234567alert( fn1 ); // FF 不能对下面的函数进行预解析if( true )&#123; var a = 1; function fn1()&#123; alert(123);&#125;&#125; 解决这个兼容性问题的方法是：以后尽量不要在if语句里面定义函数，全局变量。改成下面这种写法： for里面包了一个函数，在函数里面不要直接使用i下例会出现undefined的原因是：点击事件函数是一个作用域，只要有作用域，就会有域解析，点击事件函数里面域解析的时候会找到var i=undefined,所以这里alert(i)是undefined。但是如果把for循环里面的var去掉的话，那么点击事件函数里面就没有变量，所以i就会到父级里面去找，父级i是3,所以此时alert(i)会弹出3。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].onclick = function() &#123; alert( i ); for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].style.background = 'yellow'; &#125; &#125;; &#125; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="button" value="按钮1" /&gt; &lt;input type="button" value="按钮2" /&gt; &lt;input type="button" value="按钮3" /&gt; &lt;/body&gt; &lt;/html&gt; 但是如果把js代码改成以下就会出错 12345678910111213&lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].onclick = function() &#123; alert( i ); // 3 aBtn[i].style.background = 'yellow'; &#125;; &#125; &#125;; &lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>作用域</tag>
        <tag>预解析</tag>
        <tag>易错点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数传参项目]]></title>
    <url>%2F2018%2F03%2F04%2F%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[搜狐视频纪录片列表展示 修改文本框的值 选择卡里套选择卡]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>前端练习小项目</tag>
        <tag>函数传参</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绝对定位与相对定位]]></title>
    <url>%2F2018%2F03%2F04%2F%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E4%B8%8E%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[通常情况下，元素的position属性的值默认为static，也就是没有定位，元素出现再正常的文档流中，这个时候如果给元素设置left、right、bottom、top这些偏移属性，都不会生效，z-index也不会生效。 相对定位relative注意：使用相对定位时，就算元素被偏移了，但是它仍然会占据着没偏移之前的空间。 上图，第二个块针对本身的位置发生了一个偏移，但是它原来所占据的那个位置空间仍然还在，即使它完全离开原来的位置，但是它原来位于文档流中的位置仍然会存在，不会被第三个浮动过来填补掉；同时它的偏移也不会把别的块从文档流中原来的位置挤开，如果有重叠的地方它会重叠再其他文档流元素之上，可以通关过设置z-index属性来调整他的堆叠顺序。 绝对定位absolute被设置了绝对定位的元素，在文档流中是不占据空间的，如果某元素设置了绝对定位，那么它在文档流中的位置会被删除，其实这个元素是浮了起来，它与relative的不同点在于：相对定位不会删除它本身在文档流中占据的那块空间，而绝对定位则会删除该元素在文档流中的位置，完全从文档流中抽出来。 绝对定位是如何定位的？ 一、如果它的父级元素设置了除static之外的定位，比如position：relative 或者position：absolute或者position：fixed,那么它就会相对于它的父级元素来定位，位置通过left、top、right、bottom（刚好一个顺时针）属性来规定。 二、如果它的父级元素没有设置定位，那么就得看它父元素得父元素有没有设置定位，如果还是没有，就继续向更高层得祖先元素类推。 小结：总之它的定位就是相对于设置了除static定位之外得定位得第一个祖先元素，如果以上情况都不存在，那么他就会相对于文档body来定位（并非窗口，相对于窗口来定位得是fixed）绝对定位得元素相对于谁来定位，我们就把这个“谁”叫做参照物。 下面是使用了绝对定位得效果： 注意：在设置偏移量得时候，可以设置负值。]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>相对定位绝对定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数传参]]></title>
    <url>%2F2018%2F03%2F04%2F%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[函数传参 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; /* 函数传递参数 参数=JS的数据类型： 数字、字符串、布尔、函数、对象、未定义 */ fn1(100, 'px'); function fn1(a, b) &#123; // alert( a+b ); &#125; fn2('miaov'); fn2('妙味课堂'); function fn2(a) &#123; // alert(a.charAt(2)); &#125; //传递一个有名字的函数，不用带括号 function fn4() &#123; alert(4); &#125; 1234567891011121314151617181920212223 fn3(fn4); fn3(function(a) &#123; alert(a); &#125;); function fn3(fn) &#123; fn(100); fn(); &#125; //传递对象 fn5(window, document); function fn5(w, d) &#123; w.onload = function() &#123; d.body.innerHTML = 123; &#125;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 代码重用1、尽量保证 HTML 代码结构一致，可以通过父级选取子元素2、把核心主程序实现，用函数包起来3、把每组里不同的值找出来，通过传参实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; ul &#123; padding: 0; margin: 0; &#125; li &#123; list-style: none; &#125; body &#123; background: #333; &#125; .box &#123; width: 400px; height: 500px; position: relative; background: url(img/loader_ico.gif) no-repeat center #fff; float: left; margin-right: 60px; &#125; .box img &#123; width: 400px; height: 500px; &#125; .box ul &#123; width: 40px; position: absolute; top: 0; right: -50px; &#125; .box li &#123; width: 40px; height: 40px; margin-bottom: 4px; background: #666; &#125; .box .active &#123; background: #FC3; &#125; .box span &#123; top: 0; &#125; .box p &#123; bottom: 0; margin: 0; &#125; .box p, .box span &#123; position: absolute; left: 0; width: 400px; height: 30px; line-height: 30px; text-align: center; color: #fff; background: #000; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; fnTab('pic1', ['img/1.png', 'img/2.png', 'img/3.png', 'img/4.png'], ['小宠物', '图片二', '图片三', '面具'], 'onclick'); fnTab('pic2', ['img/2.png', 'img/3.png', 'img/4.png'], ['图片二', '图片三', '面具'], 'onmouseover'); &#125;; function fnTab(id, arrUrl, arrText, evt) &#123; var oDiv = document.getElementById(id); var oImg = oDiv.getElementsByTagName('img')[0]; var oSpan = oDiv.getElementsByTagName('span')[0]; var oP = oDiv.getElementsByTagName('p')[0]; var oUl = oDiv.getElementsByTagName('ul')[0]; var aLi = oUl.getElementsByTagName('li'); var num = 0; for (var i = 0; i &lt; arrUrl.length; i++) &#123; oUl.innerHTML += '&lt;li&gt;&lt;/li&gt;'; &#125; // 初始化 function fnTab() &#123; oImg.src = arrUrl[num]; oSpan.innerHTML = 1 + num + ' / ' + arrUrl.length; oP.innerHTML = arrText[num]; for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].className = ''; &#125; aLi[num].className = 'active'; &#125; fnTab(); for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index = i; // 索引值 aLi[i][evt] = function() &#123; num = this.index; fnTab(); &#125;; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="pic1" class="box"&gt; &lt;img src="" /&gt; &lt;span&gt;数量正在加载中……&lt;/span&gt; &lt;p&gt;文字说明正在加载中……&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;div id="pic2" class="box"&gt; &lt;img src="" /&gt; &lt;span&gt;数量正在加载中……&lt;/span&gt; &lt;p&gt;文字说明正在加载中……&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 应用：仿淘宝购物车计算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oUl = document.getElementById('list'); var aLi = oUl.getElementsByTagName('li'); for (var i = 0; i &lt; aLi.length; i++) &#123; fn1(aLi[i]); &#125; function fn1(oLi) &#123; var aBtn = oLi.getElementsByTagName('input'); var oStrong = oLi.getElementsByTagName('strong')[0]; var oEm = oLi.getElementsByTagName('em')[0]; var oSpan = oLi.getElementsByTagName('span')[0]; var n1 = Number(oStrong.innerHTML); //动态获取 '0' =&gt; 0 var n2 = parseFloat(oEm.innerHTML); //动态获取 '12.5元' =&gt; 12.5 aBtn[0].onclick = function() &#123; n1--; if (n1 &lt; 0) &#123; n1 = 0; &#125; oStrong.innerHTML = n1; oSpan.innerHTML = n1 * n2 + '元'; &#125;; aBtn[1].onclick = function() &#123; n1++; oStrong.innerHTML = n1; oSpan.innerHTML = n1 * n2 + '元'; &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="list"&gt; &lt;li&gt; &lt;input type="button" value="-" /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type="button" value="+" /&gt; 单价： &lt;em&gt;12.5元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="button" value="-" /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type="button" value="+" /&gt; 单价： &lt;em&gt;10.5元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="button" value="-" /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type="button" value="+" /&gt; 单价： &lt;em&gt;8.5元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="button" value="-" /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type="button" value="+" /&gt; 单价： &lt;em&gt;8元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="button" value="-" /&gt; &lt;strong&gt;0&lt;/strong&gt; &lt;input type="button" value="+" /&gt; 单价： &lt;em&gt;14.5元&lt;/em&gt; 小计： &lt;span&gt;0元&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt; 商品合计共：0件，共花费了：0元 &lt;br /&gt; 其中最贵的商品单价是：0元 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>前端练习小项目</tag>
        <tag>函数传参</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型转换练习]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[找到合适的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; body &#123; font-size: 20px; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var arr = ['100px', 'abc' - 6, [], -98765, 34, -2, 0, '300', , function() &#123; alert(1); &#125;, null, document, [], true, '200px' - 30, '23.45元', 5, Number('abc'), function() &#123; alert(3); &#125;, 'xyz' - 90]; var ob = document.getElementsByTagName('body')[0]; var a1 = []; var a2 = []; var a3 = []; var a4 = []; var max = 0; /* 1、找到arr里所有的数字：-98765, 34, -2, 0, 5 2、找到可以转成数字的：'100px', -98765, 34, -2, 0, '300', '23.45元', 5 3、把转成数字以后，最大值判断出来：300 4、把 NaN 所在的位置找出来：1 14 17 19 */ //题目一：用函数把数字选择出来，由于NaN在数字类型，所以用ISNaN把NAN去除掉 ob.innerHTML += '&lt;br/&gt;' + '1、找到arr里所有的数字: ' for (var i = 0; i &lt; arr.length; i++) &#123; if (typeof arr[i] == 'number' &amp;&amp; !isNaN(arr[i])) &#123; a1.push(arr[i]); &#125; &#125; for (var i = 0; i &lt; a1.length; i++) &#123; ob.innerHTML += a1[i] + ' ,'; &#125; //题目二：用函数把可以数字转换的找出来，再单独找0,要把中括号去除呢 ob.innerHTML += '&lt;br/&gt;' + '2、找到可以转成数字的: ' for (var i = 0; i &lt; arr.length; i++) &#123; if (parseFloat(arr[i]) || (arr[i] == 0 &amp;&amp; typeof arr[i] == 'number')) &#123; a2.push(arr[i]); &#125; &#125; for (var i = 0; i &lt; a2.length; i++) &#123; ob.innerHTML += a2[i] + ' ,'; &#125; //题目三：用函数把可以数字转换出来，再单独找0输入 for (var i = 0; i &lt; a2.length; i++) &#123; if (parseFloat(a2[i]) || a2[i] == 0) &#123; a3.push(parseFloat(a2[i])); &#125; &#125; ob.innerHTML += '&lt;br/&gt;' + '3、把转换数字后的数组为: ' for (var i = 0; i &lt; a3.length; i++) &#123; if (max &lt; a3[i]) &#123; max = a3[i]; &#125; ob.innerHTML += a3[i] + ' ,'; &#125; ob.innerHTML += ' 排序后最大值：' + max; //题目四：把 NaN 所在的位置找出来：1 14 17 19 ob.innerHTML += '&lt;br/&gt;' + '4、把 NaN 所在的位置找出来: ' for (var i = 0; i &lt; arr.length; i++) &#123; if (isNaN(arr[i]) &amp;&amp; typeof arr[i] == 'number') &#123; a4.push(i); &#125; &#125; for (var i = 0; i &lt; a4.length; i++) &#123; ob.innerHTML += a4[i] + ' ,'; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; QQ号码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;script&gt;window.onload = function() &#123; var oText = document.getElementById('t') var oBtn = document.getElementById('b') var count = 0; oBtn.onclick = function() &#123; if (oText.value == '') &#123; alert('没有输入') count++; &#125; if (isNaN(oText.value)) &#123; alert('非数字') count++; &#125; if (oText.value.charAt(0) == 0) &#123; alert('不能有0在前面') count++; &#125; if (parseFloat(oText.value) != parseInt(oText.value)) &#123; alert('不能是小数') count++; &#125; if (oText.value.length &lt; 5 || oText.value.length &gt; 10) &#123; alert('输入的数字必须在5位以上、10位以内') count++; &#125; if (count == 0) &#123; alert('输入的号码正确呢') &#125; &#125; &#125; &lt;/script&gt; &lt;body&gt; 请输入QQ号码： &lt;input type="text" value="" id="t" /&gt; &lt;input type="button" value="判断" id="b" /&gt; &lt;br /&gt; 1、有没有输入 &lt;br /&gt; 2、输入的是不是数字 &lt;br /&gt; 3、不能有0在前面 &lt;br /&gt; 4、不能是小数 &lt;br /&gt; 5、输入的数字必须在5位以上、10位以内 &lt;br /&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>前端练习小项目</tag>
        <tag>数据类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链简介]]></title>
    <url>%2F2018%2F03%2F02%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js数据类型、类型转换]]></title>
    <url>%2F2018%2F03%2F02%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[js数据类型以及相关操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;/*ECMAScript：标准、核心HTML 标签类型：block、inline、inline-block、table……JS中的数据类型：数字、字符串、布尔、函数、对象(obj、[]、&#123;&#125;、null)、未定义typeof 判断数据类型*/var i = 100;// alert( typeof i ); // numbervar s = ' miaov ';// alert( typeof s ); // string// alert( s.length ); // 7// alert( s.charAt(3) ); // 'a'var b = true; // 布尔值：true false// alert( typeof b ); // booleanif ( true ) &#123;&#125;for ( ; false ; ) &#123; &#125;var fn = function ()&#123; alert(1); &#125;;// fn();function fn1()&#123; alert(2);&#125;// alert( fn1 );// fn1();var obj = document;// alert( typeof obj ); // object 物体、东西、对象obj.abc = 123;obj.onOff = true;obj.fn1 = function ()&#123; alert(1); &#125;;// alert( document.onOff ); // 123// obj.fn1();var arr = [ 1,2,3,4 ];// alert( arr.length );// arr[2] = 345;// alert( arr );// arr.push( 5,6,7 );// alert( arr );// alert( typeof arr ); // objectarr.abc = 999;arr.fn1 = function ()&#123; alert('ok'); &#125;;// alert( arr.abc );// arr.fn1();var json = &#123; name:'miaov', age:5 &#125;;// alert( json.name + '今年' + json.age + '岁了' );// alert( typeof json );//objectvar n = null;// alert( typeof n );//空的东西不能添加属性var u;// alert( typeof u ); // undefined 未定义// 表示你写的程序出问题了~~&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 数据类型转换(显式类型转换)字符串变成数字123456789101112131415161718192021222324252627282930313233343536373839 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var a = '+100'; // alert( a+100 ); // '100100' // alert( Number(a) ); // 100 var a1 = ' '; // alert( Number(a1) ); // 0 var a2 = true; // alert( Number(a2) ); // true-1 false-0 var a3=[]; alert(Number(a3)); //0 var a3=['']; alert(Number(a3)); //0 var a3 = [ 1 ]; // alert( Number(a3) ); // 1 var a4 = null; // alert( Number(a4) ); // 0 var a3=function()&#123;alert(1);&#125;; alert(Number(a3)); //NaN //////////////////////////////////////////////////////////////////////////// var json = &#123;&#125;; // alert( Number(json) ); //NaN var u; // alert( Number(u) ); //NaN var a3 = function ()&#123; alert(1); &#125;; // alert( Number(a3) ); // NaN &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; parseInt与parseFloat的区别与小技巧1234567891011121314151617 var b = ' 200px'; alert( parseInt(b) ); //200 默认十进制 var b = ' 200px'; alert( parseInt(b，16进制) ); //200 十六进制var b = ' 200px1234567'; alert( parseInt(b) ); //200 var c = '12.34元';// alert( parseInt(c) ); //12var c = '12.34元';// alert( parseFloat(c) ); //12.34var c = '12.3.4元';// alert( parseFloat(c) ); //12.3 验证是整数还是小数​123456var num = '200.45'; if( parseInt(num) == parseFloat(num) )&#123; alert( num + '是整数' );&#125;else&#123; alert( num + '是小数' );&#125; js中稀奇古怪的隐式类型转换1234567891011121314151617181920212223242526&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; /* 显式类型转换（强制类型转换）： Number() parseInt() parseFloat() 隐式类型转换： + 200 + '3' 变成字符串 - * / % '200' - 3 变成数字 ++ -- 变成数字 &gt; &lt; 数字的比较 、字符串的比较 ! 取反 把右边的数据类型转成布尔值 == */ // alert( Number('……') ); NaN // alert( '……'-9 ); NaN // alert( '2' == 2 ); 123456789101112131415//字符串的比较 // alert( '10000000' &gt; '9' );//false 一位一位地比较 // 数字的比较与字符串的比较 // '1000000' '9' // alert( '2' == 2 ); //true 判断值，所以两个等号可以转换 alert('2'===2); //三个等号更严谨，先去判断类型，再去判断值 alert(!'ok'); //false &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; NaN1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; // JS中的数据类型：数字（NaN）、字符串、布尔、函数、对象(obj、[]、&#123;&#125;、null)、未定义 var a = Number('abc'); // alert( a ); // NaN // NaN：not a number 不是个 数字 的 数字类型 // alert( typeof (a) ); // number // 一旦写程序中出现：NaN 肯定进行了非法的运算操作 // alert( '200px' - 100 ); // NaN 是 false if (a) &#123; alert( '真' ); &#125; else &#123; alert( '假' ); &#125; var abc = []; // alert( abc === abc ); true // NaN 与自己都不相等！！除了NaN以外，其他的数据类型都是自己和自己相等的 alert(a === a); // false isNaN();//判断某些值是不是数字类型 不是数字true 是数字 false //在内部是根据Number来进行转换，转换之后进行判断 alert(isNaN('250'));//'250'--250--false alert(isNaN(true));//true--1--false alert(isNaN([]));//[]--0--false &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; isNaN()小应用12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aInp = document.getElementsByTagName('input'); var str = ''; aInp[1].onclick = function() &#123; str = aInp[0].value; // HTML 中拿到的内容，类型都是字符串 // alert( typeof str ); if (isNaN(str)) &#123; alert(str + '不是数字'); &#125; else &#123; alert(str + '是数字'); &#125; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" /&gt; &lt;input type="button" value="判断输入值是不是数字" /&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单实现QQ好友列表]]></title>
    <url>%2F2018%2F03%2F02%2F%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0QQ%E5%A5%BD%E5%8F%8B%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[简单实现QQ好友列表需求：实现折叠与展开，实现点击高亮显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; ul, h2 &#123; /*样式重置*/ padding: 0; margin: 0; &#125; li &#123;/* 去掉列表前面的点*/ list-style: none; &#125; #list &#123; width: 240px; border: 1px solid #333; margin: 0 auto; &#125; #list .lis &#123;&#125; #list h2 &#123; height: 30px; line-height: 30px; text-indent: 20px; background: url(img/ico1.gif) no-repeat 5px center #6FF; color: #000; &#125; #list .active &#123; background: url(img/ico2.gif) no-repeat 5px center #FF9; color: #000; &#125; #list ul &#123; display: none; &#125; #list ul li &#123; line-height: 24px; border-bottom: 1px solid #333; text-indent: 24px; &#125; #list ul .hover &#123; background: #6FF; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oUl = document.getElementById('list'); var aH2 = oUl.getElementsByTagName('h2'); var aUl = oUl.getElementsByTagName('ul'); var aLi = null; var arrLi = []; for (var i = 0; i &lt; aH2.length; i++) &#123; aH2[i].index = i; aH2[i].onclick = function() &#123; for (var i = 0; i &lt; aH2.length; i++) &#123; if (i != this.index) &#123; aUl[i].style.display = 'none'; aH2[i].className = ''; &#125; &#125; if (this.className == '') &#123; /*这里两个等号或者三个等号都可以*/ aUl[this.index].style.display = 'block'; this.className = 'active'; &#125; else &#123; aUl[this.index].style.display = 'none'; this.className = ''; &#125; &#125;; &#125; for (var i = 0; i &lt; aUl.length; i++) &#123; aLi = aUl[i].getElementsByTagName('li'); for (var j = 0; j &lt; aLi.length; j++) &#123; arrLi.push(aLi[j]); &#125; &#125; for (var i = 0; i &lt; arrLi.length; i++) &#123; arrLi[i].onclick = function() &#123; for (var i = 0; i &lt; arrLi.length; i++) &#123; if (arrLi[i] != this) &#123; arrLi[i].className = ''; &#125; &#125; if (this.className == '') &#123; this.className = 'hover'; &#125; else &#123; this.className = ''; &#125; &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="list"&gt; &lt;li class="lis"&gt; &lt;h2&gt;我的好友&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li&gt;张三&lt;/li&gt; &lt;li&gt;张三&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class="lis"&gt; &lt;h2&gt;企业好友&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;li&gt;李四&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class="lis"&gt; &lt;h2&gt;黑名单&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;张小三&lt;/li&gt; &lt;li&gt;李小四&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>前端练习小项目</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义属性]]></title>
    <url>%2F2018%2F03%2F02%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[什么是自定义属性通俗地讲，就是js往html上添加东西。js可以为任何html元素添加任意个自定义属性。例如下面程序的abc、xyz就是自定义属性 123456789101112131415161718192021222324252627&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].abc = 123; aBtn[i].xyz = true; &#125; alert(aBtn[0].abc); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="按钮1" /&gt; &lt;input type="button" value="按钮2" /&gt; &lt;input type="button" value="按钮3" /&gt;&lt;/body&gt;&lt;/html&gt; 应用1:自定义一组开关应用注意不能当作判断条件的有1、背景不能判断 2、color不能判断 3、相对路径不能当作判断条件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; li &#123; list-style: none; width: 114px; height: 140px; background: url(img/normal.png); float: left; margin-right: 20px; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var aLi = document.getElementsByTagName('li'); // var onOff = true; // 只能控制一组！ for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].onOff = true;//给每个要控制的元素都添加一个开关 aLi[i].onclick = function() &#123; // alert( this.style.background ); if (this.onOff) &#123; this.style.background = 'url(img/active.png)'; this.onOff = false; &#125; else &#123; this.style.background = 'url(img/normal.png)'; this.onOff = true; &#125; &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 应用2：获取自身递增数字及匹配数组内容相当于一个按钮就可以 控制一组东西的变化 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); var arr = ['A', 'B', 'C', 'D']; for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].num = 0; aBtn[i].onclick = function() &#123; // alert( arr[ this.num ] ); this.value = arr[this.num]; this.num++; if (this.num === arr.length) &#123; this.num = 0; &#125; &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="0" /&gt; &lt;input type="button" value="0" /&gt; &lt;input type="button" value="0" /&gt;&lt;/body&gt;&lt;/html&gt; 应用3：添加索引值、匹配数组1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; // 自定义属性（索引值） aBtn[i].onclick = function() &#123; // alert( i ); alert(this.index); //添加索引值，自定义索引值 &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="btn1" /&gt; &lt;input type="button" value="btn2" /&gt; &lt;input type="button" value="btn3" /&gt;&lt;/body&gt;&lt;/html&gt; 索引的引用想建立“匹配”“对应”关系，就用索引值 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); var arr = ['莫涛', '张森', '杜鹏']; for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; // 自定义属性（索引值） aBtn[i].onclick = function() &#123; // alert( arr[ this.index ] ); this.value = arr[this.index]; &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="btn1" /&gt; &lt;input type="button" value="btn2" /&gt; &lt;input type="button" value="btn3" /&gt;&lt;/body&gt;&lt;/html&gt; 通过索引将按钮和P匹配1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aBtn = document.getElementsByTagName('input'); var aP = document.getElementsByTagName('p'); var arr = ['马云', '马化腾', '李彦宏']; for (var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; // 自定义属性（索引值） aBtn[i].onclick = function() &#123; // alert( arr[ this.index ] ); this.value = arr[this.index]; aP[this.index].innerHTML = arr[this.index]; &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="btn1" /&gt; &lt;input type="button" value="btn2" /&gt; &lt;input type="button" value="btn3" /&gt; &lt;p&gt;a&lt;/p&gt; &lt;p&gt;b&lt;/p&gt; &lt;p&gt;c&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; hexo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; ul &#123; padding: 0; margin: 0; &#125;/*样式的重置*/ li &#123; list-style: none; &#125; body &#123; background: #333; &#125; #pic &#123; width: 400px; height: 500px; position: relative; margin: 0 auto; background: url(img/loader_ico.gif) no-repeat center #fff; &#125; #pic img &#123; width: 400px; height: 500px; &#125; #pic ul &#123; width: 40px; position: absolute; top: 0; right: -50px; &#125; #pic li &#123; width: 40px; height: 40px; margin-bottom: 4px; background: #666; &#125; #pic .active &#123; background: #FC3; &#125; #pic span &#123; top: 0; &#125; #pic p &#123; bottom: 0; margin: 0; &#125; #pic p, #pic span &#123; position: absolute; left: 0; width: 400px; height: 30px; line-height: 30px; text-align: center; color: #fff; background: #000; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oDiv = document.getElementById('pic'); var oImg = oDiv.getElementsByTagName('img')[0]; var oSpan = oDiv.getElementsByTagName('span')[0]; var oP = oDiv.getElementsByTagName('p')[0]; var oUl = oDiv.getElementsByTagName('ul')[0]; var aLi = oUl.getElementsByTagName('li'); var arrUrl = ['img/1.png', 'img/2.png', 'img/3.png', 'img/4.png']; var arrText = ['小宠物', '图片二', '图片三', '面具']; var num = 0; var oldLi = null; for (var i = 0; i &lt; arrUrl.length; i++) &#123; oUl.innerHTML += '&lt;li&gt;&lt;/li&gt;'; &#125; oldLi = aLi[num]; // 初始化 oImg.src = arrUrl[num]; oSpan.innerHTML = 1 + num + ' / ' + arrUrl.length; oP.innerHTML = arrText[num]; aLi[num].className = 'active'; for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index = i; // 索引值 aLi[i].onclick = function() &#123; oImg.src = arrUrl[this.index]; oP.innerHTML = arrText[this.index]; oSpan.innerHTML = 1 + this.index + ' / ' + arrText.length; /* &lt;li class="active"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; */ // 思路一：全部清空，当前添加 for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].className = ''; &#125; this.className = 'active'; /* // 思路二：清空上个，当前添加 oldLi.className = ''; oldLi = this; this.className = 'active'; */ &#125;; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="pic"&gt; &lt;img src="" /&gt; &lt;span&gt;数量正在加载中……&lt;/span&gt; &lt;p&gt;文字说明正在加载中……&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>自定义属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑客入门电子书整理]]></title>
    <url>%2F2018%2F03%2F01%2F%E9%BB%91%E5%AE%A2%E5%85%A5%E9%97%A8%E7%94%B5%E5%AD%90%E4%B9%A6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[黑客攻防电子书整理 链接: https://pan.baidu.com/s/1sm2fjZ3 密码: dvt3]]></content>
      <categories>
        <category>books</category>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>hacker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this指向及this应用]]></title>
    <url>%2F2018%2F02%2F28%2Fthis%E6%8C%87%E5%90%91%E5%8F%8Athis%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[thisthis可以理解为调用当前方法或者函数的那个对象，通俗地说就是谁调用了函数指的就是谁。例如下面程序的this指的是一个按钮。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; // this : 这个 // this： 指的是调用 当前 方法（函数）的那个对象 function fn1() &#123; // this &#125; // fn1(); this =&gt; window // oDiv.onclick = fn1; this =&gt; oDiv /* oDiv.onclick = function ()&#123; fn1(); fn1() 里的this =&gt; window &#125;; &lt;div onclick=" this fn1(); "&gt;&lt;/div&gt; fn1(); 里的 this 指的是 window */ // alert( this ); // object window // window 是 JS “老大” // window.alert( this ); function fn1() &#123; alert(this); // window &#125; // fn1(); // window.fn1(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btn1" type="button" value="按钮" /&gt; &lt;input id="btn2" type="button" onclick=" fn1(); " value="按钮2" /&gt; &lt;script&gt; var oBtn = document.getElementById('btn1'); // oBtn.onclick = fn1; oBtn.onclick = function() &#123; // this fn1(); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ​]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for循环遍历二维数组、嵌套元素]]></title>
    <url>%2F2018%2F02%2F28%2Ffor%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E3%80%81%E5%B5%8C%E5%A5%97%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[二维数组即数组里面的数组，例如常见的好友列表就是这种结构。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; var arr = [ [1, 2, 3, 4, '4+'], [4, 5, 6], [7, 8, 9] ]; // arr[1][2] for (var i = 0; i &lt; arr.length; i++) &#123; // arr[i][0] // arr[i][1] // arr[i][2] for (var j = 0; j &lt; arr[i].length; j++) &#123; // alert( arr[i][j] ); &#125; &#125; // for( var i=0; )&#123;&#125; // for( var i=0; )&#123;&#125; window.onload = function() &#123; var oUl = document.getElementById('list'); var aUl = oUl.getElementsByTagName('ul'); var len = aUl.length; var aLi = null; // 空 for (var i = 0; i &lt; len; i++) &#123; aLi = aUl[i].getElementsByTagName('li'); for (var j = 0; j &lt; aLi.length; j++) &#123; aLi[j].style.border = '1px solid red'; &#125; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="list"&gt; &lt;li&gt; &lt;h2&gt;我的好友&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;莫涛&lt;/li&gt; &lt;li&gt;张森&lt;/li&gt; &lt;li&gt;杜鹏&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;ol&gt; &lt;li&gt;no&lt;/li&gt; &lt;li&gt;no&lt;/li&gt; &lt;li&gt;no&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;我的白名单&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;莫小涛&lt;/li&gt; &lt;li&gt;张小森&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;ol&gt; &lt;li&gt;no&lt;/li&gt; &lt;li&gt;no&lt;/li&gt; &lt;li&gt;no&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;我的黑名单&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;莫张&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; cssText在下例中，cssText只是针对div的行间样式做修改，并没有动style里面的样式。后面的cssText会替换掉前面的cssText。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; border: 1px solid #333; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt;123&lt;/div&gt; &lt;input id="btn1" type="button" value="按钮" /&gt; &lt;script&gt; var oDiv = document.getElementById('div1'); var oBtn = document.getElementById('btn1'); oDiv.onclick = function() &#123; // oDiv.style.width = '200px'; oDiv.style.cssText = ' width:200px;height:200px;'; &#125;; oBtn.onclick = function() &#123; // oDiv.style.width = '100px'; oDiv.style.cssText = ''; //这里的cssText会替换掉上面的cssText，类似于innerHTML &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 例子：自动上生成一组新闻1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oUl = document.getElementById('list'); var arr = [ '山西省委附近多次爆炸 官方称尚不确定是恐怖袭击', '甘肃张掖明令禁止转基因 书记:无力辨别只能禁止', '多地制定雾霾预案限行限排被批治标不治本', '韩媒抱怨中国雾霾侵袭韩国 称其为"黑色灾难" ', '伊朗革命卫队高官在叙利亚当"志愿者"被杀(图)' ]; var onOff = true; oBtn.onclick = function() &#123; // oBtn.disabled = true; // oBtn.style.display = 'none'; //思路1、按钮找麻烦 // oUl.innerHTML = ''; //思路2、先清空，再生成，不过影响性能 // onOff = false; no!!!! if (onOff) &#123; //思路3、另设一个变量，做判断 // onOff = false; ok for (var i = 0; i &lt; arr.length; i++) &#123; oUl.innerHTML += '&lt;li&gt;' + arr[i] + '&lt;/li&gt;'; &#125; // onOff = false; ok &#125; onOff = false; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btn1" type="button" value="自动生成5条新闻" /&gt; &lt;ul id="list" style="border:1px solid red;"&gt;&lt;/ul&gt; &lt;script&gt; alert(document.getElementById('list').style.border); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for应用（逢十、V字）]]></title>
    <url>%2F2018%2F02%2F28%2Ffor%E5%BA%94%E7%94%A8%EF%BC%88%E9%80%A2%E5%8D%81%E3%80%81V%E5%AD%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[逢十往下一行用js生成100个div，每行十个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; div &#123; width: 50px; height: 50px; background: red; position: absolute; top: 0; left: 0; font-size: 30px; text-align: center; line-height: 50px; color: #fff; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var aDiv = document.getElementsByTagName('div'); for (var i = 0; i &lt; 100; i++) &#123; document.body.innerHTML += '&lt;div&gt;' + i + '&lt;/div&gt;'; &#125; for (var i = 0; i &lt; aDiv.length; i++) &#123; var m = i % 10; var n = parseInt(i / 10); aDiv[i].style.left = m * 50 + 'px'; aDiv[i].style.top = 10 + n * 50 + 'px'; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 小拓展：可以用这种方法来写一个元素周期表的效果小结：求余数 1document.write(1%4); //结果为1 求商 1console.info(1/4);//结果为0.25 求商，取整 1console.info(parseInt(1/4));//结果为0 天花板取整 1console.info(Math.ceil(1/4));//结果为1 地板取整 1console.info(Math.floor(1/4));//结果为0 V字形js生成20个div,用js写一个v字形图案 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; div &#123; width: 50px; height: 50px; background: red; position: absolute; top: 0; left: 0; font-size: 30px; text-align: center; line-height: 50px; color: #fff; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var aDiv = document.getElementsByTagName('div'); for (var i = 0; i &lt; 20; i++) &#123; document.body.innerHTML += '&lt;div&gt;' + i + '&lt;/div&gt;'; &#125; for (var i = 0; i &lt; aDiv.length / 2; i++) &#123; aDiv[i].style.left = i * 50 + 'px'; aDiv[i].style.top = i * 50 + 'px'; &#125; for (var i = aDiv.length / 2; i &lt; aDiv.length; i++) &#123; aDiv[i].style.left = i * 50 + 'px'; aDiv[i].style.top = 50*aDiv.length - (i+1) * 50 + 'px'; &#125; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的for循环]]></title>
    <url>%2F2018%2F02%2F26%2Fjs%E7%9A%84for%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[for应用：选取、生成、性能方法1：document.body.innerHTML添加使用这种方法添加多个元素的时候，性能不好。因为每一次添加元素的时候都要访问一次body 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload = function ()&#123; // 性能有问题！！！ for( var i=0; i&lt;6000; i++ )&#123; document.body.innerHTML += '&lt;input type="button" value="按钮" /&gt;'; &#125; &#125;;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 方法2：只访问一次body这个方法比上个方法，性能好很多，即使添加多个元素速度也很快 12345678910111213141516171819&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function ()&#123; var str = ''; for( var i=0; i&lt;6000; i++ )&#123; str += '&lt;input type="button" value="按钮" /&gt;'; &#125; document.body.innerHTML = str; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 小tips：可以利用循环来生成视频网站每个播放页面的每个第几集的按钮。 for循环生成坐标1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; div &#123; width: 50px; height: 50px; background: red; position: absolute; top: 0; left: 0; font-size: 30px; text-align: center; line-height: 50px; color: #fff; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var aDiv = document.getElementsByTagName('div'); for (var i = 0; i &lt; 11; i++) &#123; document.body.innerHTML += '&lt;div&gt;' + i + '&lt;/div&gt;'; &#125; for (var i = 0; i &lt; aDiv.length; i++) &#123; aDiv[i].style.left = 10 + i * 50 + 'px'; aDiv[i].style.top = 10 + i * 50 + 'px'; &#125; // 逢10 往下一行（小练习） // 来一个小V字形（小练习） &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; for循环遍历二维数组，嵌套元素]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>for循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片切换及函数合并]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%9B%BE%E7%89%87%E5%88%87%E6%8D%A2%E5%8F%8A%E5%87%BD%E6%95%B0%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[图片切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; p &#123; margin: 0; &#125; body &#123; text-align: center; &#125; #box &#123; width: 400px; height: 400px; border: 10px solid #ccc; margin: 50px auto 0; position: relative; &#125; a &#123; width: 40px; height: 40px; background: #fff; filter: alpha(opacity:80); opacity: 0.8; position: absolute; top: 160px; font-size: 18px; color: #000; text-align: center; line-height: 40px; text-decoration: none; &#125; a:hover &#123; filter: alpha(opacity:30); opacity: 0.3; &#125; #prev &#123; left: 10px; &#125; #next &#123; right: 10px; &#125; #p1 &#123; width: 400px; height: 30px; line-height: 30px; text-align: center; background: #000; color: #fff; font-size: 14px; filter: alpha(opacity:80); opacity: 0.8; position: absolute; bottom: 0; left: 0; &#125; strong &#123; width: 400px; height: 30px; line-height: 30px; text-align: center; background: #000; color: #fff; font-size: 14px; filter: alpha(opacity:80); opacity: 0.8; position: absolute; top: 0; left: 0; &#125; #img1 &#123; width: 400px; height: 400px; &#125; span &#123; position: absolute; width: 400px; height: 30px; line-height: 30px; text-align: center; top: -50px; left: 0; font-family: '微软雅黑'; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oPrev = document.getElementById('prev'); var oNext = document.getElementById('next'); var oP = document.getElementById('p1'); var oStrong = document.getElementById('strong1'); var oImg = document.getElementById('img1'); var aBtn = document.getElementsByTagName('input'); var arrUrl = ['img/1.jpg', 'img/2.jpg', 'img/3.jpg', 'img/4.jpg']; var arrText = ['文字一', '文字二', '文字三', '识文断字']; var num = 0; var onOff = true; aBtn[0].onclick = function() &#123; onOff = true; document.getElementsByTagName('span')[0].innerHTML = '图片可从最后一张跳转到第一张循环切换'; &#125;; aBtn[1].onclick = function() &#123; onOff = false; document.getElementsByTagName('span')[0].innerHTML = '图片只能到最后一张\或只能到第一张切换'; &#125;; // 初始化 function fnTab() &#123; oP.innerHTML = arrText[num]; oStrong.innerHTML = num + 1 + ' / ' + arrText.length; oImg.src = arrUrl[num]; &#125; fnTab(); oPrev.onclick = function() &#123; num--; if (num == -1) &#123; if (onOff) &#123; num = arrText.length - 1; &#125; else &#123; alert('这已经是第一张了，不能再往前了~~'); num = 0; &#125; //num = arrText.length-1; &#125; fnTab(); &#125;; oNext.onclick = function() &#123; num++; if (num == arrText.length) &#123; if (onOff) &#123; num = 0; &#125; else &#123; alert('已经到最后一张啦~'); num = arrText.length - 1; &#125; &#125; fnTab(); &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="循环切换" /&gt; &lt;input type="button" value="顺序切换" /&gt; &lt;div id="box"&gt;&lt;span&gt;图片可从最后一张跳转到第一张循环切换&lt;/span&gt; &lt;a id="prev" href="javascript:;"&gt; &lt;&lt;/a&gt; &lt;a id="next" href="javascript:;"&gt;&gt;&lt;/a&gt; &lt;p id="p1"&gt;图片文字加载中……&lt;/p&gt; &lt;strong id="strong1"&gt;图片数量计算中……&lt;/strong&gt; &lt;img id="img1" /&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>图片切换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态方法ByTagName]]></title>
    <url>%2F2018%2F02%2F25%2F%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95ByTagName%2F</url>
    <content type="text"><![CDATA[ById与ByTagName区别1：ById前面就只能跟document，不能跟别的元素；ByTagName前面可以跟别的元素。123var oUI=document.getElementById('list');document.getElementByTagName('li');var aLi=oUI.getElementsByTagName('li'); 区别2：ById的方法找到的是一个元素，而ByTagName方法实际上找到的是多个东西，是元素的集合，在使用TagName的时候，必须要加上中括号[],即使页面上只有一个该标签元素，其实找到的也是一个集合。也就是说以后只要见到ByTagName方法，后面必须要跟一个中括号。html部分： 1234567&lt;body&gt; &lt;ul id="list"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; js部分： 1234window.onload = function() &#123; // var oUl = document.getElementById('list'); var oUl = document.getElementsByTagName('ul')[0]; var aLi = oUl.getElementsByTagName('li'); 如在下例中，document.getElementByTagName找到的li，既包含了ul里面的li，又包含了ol里面的li。html部分： 1234567891011&lt;body&gt; &lt;ul id="list"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt;&lt;/body&gt; js部分： 123window.onload = function() &#123;document.getElementsByTagName('li');&#125; 区别3：ById是静态方法，ByTagName是动态方法 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script&gt;window.onload = function ()&#123; // document.title = 123; // document.body.innerHTML = 'abc'; var aBtn = document.getElementsByTagName('input'); // alert(aBtn.length); document.body.innerHTML = '&lt;input type="button" value="按钮" /&gt;&lt;input type="button" value="按钮" /&gt;&lt;input type="button" value="按钮" /&gt;'; // alert(aBtn.length); aBtn[0].onclick = function ()&#123; alert(1); &#125;; aBtn[1].onclick = function ()&#123; alert(1); &#125;; aBtn[2].onclick = function ()&#123; alert(1); &#125;; // 重复执行某些代码 // 每次执行的时候，有个数字在变化&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>ByTagName</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟手机短信发送]]></title>
    <url>%2F2018%2F02%2F25%2F%E6%A8%A1%E6%8B%9F%E6%89%8B%E6%9C%BA%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>练习项目</category>
      </categories>
      <tags>
        <tag>前端练习小项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js条件判断]]></title>
    <url>%2F2018%2F02%2F25%2Fjs%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>条件判断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度文库下载破解]]></title>
    <url>%2F2018%2F02%2F24%2F%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E4%B8%8B%E8%BD%BD%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js属性操作]]></title>
    <url>%2F2018%2F02%2F24%2Fjs%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[HTML的属性操作：读、写属性：属性名+属性值。 属性的读操作读操作：获取、找到。元素.属性名 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oText = document.getElementById('text1'); var oSelect = document.getElementById('select1'); oBtn.onclick = function() &#123; alert(oText.value + '在' + oSelect.value); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="text" id="text1" /&gt; &lt;select id="select1"&gt; &lt;option value="北京"&gt;北京&lt;/option&gt; &lt;option value="上海"&gt;上海&lt;/option&gt; &lt;option value="杭州"&gt;杭州&lt;/option&gt; &lt;/select&gt; &lt;input type="button" id="btn1" value="按钮" /&gt; &lt;/body&gt; &lt;/html&gt; 属性的写操作(添加)替换、修改。元素.属性名=新的值。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oText = document.getElementById('text1'); var oSelect = document.getElementById('select1'); oBtn.onclick = function() &#123; //oBtn.value='button'; //oText.value='按钮'; oText.value=oSelect.value; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="text1" /&gt; &lt;select id="select1"&gt; &lt;option value="北京"&gt;北京&lt;/option&gt; &lt;option value="上海"&gt;上海&lt;/option&gt; &lt;option value="杭州"&gt;杭州&lt;/option&gt; &lt;/select&gt; &lt;input type="button" id="btn1" value="按钮" /&gt;&lt;/body&gt;&lt;/html&gt; 读写操作结合的例子在文本框中输入图片地址，点击按钮切换图片。 123456789101112131415161718192021222324252627&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oText = document.getElementById('text1'); var oImg = document.getElementById('img1'); oBtn.onclick = function() &#123; oImg.src = oText.value; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="text1" type="text" /&gt; &lt;input id="btn1" type="button" value="按钮" /&gt; &lt;p id="p1"&gt;这是一些文字&lt;/p&gt; &lt;img id="img1" src="img/1.jpg" width="200" /&gt;&lt;/body&gt;&lt;/html&gt; innerHTML元素.innerHTML:可以读取元素内的所有HTML代码。元素.innerHTML=新的值：修改或者替换元素内的所有HTML内容。12345678910111213141516171819202122232425262728&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oText = document.getElementById('text1'); var oP = document.getElementById('p1'); oBtn.onclick = function() &#123; // oImg.src = oText.value; // alert( oP.innerHTML ); oP.innerHTML = oText.value; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="text1" type="text" /&gt; &lt;input id="btn1" type="button" value="按钮" /&gt; &lt;p id="p1"&gt;这是一些文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 例子:属性读写操作配合innerHTML1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style&gt;#div1 &#123; width:240px; height:200px; border:1px solid #333; background:#f1f1f1; padding:10px; &#125;&lt;/style&gt;&lt;script&gt;window.onload = function ()&#123; var oDiv = document.getElementById('div1'); var oStrong = document.getElementById('strong1'); var oText = document.getElementById('text1'); var oBtn = document.getElementById('btn1'); oBtn.onclick = function ()&#123; // 原来的内容，你得给我留着，然后再加上新内容 // a = a + b // a += b // 添加：+= // oDiv.innerHTML = oDiv.innerHTML + oText.value + '&lt;br /&gt;'; oDiv.innerHTML += oStrong.innerHTML + oText.value + '&lt;br /&gt;'; oText.value = ''; &#125;;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;strong id="strong1"&gt;张三：&lt;/strong&gt;&lt;input id="text1" type="text" /&gt;&lt;input id="btn1" type="button" value="提交" /&gt;&lt;/body&gt;&lt;/html&gt; 属性操作注意事项JS中不允许出现“-”，都是去掉“-”，后面的单词的首字母大写。如：font-size fontSizepadding-top paddingTopmargin-left marginLeft1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn1 = document.getElementById('btn1'); var oBtn2 = document.getElementById('btn2'); var oP = document.getElementById('p1'); var num = 14; oBtn1.onclick = function() &#123; num -= 2; oP.style.fontSize = num + 'px'; &#125;; oBtn2.onclick = function() &#123; num += 2; oP.style.fontSize = num + 'px'; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btn1" type="button" value="-" /&gt; &lt;input id="btn2" type="button" value="+" /&gt; &lt;p id="p1" style="font-size:16px;"&gt;10月28日晚，中央纪委监察部官网发布消息，贵州省委常委、遵义市委书记廖少华因涉嫌严重违纪违法接受组织调查。3天后中组部宣布对其免职。廖成为十八大后中纪委一连串"打虎"行动中第十一位落马的副省部级以上高官。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; js中的class作为保留字，不能用，样式名用className1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn1 = document.getElementById('btn1'); var oBtn2 = document.getElementById('btn2'); var oBtn3 = document.getElementById('btn3'); var oBtn4 = document.getElementById('btn4'); var oP = document.getElementById('p1'); var num = 14; oBtn1.onclick = function() &#123; num -= 2; oP.style.fontSize = num + 'px'; &#125;; oBtn2.onclick = function() &#123; num += 2; oP.style.fontSize = num + 'px'; &#125;; oBtn3.onclick = function() &#123; oP.className = 'red'; &#125;; oBtn4.onclick = function() &#123; oP.className = 'yellow'; &#125;; &#125;; &lt;/script&gt; &lt;style&gt; .red &#123; width: 400px; border: 10px solid #333; background: red; padding: 20px; color: yellow; &#125; .yellow &#123; width: 500px; border: 5px solid #333; background: yellow; padding: 10px; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="btn1" type="button" value="-" /&gt; &lt;input id="btn2" type="button" value="+" /&gt; &lt;input id="btn3" type="button" value="红" /&gt; &lt;input id="btn4" type="button" value="黄" /&gt; &lt;p id="p1" style="font-size:16px;"&gt;10月28日晚，中央纪委监察部官网发布消息，贵州省委常委、遵义市委书记廖少华因涉嫌严重违纪违法接受组织调查。3天后中组部宣布对其免职。廖成为十八大后中纪委一连串"打虎"行动中第十一位落马的副省部级以上高官。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 不能作为判断条件的有:1、所有的相对路径地址:img src href2、颜色值：color：red #f00 rgb(100,0,0)3、innerHTML不能拿来做判断 js修改input的type(ie6/7/8无效)点击按钮变成复选框的例子： 1234567&lt;input id="inp1" type="button"/&gt;&lt;script&gt;var olp=document.getElementById('inp1');olnp.onclick=function()&#123; olnp.type='checkbox'; //注意：这里在ie6/7/8会报错！！！&#125;&lt;/script&gt; 如果要做上面那个效果，还要兼容ie6/7/8，可以这样巧妙地回避：点击按钮，让按钮隐藏起来，checkbox本来是隐藏的，点击按钮之后让他显示出来。 浮动想要一个元素浮动，在IE下用styleFloat,非IE下用cssFloat,简而言之就是下面这样：同时写两句 123456789101112131415161718192021222324252627282930313233343536373839404142434445 oDiv.style.styleFloat='left'; //兼容IE浏览器 oDiv.style.cssFloat='left'; //兼容非IE浏览器下 ``` 还可以采用下面的方法：通过改class，来修改浮动。 ``` javascript .left&#123;float:left;&#125; .right&#123;float:right;&#125; ``` #### 点后面的值无法修改 ```html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oAttr = document.getElementById('attr'); var oVal = document.getElementById('val'); var oBtn = document.getElementById('btn1'); var oDiv = document.getElementById('div1'); oBtn.onclick = function() &#123; oDiv.style[oAttr.value] = oVal.value; //中括号里面的值可以随便改 //js中允许把点换成[] &#125; &#125; &lt;/script&gt; 请输入属性名称： &lt;input type="text" id="attr" /&gt; &lt;br/&gt; 请输入属性值： &lt;input type="text" id="val" /&gt; &lt;input type="button" value="确定" id="btn1" /&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>属性操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端利器——6款开源web性能优化辅助工具]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%89%8D%E7%AB%AF%E5%88%A9%E5%99%A8%E2%80%94%E2%80%946%E6%AC%BE%E5%BC%80%E6%BA%90web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Web 性能优化是一个老生常谈的话题，也是前端页面开发十分重要的部分。当页面加载速度越慢，用户流失的概率就越大，性能和交互直接影响用户体验。下面推荐几款 Web 性能优化辅助工具推荐，希望能对大家有所帮助 LighthouseLighthouse 是 Google 开源的一个自动化工具，用于改进网络应用的质量。你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 当为 Lighthouse 提供一个要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。可以参考失败的测试，看看可以采取哪些措施来改进应用。 Chrom 扩展则会把报告以非常人性化的图形界面展示给你。 传送门：www.oschina.net/p/lighthouse Speed RacerSpeedRacer 是一款性能测试工具，它在 Chrome 中运行脚本，并生成详细的性能报告。 SpeedRacer 是直接借助浏览器来实际测试性能的工具，在实际工作中，可以与其它模拟用户访问流量来评估性能的工具配合使用。 传送门：https://github.com/speedracer/speedracer Yellow Lab ToolsYellow Lab Tools 是一款 Web 性能及前端质量测试工具。与其他工具不同的是，它有一些在其他工具上无法看到的独特功能，例如页面加载时 JavaScript 与 DOM 互动和其他程序代码验证问题。 Yellow Lab Tools 偏向于一个发现不良实践的工具，会综合页面权重、请求数、DOM、错误的 Javascript、错误的 CSS 等方面取得一个评分。并显示出在加载页面的过程中，DOM 是如何相互影响。 传送门：https://yellowlab.tools/ Web Tracing FrameworkWeb Tracing Framework 也是 Google 推出的一组用于跟踪和调查复杂 Web 应用的库、工具和可视化工具合集。它可以帮助发现性能问题，跟踪回归，并构建流畅的 60fps Web 应用。能让你花更少时间来测试代码即可。 传送门：www.oschina.net/p/tracing-framework grunt-perfbudgetgrunt-perfbudget 是一款用于评估性能的 Grunt task，它使用 WebPagetest 的公有或私有实例在特定的 URL 进行测试，并将测试结果和你预期的性能期望做比较。 如果小于预期，那么这个 task 就顺利完成了，如果超过了预期的性能期望，那么就会报告失败，并帮助你分析超出预期的原因。 传送门：https://github.com/tkadlec/grunt-perfbudget Sitespeed.ioSitespeed.io 是一组基于最佳实践以及一些加载时序等量化标准的开源工具，用以帮助开发者分析网页的加载速度和渲染性能。 Sitespeed.io 从开发者的站点收集多个页面的数据，并根据最佳实践等规则来分析这些网页，然后将结果以 HTML 的形式输出，或者以数值的形式发送到 Graphite 。 传送门：https://www-origin.sitespeed.io/]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>工具</tag>
        <tag>web性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客添加feed]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed%2F</url>
    <content type="text"><![CDATA[安装hexo-generator-feed 1$ npm install hexo-generator-feed --save 配置到站点配置文件_config.yml 12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 最后，在你next主题下的_config.yml下，添加RSS订阅链接即可： rss: /atom.xml]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>feed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客添加站点地图]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[安装hexo-generator-seo-friendly-sitemap 1$ npm install hexo-generator-seo-friendly-sitemap --save 在站点配置文件_config.yml中添加 12sitemap: path: sitemap.xml]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>站点地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加站内搜索]]></title>
    <url>%2F2018%2F02%2F23%2Fhexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 安装步骤安装hexo-generator-search在站点的根目录下执行： $ npm install hexo-generator-search --save 安装hexo-generator-searchdb在站点的根目录下执行： $ npm install hexo-generator-searchdb --save 启用搜索编辑站点配置文件，加入以下代码： search: path: search.xml field: post format: html limit: 10000]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素各种位置宽高]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%85%83%E7%B4%A0%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%AE%BD%E9%AB%98%2F</url>
    <content type="text"><![CDATA[offsetLeftoffsetLeft[Top]:只读，属性，当前元素到定位父级的距离（偏移值），就是到当前元素的offsetParent的距离。 当前元素没有定位，但是有定位父级css部分： 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green;position: relative;&#125;#div3 &#123;background: orange; &#125;&lt;/style&gt; js部分： 1234window.onload = function() &#123; var oDiv3 = document.getElementById('div3'); alert( oDiv3.offsetLeft ); &#125; html部分: 1234567&lt;body id="body1"&gt; &lt;div id="div1"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 上述代码在ie11和Ie7的效果如下两图所示，可以得出结论： 在ie7下，如果自己没有定位，那么offsetLeft[Top]是到body的距离。 所以会显示100px 当前元素有定位的情况，且定位父级css部分: 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green;position: relative;&#125;#div3 &#123;background: orange;position: relative; &#125;&lt;/style&gt; 其余部分代码同上个例子。ie11的效果同上个例子，但是Ie7的效果发生了变化，当前元素有定位的情况下，是到定位父级的距离。 当前元素有定位，但是没有定位父级当前元素如果没有定位父级，offsetLeft默认的情况下是到body的，但是在Ie7下是指向到html的(在ie7以下body的默认margin-left值是10px)。css部分: 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green;&#125;#div3 &#123;background: orange;position: relative; &#125;&lt;/style&gt; 其余部分代码同例子一。 offsetTopcss部分： 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green;&#125;#div3 &#123;background: orange;position: relative; &#125;&lt;/style&gt; js部分: 1234window.onload = function() &#123; var oDiv3 = document.getElementById('div3'); alert( oDiv3.offsetLeft ); &#125; 效果如下,得出结论：ie7下的html默认margin-top是15px 小结如果有定位父级：ie7以下：如果自己没有定位，那么offsetLeft[Top]是到body的距离；如果自己有定位，那么就是到定位父级的距离。其他浏览器：到定位父级的距离。 元素宽高html部分： 123&lt;body&gt; &lt;div id="div1" style="width: 100px; height: 100px; border: 1px solid red; padding: 10px; margin: 10px;"&gt;&lt;/div&gt;&lt;/body&gt; js部分: 12345678&lt;script&gt;window.onload = function() &#123; var oDiv = document.getElementById('div1');alert( oDiv.style.width ); //样式宽100alert( oDiv.clientWidth ); //样式宽 + padding=可视区宽 120alert( oDiv.offsetWidth ); //样式宽 + padding + border 可视区宽 + 边框 122 &#125; &lt;script&gt; 得到三个宽度分别为:]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[父节点]]></title>
    <url>%2F2018%2F02%2F22%2F%E7%88%B6%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[元素.parentNode元素.parentNode:只读，属性，当前节点的父级节点，一个元素的父节点只有一个。在标准下和非标准下都可以，没有什么兼容问题。js部分： 1234window.onload = function() &#123;var oDiv3 = document.getElementById('div3');alert( oDiv3.parentNode.id );&#125; html部分：1234567body id="body1"&gt; &lt;div id="div1"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 在标准ie和非标准ie下，div3的父级都是div2，没有什么兼容性问题。 元素.offsetParent元素.offsetParent:只读，属性，有定位的父节点。如果多个父节点有定位，就是离它最近的有定位的父节点。如果没有定位父级，默认是body。 没有定位父级的例子css部分: 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green; zoom: 1;&#125;#div3 &#123;background: orange;&#125;&lt;/style&gt; js部分： 12345&lt;script&gt;window.onload = function() &#123; var oDiv3 = document.getElementById('div3'); alert( oDiv3.offsetParent ); &#125; html部分： 1234567&lt;body id="body1"&gt; &lt;div id="div1"&gt; &lt;div id="div2"&gt; &lt;div id="div3"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; ​ 加了定位属性的例子css部分: 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green; zoom: 1;position: relative;&#125;#div3 &#123;background: orange;&#125;&lt;/style&gt; js部分： 1234window.onload = function() &#123; var oDiv3 = document.getElementById('div3'); alert( oDiv3.offsetParent.id ); &#125; 展示效果如下，可以看出，div2加了定位属性之后，div3的offsetParent就变成了div2,而不是body了。 ie7以下，当前元素有定位例子ie7以下，如果当前元素没有定位默认是body，如果有定位则是html.css部分： 123456 &lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green; zoom: 1;&#125;#div3 &#123;background: orange;position: relative;&#125;&lt;/style&gt; js部分： 1234window.onload = function() &#123; var oDiv3 = document.getElementById('div3'); alert( oDiv3.offsetParent.tagName ); &#125; 在ie11的效果如下图： 在ie7及以下的效果如下图: ie7以下，当前元素某个父级触发layoutie7以下，如果当前元素的某个父级触发了layout，那么offsetParent就会指向到触发了layout特性的父节点上。css部分： 123456&lt;style&gt;div &#123;padding: 40px 50px;&#125;#div1 &#123;background: red;&#125;#div2 &#123;background: green; zoom: 1;&#125;#div3 &#123;background: orange;&#125;&lt;/style&gt; js部分： 123window.onload = function() &#123; alert( oDiv3.offsetParent.id); &#125; 效果如下所示，因为div2有zoom属性，zoom触发了layout,所以div3的offsetParent是触发了layout特性的父节点div2]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>父节点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子节点和兄弟节点的操作]]></title>
    <url>%2F2018%2F02%2F21%2F%E5%AD%90%E8%8A%82%E7%82%B9%E5%92%8C%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[元素.firstChild元素.firstChild:只读，属性，第一个子节点 12345678&lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 添加下列代码来显示第一个子节点 下图说明在标准ie浏览器下:firstChild会包含文本类型的节点；在非标准的ie下：只包含元素节点 1alert( oUl.firstChild ); 元素.firstElementChild元素.firstElementChild:只读，属性，标准下获取第一个元素类型的子节点（所以在非标准的ie下是不支持这个属性的),所以非标准下会输出下图所示undefined 可以用以下代码，这样的话在标准下和非标准下都可以正常。 12345 if ( oUl.firstElementChild ) &#123; oUl.firstElementChild.style.background = 'red'; //在标准浏览器下&#125; else &#123; oUl.firstChild.style.background = 'red'; //在非标准ie下&#125; 简化这段代码： 123456var oFirst=oUl.firstElementChild || oUl.firstChild;if(oFirst)&#123; oFirst.style.background='red';&#125;else&#123; alert('没有子节点可以设置'); &#125; 元素.lastChild || 元素.lastElementChild元素.lastChild || 元素.lastElementChild:最后一个子节点 123456var oLast=oUl.lastElementChild || oUl.lastChild;if(oLast)&#123; oLast.style.background='yellow';&#125;else&#123; alert('没有子节点可以设置'); &#125; 元素.nextSibling || 元素.nextElementSibling元素.nextSibling || 元素.nextElementSibling:下一个兄弟节点 12var oNext=oFirst.nextElementSibling || oFirst.nextSibling; oNext.style.background='blue'; 元素.previousSibling || 元素.previousElementSibling元素.previousSibling || 元素.previousElementSibling：上一个兄弟节点 12var oPrev=oLast.previousElementSibling || oLast.previousSibling; oPrev.style.background='orange';]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
        <tag>前端</tag>
        <tag>子节点和兄弟节点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM之childNodes]]></title>
    <url>%2F2018%2F02%2F21%2FDOM%E4%B9%8BchildNodes%2F</url>
    <content type="text"><![CDATA[写在前面的话：工作当中不太推荐使用childNodes，兼容性问题比较多。推荐使用childrenDOM是javascript操作网页的接口，全称为文档对象模型（Document Object Model）。它的作用是将网页转为一个JavaScript对象，从而可以使用JavaScript对网页进行各种操作（比如增删内容）。浏览器会根据DOM模型，将HTML文档解析成一系列的节点，再由这些节点组成一个树状结构。DOM的最小组成单位叫做节点（node），文档的树形结构由12种类型的节点组成。 小结：一般地，节点至少拥有nodeType、nodeName和nodeValue这三个基本属性。节点类型不同，三个属性的值也不相同。 childNodes 子节点元素.childNodes为子节点列表集合（只读），注意childNodes只包含一级子节点，不包含后辈孙级以下的节点。 nodeType 节点类型nodeType属性返回节点类型的常数值(无符号短整型)。不同的类型对应不同的常数值，12种类型分别对应12种不同的常数值 节点类型 名称 对应的常数值 元素节点 Node.ELEMENT_NODE 1 属性节点 Node.ATTRIBUTE_NODE 2 文本节点 Node.TEXT_NODE 3 CDATA节点 Node.CDATA_SECTION_NODE 4 实体引用名称节点 Node.ENTRY_REFERENCE_NODE 5 实体名称节点 Node.ENTITY_NODE 6 处理指令节点 Node.PROCESSING_INSTRUCTION_NODE 7 注释节点 Node.COMMENT_NODE 8 文档节点 Node.DOCUMENT_NODE 9 文档类型节点 Node.DOCUMENT_TYPE_NODE 10 文档片段节点 Node.DOCUMENT_FRAGMENT_NODE 11 DTD声明节点 Node.NOTATION_NODE 12 元素节点和文本节点下面这段代码在标准的ie下面显示是9个节点，在非标准的ie下显示4个节点。1234567891011121314151617181920212223&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;&lt;/title&gt;&lt;script&gt;window.onload = function() &#123; var oUl = document.getElementById('ul1'); alert( oUl.childNodes.length ); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id="ul1"&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 这是因为在标准ie下包含了文本和元素类型的节点，也会包含非法嵌套的节点。而在非标准的浏览器下，只包含元素类型的节点，ie7以下不会包含非法嵌套的节点。所以在这个例子中，在标准浏览器下，会把标签元素之间的回车换行符当作文本类型的节点（有5个）+4个元素节点，合起来就是9个；在非标准下只有4个元素节点。如果删掉其中的一个回车换行符，则会在标准浏览器下减少一个节点。区分了这一点，再看下面这个例子：12345for (var i=0; i&lt;oUl.childNodes.length; i++) &#123; oUl.childNodes[i].style.background = 'red'; &#125; 如果要循环当前oUl下的所有的子节点列表，给所有子节点加上一个背景色。则在非标准的ie下可以很正常地显示：而在标准ie下，会显示出错。这是因为回车换行符被当作文本节点，所以第0个子节点其实是一个文本，文本是没有style也没有background的属性的。 这里我们可以添加以下代码来验证第0个元素的节点类型: 1alert(oUl.childNodes[0].nodeType); 在标准ie下，显示3，说明第0个元素是文本节点。而在非标准ie下显示1，说明第0个节点是元素节点： 属性节点元素.attributes用来获取当前的属性（只读，属性列表集合) 12alert( oUl.attributes.length );获取并显示元素属性个数alert(oUl.attributes[1].value);显示属性值 children工作中推荐使用children，只读属性，子节点列表集合。和child差不多，有一点区别就是： 12345678910&lt;body&gt; &lt;ul id="ul1" &gt; &lt;li&gt;11111 &lt;span&gt;span&lt;/span&gt;&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;p&gt;pppppppp&lt;/p&gt; &lt;/ul&gt;&lt;/body&gt; 上述这段代码，在标准ie下，显示的children.length为5，可以看出使用children的时候不会再把文本节点算进去了，但是把非法嵌套的P也包括进去了 而在非标准ie下，显示的children.length为4，这是因为p没有算进去，不认这种非法嵌套。]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XHTML+CSS2笔记1]]></title>
    <url>%2F2018%2F02%2F20%2FXHTML-CSS2%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[H5标签兼容性解决方案]]></title>
    <url>%2F2018%2F02%2F20%2FH5%E6%A0%87%E7%AD%BE%E5%85%BC%E5%AE%B9%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[H5的语义化标签以及属性，可以让开发者非常方便地实现清晰的web页面布局，加上css3的效果渲染，快速建立web页面就容易多了。H5的新增标签有：http://www.w3school.com.cn/html5/html5_reference.asp使用这些标签可以使代码语义化更加直观，而且更方便seo优化，但是H5新标签在ie6/7/8上并不能识别，这里使用JavaScript来解决兼容性问题。一、原理说明 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; header &#123; width: 200px; height: 200px; background-color: red; &#125; section &#123; width: 150px; height: 150px; background-color: yellow; &#125; footer &#123; width: 100px; height: 100px; background-color: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;header&lt;/header&gt; &lt;section&gt;section&lt;/section&gt; &lt;footer&gt;footer&lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; 例如上面这段代使用了header、section、footer标签，这几个H5的标签在ie7浏览器下打开是这个样子的: 这是因为这几个H5的标签在ie以下的浏览器并不兼容，所以显示不出来样式。解决方法：用js来自定义这三个H5标签，但是因为自定义标签默认为内联样式（不支持宽高的设置，靠内容充满),所以看到的如下所示:12345&lt;script type="text/javascript"&gt;document.createElement("header"); document.createElement("section");document.createElement("footer");&lt;/script&gt; 如果要以块级元素显示，显示宽高，则在每个样式里面添加代码display：block; 二、解决方案1:引用js成熟的库–html5shiv.js在之间直接添加以下代码:​1&lt;script type="text/javascript" src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"&gt;&lt;/script&gt; ​ 或者直接添加: 123&lt;!--[if lt IE 9]&gt;&lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt;&lt;![endif]--&gt; 三、解决方案2：自己coding js 123456789101112&lt;script&gt; (function() &#123; if (! /*@cc_on!@*/ 0) return; var e = “abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video”.split(‘, ‘); var i= e.length; while (i–)&#123; document.createElement(e[i]) &#125; &#125;)() &lt;/script&gt; 不管你用上面哪种方式，请记得在CSS中进行如下定义，目的是让这些标签成为块状元素，just like div。 12/*html5*/article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123;display:block&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>H5标签</tag>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你github+hexo搭建博客（基础篇）]]></title>
    <url>%2F2018%2F02%2F14%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[(更新)hexo+github博客搭建进阶指南]]></title>
    <url>%2F2018%2F02%2F13%2Fgithub-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[[TOC] 在右上角或者左上角实现fork me on github点击 这里 或者 这里选择自己喜欢的样式，并复制相应的代码。然后复制代码到themes/next/layout/_layout.swig文件中，放置在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面，并把href改为你的GitHub地址。 添加RSS 切换到你博客文件夹的根目录下，然后在git bash里面输入以下代码，安装模块 npm install --save hexo-generator-feed 然后打开站点配置文件，在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！) #3、添加动态背景实现点击出现桃心效果 修改文章内链接文本样式修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记修改作者头像并旋转博文压缩修改“代码块自定义样式侧边栏社交小图标设置主页文章添加阴影效果在网站底部加上访问量添加热度网站底部字数统计添加 README.md 文件设置网站的图标Favicon实现统计功能添加顶部加载条在文章底部增加版权信息添加网易云跟帖(跟帖关闭，已失效，改为来必力)隐藏网页底部powered By Hexo / 强力驱动修改网页底部的桃心文章加密访问添加jiathis分享博文置顶修改字体大小修改打赏字体不闪动自定义鼠标样式为博客加上萌萌的宠物DaoVoice 在线联系点击爆炸效果]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>github</tag>
        <tag>hxo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九大排序算法总结]]></title>
    <url>%2F2018%2F02%2F13%2Fercha%2F</url>
    <content type="text"><![CDATA[主要有以下32种： 在右上角或者左上角实现fork me on github添加RSS添加动态背景实现点击出现桃心效果修改文章内链接文本样式修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记修改作者头像并旋转博文压缩修改“代码块自定义样式侧边栏社交小图标设置主页文章添加阴影效果在网站底部加上访问量添加热度网站底部字数统计添加 README.md 文件设置网站的图标Favicon实现统计功能添加顶部加载条在文章底部增加版权信息添加网易云跟帖(跟帖关闭，已失效，改为来必力)隐藏网页底部powered By Hexo / 强力驱动修改网页底部的桃心文章加密访问添加jiathis分享博文置顶修改字体大小修改打赏字体不闪动自定义鼠标样式为博客加上萌萌的宠物DaoVoice 在线联系点击爆炸效果]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青蛙旅行破解版]]></title>
    <url>%2F2018%2F02%2F13%2Fqingwa%2F</url>
    <content type="text"><![CDATA[链接 密码 gggg hhhhhhhhhhhhh aaaaaaaaaaaaaa aadddddddddddddd rrrrrrrrrrrrrrrrrr ggggggggggggggggg]]></content>
      <categories>
        <category>android</category>
        <category>逆向</category>
        <category>破解</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>破解</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM浅谈]]></title>
    <url>%2F2018%2F02%2F02%2FDOM%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[先附上一个DOM的教程：http://www.w3school.com.cn/htmldom/dom_methods.asp DOM的结构实际上和数据结构里面的树非常相似 方法 描述getElementById() 返回带有指定 ID 的元素。getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。appendChild() 把新的子节点添加到指定节点。removeChild() 删除子节点。replaceChild() 替换子节点。insertBefore() 在指定的子节点前面插入新的子节点。createAttribute() 创建属性节点。createElement() 创建元素节点。createTextNode() 创建文本节点。getAttribute() 返回指定的属性值。setAttribute() 把指定属性设置或修改为指定的值。 ·其他细节修改Copyright：isabllezhou mail:isabellezhou@163.com]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
