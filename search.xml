<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js属性操作]]></title>
    <url>%2F2018%2F02%2F24%2Fjs%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[HTML的属性操作：读、写属性：属性名+属性值。 属性的读操作读操作：获取、找到。元素.属性名 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn1&apos;); var oText = document.getElementById(&apos;text1&apos;); var oSelect = document.getElementById(&apos;select1&apos;); oBtn.onclick = function() { alert(oText.value + &apos;在&apos; + oSelect.value); } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;text1&quot; /&gt; &lt;select id=&quot;select1&quot;&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;杭州&quot;&gt;杭州&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;按钮&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 属性的写操作(添加)替换、修改。元素.属性名=新的值。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn1&apos;); var oText = document.getElementById(&apos;text1&apos;); var oSelect = document.getElementById(&apos;select1&apos;); oBtn.onclick = function() { //oBtn.value=&apos;button&apos;; //oText.value=&apos;按钮&apos;; oText.value=oSelect.value; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;text1&quot; /&gt; &lt;select id=&quot;select1&quot;&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;杭州&quot;&gt;杭州&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;按钮&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 读写操作结合的例子在文本框中输入图片地址，点击按钮切换图片。 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn1&apos;); var oText = document.getElementById(&apos;text1&apos;); var oImg = document.getElementById(&apos;img1&apos;); oBtn.onclick = function() { oImg.src = oText.value; }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=&quot;text1&quot; type=&quot;text&quot; /&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;按钮&quot; /&gt; &lt;p id=&quot;p1&quot;&gt;这是一些文字&lt;/p&gt; &lt;img id=&quot;img1&quot; src=&quot;img/1.jpg&quot; width=&quot;200&quot; /&gt; &lt;/body&gt; &lt;/html&gt; innerHTML元素.innerHTML:可以读取元素内的所有HTML代码。元素.innerHTML=新的值：修改或者替换元素内的所有HTML内容。 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var oBtn = document.getElementById(&apos;btn1&apos;); var oText = document.getElementById(&apos;text1&apos;); var oP = document.getElementById(&apos;p1&apos;); oBtn.onclick = function() { // oImg.src = oText.value; // alert( oP.innerHTML ); oP.innerHTML = oText.value; }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=&quot;text1&quot; type=&quot;text&quot; /&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;按钮&quot; /&gt; &lt;p id=&quot;p1&quot;&gt;这是一些文字&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 例子:属性读写操作配合innerHTML&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; #div1 { width:240px; height:200px; border:1px solid #333; background:#f1f1f1; padding:10px; } &lt;/style&gt; &lt;script&gt; window.onload = function (){ var oDiv = document.getElementById(&apos;div1&apos;); var oStrong = document.getElementById(&apos;strong1&apos;); var oText = document.getElementById(&apos;text1&apos;); var oBtn = document.getElementById(&apos;btn1&apos;); oBtn.onclick = function (){ // 原来的内容，你得给我留着，然后再加上新内容 // a = a + b // a += b // 添加：+= // oDiv.innerHTML = oDiv.innerHTML + oText.value + &apos;&lt;br /&gt;&apos;; oDiv.innerHTML += oStrong.innerHTML + oText.value + &apos;&lt;br /&gt;&apos;; oText.value = &apos;&apos;; }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; &lt;strong id=&quot;strong1&quot;&gt;张三：&lt;/strong&gt; &lt;input id=&quot;text1&quot; type=&quot;text&quot; /&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;提交&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 属性操作注意事项JS中不允许出现“-”，都是去掉“-”，后面的单词的首字母大写。如：font-size fontSizepadding-top paddingTopmargin-left marginLeft &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var oBtn1 = document.getElementById(&apos;btn1&apos;); var oBtn2 = document.getElementById(&apos;btn2&apos;); var oP = document.getElementById(&apos;p1&apos;); var num = 14; oBtn1.onclick = function() { num -= 2; oP.style.fontSize = num + &apos;px&apos;; }; oBtn2.onclick = function() { num += 2; oP.style.fontSize = num + &apos;px&apos;; }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;-&quot; /&gt; &lt;input id=&quot;btn2&quot; type=&quot;button&quot; value=&quot;+&quot; /&gt; &lt;p id=&quot;p1&quot; style=&quot;font-size:16px;&quot;&gt;10月28日晚，中央纪委监察部官网发布消息，贵州省委常委、遵义市委书记廖少华因涉嫌严重违纪违法接受组织调查。3天后中组部宣布对其免职。廖成为十八大后中纪委一连串&quot;打虎&quot;行动中第十一位落马的副省部级以上高官。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; js中的class作为保留字，不能用，样式名用className&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script&gt; window.onload = function() { var oBtn1 = document.getElementById(&apos;btn1&apos;); var oBtn2 = document.getElementById(&apos;btn2&apos;); var oBtn3 = document.getElementById(&apos;btn3&apos;); var oBtn4 = document.getElementById(&apos;btn4&apos;); var oP = document.getElementById(&apos;p1&apos;); var num = 14; oBtn1.onclick = function() { num -= 2; oP.style.fontSize = num + &apos;px&apos;; }; oBtn2.onclick = function() { num += 2; oP.style.fontSize = num + &apos;px&apos;; }; oBtn3.onclick = function() { oP.className = &apos;red&apos;; }; oBtn4.onclick = function() { oP.className = &apos;yellow&apos;; }; }; &lt;/script&gt; &lt;style&gt; .red { width: 400px; border: 10px solid #333; background: red; padding: 20px; color: yellow; } .yellow { width: 500px; border: 5px solid #333; background: yellow; padding: 10px; color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;-&quot; /&gt; &lt;input id=&quot;btn2&quot; type=&quot;button&quot; value=&quot;+&quot; /&gt; &lt;input id=&quot;btn3&quot; type=&quot;button&quot; value=&quot;红&quot; /&gt; &lt;input id=&quot;btn4&quot; type=&quot;button&quot; value=&quot;黄&quot; /&gt; &lt;p id=&quot;p1&quot; style=&quot;font-size:16px;&quot;&gt;10月28日晚，中央纪委监察部官网发布消息，贵州省委常委、遵义市委书记廖少华因涉嫌严重违纪违法接受组织调查。3天后中组部宣布对其免职。廖成为十八大后中纪委一连串&quot;打虎&quot;行动中第十一位落马的副省部级以上高官。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 不能作为判断条件的有:1、所有的相对路径地址:img src href2、颜色值：color：red #f00 rgb(100,0,0)3、innerHTML不能拿来做判断 js修改input的type(ie6/7/8无效)点击按钮变成复选框的例子： &lt;input id=&quot;inp1&quot; type=&quot;button&quot;/&gt; &lt;script&gt; var olp=document.getElementById(&apos;inp1&apos;); olnp.onclick=function(){ olnp.type=&apos;checkbox&apos;; //注意：这里在ie6/7/8会报错！！！ } &lt;/script&gt; 如果要做上面那个效果，还要兼容ie6/7/8，可以这样巧妙地回避：点击按钮，让按钮隐藏起来，checkbox本来是隐藏的，点击按钮之后让他显示出来。 浮动想要一个元素浮动，在IE下用styleFloat,非IE下用cssFloat,简而言之就是下面这样：同时写两句 oDiv.style.styleFloat=&apos;left&apos;; //兼容IE浏览器 oDiv.style.cssFloat=&apos;left&apos;; //兼容非IE浏览器下]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>属性操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端利器——6款开源web性能优化辅助工具]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%89%8D%E7%AB%AF%E5%88%A9%E5%99%A8%E2%80%94%E2%80%946%E6%AC%BE%E5%BC%80%E6%BA%90web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Web 性能优化是一个老生常谈的话题，也是前端页面开发十分重要的部分。当页面加载速度越慢，用户流失的概率就越大，性能和交互直接影响用户体验。下面推荐几款 Web 性能优化辅助工具推荐，希望能对大家有所帮助 LighthouseLighthouse 是 Google 开源的一个自动化工具，用于改进网络应用的质量。你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 当为 Lighthouse 提供一个要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。可以参考失败的测试，看看可以采取哪些措施来改进应用。 Chrom 扩展则会把报告以非常人性化的图形界面展示给你。 传送门：www.oschina.net/p/lighthouse Speed RacerSpeedRacer 是一款性能测试工具，它在 Chrome 中运行脚本，并生成详细的性能报告。 SpeedRacer 是直接借助浏览器来实际测试性能的工具，在实际工作中，可以与其它模拟用户访问流量来评估性能的工具配合使用。 传送门：https://github.com/speedracer/speedracer Yellow Lab ToolsYellow Lab Tools 是一款 Web 性能及前端质量测试工具。与其他工具不同的是，它有一些在其他工具上无法看到的独特功能，例如页面加载时 JavaScript 与 DOM 互动和其他程序代码验证问题。 Yellow Lab Tools 偏向于一个发现不良实践的工具，会综合页面权重、请求数、DOM、错误的 Javascript、错误的 CSS 等方面取得一个评分。并显示出在加载页面的过程中，DOM 是如何相互影响。 传送门：https://yellowlab.tools/ Web Tracing FrameworkWeb Tracing Framework 也是 Google 推出的一组用于跟踪和调查复杂 Web 应用的库、工具和可视化工具合集。它可以帮助发现性能问题，跟踪回归，并构建流畅的 60fps Web 应用。能让你花更少时间来测试代码即可。 传送门：www.oschina.net/p/tracing-framework grunt-perfbudgetgrunt-perfbudget 是一款用于评估性能的 Grunt task，它使用 WebPagetest 的公有或私有实例在特定的 URL 进行测试，并将测试结果和你预期的性能期望做比较。 如果小于预期，那么这个 task 就顺利完成了，如果超过了预期的性能期望，那么就会报告失败，并帮助你分析超出预期的原因。 传送门：https://github.com/tkadlec/grunt-perfbudget Sitespeed.ioSitespeed.io 是一组基于最佳实践以及一些加载时序等量化标准的开源工具，用以帮助开发者分析网页的加载速度和渲染性能。 Sitespeed.io 从开发者的站点收集多个页面的数据，并根据最佳实践等规则来分析这些网页，然后将结果以 HTML 的形式输出，或者以数值的形式发送到 Graphite 。 传送门：https://www-origin.sitespeed.io/]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>web性能</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客添加feed]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed%2F</url>
    <content type="text"><![CDATA[安装hexo-generator-feed $ npm install hexo-generator-feed --save 配置到站点配置文件_config.yml # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 最后，在你next主题下的_config.yml下，添加RSS订阅链接即可： rss: /atom.xml]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>feed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客添加站点地图]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[安装hexo-generator-seo-friendly-sitemap $ npm install hexo-generator-seo-friendly-sitemap --save 在站点配置文件_config.yml中添加 sitemap: path: sitemap.xml]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>站点地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加站内搜索]]></title>
    <url>%2F2018%2F02%2F23%2Fhexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 安装步骤安装hexo-generator-search在站点的根目录下执行： $ npm install hexo-generator-search --save 安装hexo-generator-searchdb在站点的根目录下执行： $ npm install hexo-generator-searchdb --save 启用搜索编辑站点配置文件，加入以下代码： search: path: search.xml field: post format: html limit: 10000]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素各种位置宽高]]></title>
    <url>%2F2018%2F02%2F23%2F%E5%85%83%E7%B4%A0%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%AE%BD%E9%AB%98%2F</url>
    <content type="text"><![CDATA[offsetLeftoffsetLeft[Top]:只读，属性，当前元素到定位父级的距离（偏移值），就是到当前元素的offsetParent的距离。 当前元素没有定位，但是有定位父级css部分： &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green;position: relative;} #div3 {background: orange; } &lt;/style&gt; js部分： window.onload = function() { var oDiv3 = document.getElementById(&apos;div3&apos;); alert( oDiv3.offsetLeft ); } html部分: &lt;body id=&quot;body1&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt; &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 上述代码在ie11和Ie7的效果如下两图所示，可以得出结论： 在ie7下，如果自己没有定位，那么offsetLeft[Top]是到body的距离。 所以会显示100px 当前元素有定位的情况，且定位父级css部分: &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green;position: relative;} #div3 {background: orange;position: relative; } &lt;/style&gt; 其余部分代码同上个例子。ie11的效果同上个例子，但是Ie7的效果发生了变化，当前元素有定位的情况下，是到定位父级的距离。 当前元素有定位，但是没有定位父级当前元素如果没有定位父级，offsetLeft默认的情况下是到body的，但是在Ie7下是指向到html的(在ie7以下body的默认margin-left值是10px)。css部分: &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green;} #div3 {background: orange;position: relative; } &lt;/style&gt; 其余部分代码同例子一。 offsetTopcss部分： &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green;} #div3 {background: orange;position: relative; } &lt;/style&gt; js部分: window.onload = function() { var oDiv3 = document.getElementById(&apos;div3&apos;); alert( oDiv3.offsetLeft ); } 效果如下,得出结论：ie7下的html默认margin-top是15px 小结如果有定位父级：ie7以下：如果自己没有定位，那么offsetLeft[Top]是到body的距离；如果自己有定位，那么就是到定位父级的距离。其他浏览器：到定位父级的距离。 元素宽高html部分： &lt;body&gt; &lt;div id=&quot;div1&quot; style=&quot;width: 100px; height: 100px; border: 1px solid red; padding: 10px; margin: 10px;&quot;&gt;&lt;/div&gt; &lt;/body&gt; js部分: &lt;script&gt; window.onload = function() { var oDiv = document.getElementById(&apos;div1&apos;); alert( oDiv.style.width ); //样式宽100 alert( oDiv.clientWidth ); //样式宽 + padding=可视区宽 120 alert( oDiv.offsetWidth ); //样式宽 + padding + border 可视区宽 + 边框 122 } &lt;script&gt; 得到三个宽度分别为:]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[父节点]]></title>
    <url>%2F2018%2F02%2F22%2F%E7%88%B6%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[元素.parentNode元素.parentNode:只读，属性，当前节点的父级节点，一个元素的父节点只有一个。在标准下和非标准下都可以，没有什么兼容问题。js部分： window.onload = function() { var oDiv3 = document.getElementById(&apos;div3&apos;); alert( oDiv3.parentNode.id ); } html部分： body id=&quot;body1&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt; &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 在标准ie和非标准ie下，div3的父级都是div2，没有什么兼容性问题。 元素.offsetParent元素.offsetParent:只读，属性，有定位的父节点。如果多个父节点有定位，就是离它最近的有定位的父节点。如果没有定位父级，默认是body。 没有定位父级的例子css部分: &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green; zoom: 1;} #div3 {background: orange;} &lt;/style&gt; js部分： &lt;script&gt; window.onload = function() { var oDiv3 = document.getElementById(&apos;div3&apos;); alert( oDiv3.offsetParent ); } html部分： &lt;body id=&quot;body1&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;div2&quot;&gt; &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 加了定位属性的例子css部分: &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green; zoom: 1;position: relative;} #div3 {background: orange;} &lt;/style&gt; js部分： window.onload = function() { var oDiv3 = document.getElementById(&apos;div3&apos;); alert( oDiv3.offsetParent.id ); } 展示效果如下，可以看出，div2加了定位属性之后，div3的offsetParent就变成了div2,而不是body了。 ie7以下，当前元素有定位例子ie7以下，如果当前元素没有定位默认是body，如果有定位则是html.css部分： &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green; zoom: 1;} #div3 {background: orange;position: relative;} &lt;/style&gt; js部分： window.onload = function() { var oDiv3 = document.getElementById(&apos;div3&apos;); alert( oDiv3.offsetParent.tagName ); } 在ie11的效果如下图： 在ie7及以下的效果如下图: ie7以下，当前元素某个父级触发layoutie7以下，如果当前元素的某个父级触发了layout，那么offsetParent就会指向到触发了layout特性的父节点上。css部分： &lt;style&gt; div {padding: 40px 50px;} #div1 {background: red;} #div2 {background: green; zoom: 1;} #div3 {background: orange;} &lt;/style&gt; js部分： window.onload = function() { alert( oDiv3.offsetParent.id); } 效果如下所示，因为div2有zoom属性，zoom触发了layout,所以div3的offsetParent是触发了layout特性的父节点div2]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>父节点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子节点和兄弟节点的操作]]></title>
    <url>%2F2018%2F02%2F21%2F%E5%AD%90%E8%8A%82%E7%82%B9%E5%92%8C%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[元素.firstChild元素.firstChild:只读，属性，第一个子节点 &lt;body&gt; &lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; 添加下列代码来显示第一个子节点 下图说明在标准ie浏览器下:firstChild会包含文本类型的节点；在非标准的ie下：只包含元素节点 alert( oUl.firstChild ); 元素.firstElementChild元素.firstElementChild:只读，属性，标准下获取第一个元素类型的子节点（所以在非标准的ie下是不支持这个属性的),所以非标准下会输出下图所示undefined 可以用以下代码，这样的话在标准下和非标准下都可以正常。 if ( oUl.firstElementChild ) { oUl.firstElementChild.style.background = &apos;red&apos;; //在标准浏览器下 } else { oUl.firstChild.style.background = &apos;red&apos;; //在非标准ie下 } 简化这段代码： var oFirst=oUl.firstElementChild || oUl.firstChild; if(oFirst){ oFirst.style.background=&apos;red&apos;; }else{ alert(&apos;没有子节点可以设置&apos;); } 元素.lastChild || 元素.lastElementChild元素.lastChild || 元素.lastElementChild:最后一个子节点 var oLast=oUl.lastElementChild || oUl.lastChild; if(oLast){ oLast.style.background=&apos;yellow&apos;; }else{ alert(&apos;没有子节点可以设置&apos;); } 元素.nextSibling || 元素.nextElementSibling元素.nextSibling || 元素.nextElementSibling:下一个兄弟节点 var oNext=oFirst.nextElementSibling || oFirst.nextSibling; oNext.style.background=&apos;blue&apos;; 元素.previousSibling || 元素.previousElementSibling元素.previousSibling || 元素.previousElementSibling：上一个兄弟节点 var oPrev=oLast.previousElementSibling || oLast.previousSibling; oPrev.style.background=&apos;orange&apos;;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
        <tag>前端</tag>
        <tag>子节点和兄弟节点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM之childNodes]]></title>
    <url>%2F2018%2F02%2F21%2FDOM%E4%B9%8BchildNodes%2F</url>
    <content type="text"><![CDATA[写在前面的话：工作当中不太推荐使用childNodes，兼容性问题比较多。推荐使用childrenDOM是javascript操作网页的接口，全称为文档对象模型（Document Object Model）。它的作用是将网页转为一个JavaScript对象，从而可以使用JavaScript对网页进行各种操作（比如增删内容）。浏览器会根据DOM模型，将HTML文档解析成一系列的节点，再由这些节点组成一个树状结构。DOM的最小组成单位叫做节点（node），文档的树形结构由12种类型的节点组成。 小结：一般地，节点至少拥有nodeType、nodeName和nodeValue这三个基本属性。节点类型不同，三个属性的值也不相同。 childNodes 子节点元素.childNodes为子节点列表集合（只读），注意childNodes只包含一级子节点，不包含后辈孙级以下的节点。 nodeType 节点类型nodeType属性返回节点类型的常数值(无符号短整型)。不同的类型对应不同的常数值，12种类型分别对应12种不同的常数值 节点类型 名称 对应的常数值 元素节点 Node.ELEMENT_NODE 1 属性节点 Node.ATTRIBUTE_NODE 2 文本节点 Node.TEXT_NODE 3 CDATA节点 Node.CDATA_SECTION_NODE 4 实体引用名称节点 Node.ENTRY_REFERENCE_NODE 5 实体名称节点 Node.ENTITY_NODE 6 处理指令节点 Node.PROCESSING_INSTRUCTION_NODE 7 注释节点 Node.COMMENT_NODE 8 文档节点 Node.DOCUMENT_NODE 9 文档类型节点 Node.DOCUMENT_TYPE_NODE 10 文档片段节点 Node.DOCUMENT_FRAGMENT_NODE 11 DTD声明节点 Node.NOTATION_NODE 12 元素节点和文本节点下面这段代码在标准的ie下面显示是9个节点，在非标准的ie下显示4个节点。1234567891011121314151617181920212223&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;script&gt;window.onload = function() &#123; var oUl = document.getElementById(&apos;ul1&apos;); alert( oUl.childNodes.length ); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 这是因为在标准ie下包含了文本和元素类型的节点，也会包含非法嵌套的节点。而在非标准的浏览器下，只包含元素类型的节点，ie7以下不会包含非法嵌套的节点。所以在这个例子中，在标准浏览器下，会把标签元素之间的回车换行符当作文本类型的节点（有5个）+4个元素节点，合起来就是9个；在非标准下只有4个元素节点。如果删掉其中的一个回车换行符，则会在标准浏览器下减少一个节点。区分了这一点，再看下面这个例子： for (var i=0; i&lt;oUl.childNodes.length; i++) { oUl.childNodes[i].style.background = &apos;red&apos;; } 如果要循环当前oUl下的所有的子节点列表，给所有子节点加上一个背景色。则在非标准的ie下可以很正常地显示：而在标准ie下，会显示出错。这是因为回车换行符被当作文本节点，所以第0个子节点其实是一个文本，文本是没有style也没有background的属性的。 这里我们可以添加以下代码来验证第0个元素的节点类型: alert(oUl.childNodes[0].nodeType); 在标准ie下，显示3，说明第0个元素是文本节点。而在非标准ie下显示1，说明第0个节点是元素节点： 属性节点元素.attributes用来获取当前的属性（只读，属性列表集合) alert( oUl.attributes.length );获取并显示元素属性个数 alert(oUl.attributes[1].value);显示属性值 children工作中推荐使用children，只读属性，子节点列表集合。和child差不多，有一点区别就是： &lt;body&gt; &lt;ul id=&quot;ul1&quot; &gt; &lt;li&gt;11111 &lt;span&gt;span&lt;/span&gt;&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;33333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt; &lt;p&gt;pppppppp&lt;/p&gt; &lt;/ul&gt; &lt;/body&gt; 上述这段代码，在标准ie下，显示的children.length为5，可以看出使用children的时候不会再把文本节点算进去了，但是把非法嵌套的P也包括进去了 而在非标准ie下，显示的children.length为4，这是因为p没有算进去，不认这种非法嵌套。]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XHTML+CSS2笔记1]]></title>
    <url>%2F2018%2F02%2F20%2FXHTML-CSS2%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[H5标签兼容性解决方案]]></title>
    <url>%2F2018%2F02%2F20%2FH5%E6%A0%87%E7%AD%BE%E5%85%BC%E5%AE%B9%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[H5的语义化标签以及属性，可以让开发者非常方便地实现清晰的web页面布局，加上css3的效果渲染，快速建立web页面就容易多了。H5的新增标签有：http://www.w3school.com.cn/html5/html5_reference.asp使用这些标签可以使代码语义化更加直观，而且更方便seo优化，但是H5新标签在ie6/7/8上并不能识别，这里使用JavaScript来解决兼容性问题。一、原理说明 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; header &#123; width: 200px; height: 200px; background-color: red; &#125; section &#123; width: 150px; height: 150px; background-color: yellow; &#125; footer &#123; width: 100px; height: 100px; background-color: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;header&lt;/header&gt; &lt;section&gt;section&lt;/section&gt; &lt;footer&gt;footer&lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; 例如上面这段代使用了header、section、footer标签，这几个H5的标签在ie7浏览器下打开是这个样子的: 这是因为这几个H5的标签在ie以下的浏览器并不兼容，所以显示不出来样式。解决方法：用js来自定义这三个H5标签，但是因为自定义标签默认为内联样式（不支持宽高的设置，靠内容充满),所以看到的如下所示:12345&lt;script type=&quot;text/javascript&quot;&gt;document.createElement(&quot;header&quot;); document.createElement(&quot;section&quot;);document.createElement(&quot;footer&quot;);&lt;/script&gt; 如果要以块级元素显示，显示宽高，则在每个样式里面添加代码display：block; 二、解决方案1:引用js成熟的库–html5shiv.js在之间直接添加以下代码: &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt; 或者直接添加: &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt; 三、解决方案2：自己coding js &lt;script&gt; (function() { if (! /*@cc_on!@*/ 0) return; var e = “abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video”.split(‘, ‘); var i= e.length; while (i–){ document.createElement(e[i]) } })() &lt;/script&gt; 不管你用上面哪种方式，请记得在CSS中进行如下定义，目的是让这些标签成为块状元素，just like div。 /*html5*/ article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block}]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>H5标签</tag>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你github+hexo搭建博客（基础篇）]]></title>
    <url>%2F2018%2F02%2F14%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[(更新)hexo+github博客搭建进阶指南]]></title>
    <url>%2F2018%2F02%2F13%2Fgithub-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[[TOC] 在右上角或者左上角实现fork me on github点击 这里 或者 这里选择自己喜欢的样式，并复制相应的代码。然后复制代码到themes/next/layout/_layout.swig文件中，放置在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面，并把href改为你的GitHub地址。 添加RSS 切换到你博客文件夹的根目录下，然后在git bash里面输入以下代码，安装模块 npm install --save hexo-generator-feed 然后打开站点配置文件，在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！) #3、添加动态背景实现点击出现桃心效果 修改文章内链接文本样式修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记修改作者头像并旋转博文压缩修改“代码块自定义样式侧边栏社交小图标设置主页文章添加阴影效果在网站底部加上访问量添加热度网站底部字数统计添加 README.md 文件设置网站的图标Favicon实现统计功能添加顶部加载条在文章底部增加版权信息添加网易云跟帖(跟帖关闭，已失效，改为来必力)隐藏网页底部powered By Hexo / 强力驱动修改网页底部的桃心文章加密访问添加jiathis分享博文置顶修改字体大小修改打赏字体不闪动自定义鼠标样式为博客加上萌萌的宠物DaoVoice 在线联系点击爆炸效果]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>github</tag>
        <tag>hxo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九大排序算法总结]]></title>
    <url>%2F2018%2F02%2F13%2Fercha%2F</url>
    <content type="text"><![CDATA[主要有以下32种： 在右上角或者左上角实现fork me on github添加RSS添加动态背景实现点击出现桃心效果修改文章内链接文本样式修改文章底部的那个带#号的标签在每篇文章末尾统一添加“本文结束”标记修改作者头像并旋转博文压缩修改“代码块自定义样式侧边栏社交小图标设置主页文章添加阴影效果在网站底部加上访问量添加热度网站底部字数统计添加 README.md 文件设置网站的图标Favicon实现统计功能添加顶部加载条在文章底部增加版权信息添加网易云跟帖(跟帖关闭，已失效，改为来必力)隐藏网页底部powered By Hexo / 强力驱动修改网页底部的桃心文章加密访问添加jiathis分享博文置顶修改字体大小修改打赏字体不闪动自定义鼠标样式为博客加上萌萌的宠物DaoVoice 在线联系点击爆炸效果]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青蛙旅行破解版]]></title>
    <url>%2F2018%2F02%2F13%2Fqingwa%2F</url>
    <content type="text"><![CDATA[链接 密码 gggg hhhhhhhhhhhhh aaaaaaaaaaaaaa aadddddddddddddd rrrrrrrrrrrrrrrrrr ggggggggggggggggg]]></content>
      <categories>
        <category>android</category>
        <category>逆向</category>
        <category>破解</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>破解</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM浅谈]]></title>
    <url>%2F2018%2F02%2F02%2FDOM%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[先附上一个DOM的教程：http://www.w3school.com.cn/htmldom/dom_methods.asp DOM的结构实际上和数据结构里面的树非常相似 方法 描述getElementById() 返回带有指定 ID 的元素。getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。appendChild() 把新的子节点添加到指定节点。removeChild() 删除子节点。replaceChild() 替换子节点。insertBefore() 在指定的子节点前面插入新的子节点。createAttribute() 创建属性节点。createElement() 创建元素节点。createTextNode() 创建文本节点。getAttribute() 返回指定的属性值。setAttribute() 把指定属性设置或修改为指定的值。 ·其他细节修改Copyright：isabllezhou mail:isabellezhou@163.com]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
